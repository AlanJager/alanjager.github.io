<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Packed virtqueue: How to reduce overhead with virtio | 花の様に</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="This is the final post of a three-post series, the previous posts are “Virtio devices and drivers overview: The headjack and the phone,” and “Virtqueues and virtio ring: How the data travels.”   这是三篇">
<meta property="og:type" content="article">
<meta property="og:title" content="Packed virtqueue: How to reduce overhead with virtio">
<meta property="og:url" content="http://hanayo.cn/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/index.html">
<meta property="og:site_name" content="花の様に">
<meta property="og:description" content="This is the final post of a three-post series, the previous posts are “Virtio devices and drivers overview: The headjack and the phone,” and “Virtqueues and virtio ring: How the data travels.”   这是三篇">
<meta property="og:locale">
<meta property="og:image" content="http://hanayo.cn/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-1.png">
<meta property="og:image" content="http://hanayo.cn/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-2.png">
<meta property="og:image" content="http://hanayo.cn/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-3.png">
<meta property="article:published_time" content="2023-02-23T15:13:20.000Z">
<meta property="article:modified_time" content="2023-02-23T15:15:29.577Z">
<meta property="article:author" content="Alan Jager">
<meta property="article:tag" content="qemu">
<meta property="article:tag" content="architecture">
<meta property="article:tag" content="virtio">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hanayo.cn/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-1.png">
  
    <link rel="alternate" href="/atom.xml" title="花の様に" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">花の様に</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanayo.cn"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-packed-virtqueue-how-to-reduce-overhead-with-virtio" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" class="article-date">
  <time class="dt-published" datetime="2023-02-23T15:13:20.000Z" itemprop="datePublished">2023-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>►<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Packed virtqueue: How to reduce overhead with virtio
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>This is the final post of a three-post series, the previous posts are “<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">Virtio devices and drivers overview: The headjack and the phone</a>,” and “<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtqueues-and-virtio-ring-how-data-travels">Virtqueues and virtio ring: How the data travels</a>.”</p>
</blockquote>
<p> 这是三篇系列文章的最后一篇，之前的文章是”<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">Virtio设备和驱动概述：头戴式耳机和手机</a>“，以及”<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtqueues-and-virtio-ring-how-data-travels">Virtqueues和virtio环：数据如何传输</a>“。</p>
<h2 id="Split-virtqueue-issues-Too-much-spinning-around"><a href="#Split-virtqueue-issues-Too-much-spinning-around" class="headerlink" title="Split virtqueue issues: Too much spinning around"></a>Split virtqueue issues: Too much spinning around</h2><blockquote>
<p>While the split virtqueue shines because of the simplicity of its design, it has a fundamental problem: The avail-used buffer cycle needs to use memory in a very sparse way. This puts pressure on the CPU cache utilization, and in the case of hardware means several PCI transactions for each descriptor.</p>
</blockquote>
<p>虽然split virtqueue因其设计的简单性而大放异彩，但它有一个基本问题：可用的缓冲区环需要以一种非常稀疏的方式使用内存。这给CPU的缓存利用率带来了压力，在硬件的情况下，意味着每个描述符都要有几个PCI事务。</p>
<blockquote>
<p>Packed virtqueue amends it by merging the three rings in just one location in virtual environment guest memory. While this may seem complicated at first glance, it’s a natural step after the split version if we realize that the device can discard and overwrite the data it already has read from the driver, and the same happens the other way around.</p>
</blockquote>
<p>Packed virtqueue对其进行了修正，将三个环合并在虚拟环境guest内存的一个位置。虽然这乍看起来很复杂，但如果我们意识到设备可以丢弃和覆盖它已经从驱动中读取的数据，那么这就是分裂版本之后的一个自然步骤，反之亦然。</p>
<h3 id="Supplying-descriptors-to-the-device-How-to-fill-device-todo-list"><a href="#Supplying-descriptors-to-the-device-How-to-fill-device-todo-list" class="headerlink" title="Supplying descriptors to the device: How to fill device todo-list"></a>Supplying descriptors to the device: How to fill device todo-list</h3><blockquote>
<p>After initialization in the same process as described in Virtio device initialization: feature bits, and after the agreement on RING_PACKED feature flag, the driver and the device starts with a shared blank canvas of descriptors with an agreed length (up to 215 entries) in a agreed guest’s memory location. The layout of these descriptors is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_desc</span> &#123;</span> </span><br><span class="line">        le64 addr;</span><br><span class="line">        le32 len;</span><br><span class="line">        le16 id;</span><br><span class="line">        le16 flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Memory layout of a packed virtqueue descriptor</strong></p>
</blockquote>
<p>在Virtio设备初始化：特征位中描述的相同过程中进行初始化后，在就RING_PACKED特征标志达成一致后，驱动程序和设备开始在商定的客体内存位置上共享一个空白的描述符，其长度是商定的（最多215条）。这些描述符的布局是：。</p>
<blockquote>
<p>This time, the id field is not an index for the device to look for the buffer: it is an opaque value for it, only has meaning for the driver.</p>
<p>The driver also maintains an internal single-bit ring wrap counter initialized to 1. The driver will flip its value every time it makes available the last descriptor in the ring.</p>
<p>As with split descriptors, the first step is to write the different fields: address, length, id and flags. However, packed descriptors take into account two new flags: <code>AVAIL(0x7)</code> and <code>USED(0x15)</code>. To mark a descriptor as available, the driver makes the <code>AVAIL(0x7)</code> flag the same as its internal wrap counter, and the used flag the inverse. While just a binary flag avail/used would be easier to implement, it would prevent useful optimizations we will describe later.</p>
</blockquote>
<p>这一次，id字段不是设备寻找缓冲区的索引：它是一个不透明的值，只对驱动有意义。</p>
<p>驱动程序还维护一个内部的单比特环形缠绕计数器，初始化为1，每次提供环形的最后一个描述符时，驱动程序都会翻转其值。</p>
<p>与分割描述符一样，第一步是写入不同的字段：地址、长度、ID和标志。然而，打包描述符考虑到了两个新的标志。AVAIL(0x7)和USED(0x15)。为了将一个描述符标记为可用，驱动程序使AVAIL(0x7)标志与它的内部包装计数器相同，而使用的标志则是相反的。虽然只有一个二进制标志AVA/USED会更容易实现，但它会妨碍我们后面要描述的有用的优化。</p>
<blockquote>
<p>As an example, if the driver allocates a write buffer with <code>0x1000</code> bytes on position <code>0x80000000</code> in the step 1 in the diagram, and makes it the first available descriptor setting <code>AVAIL(0x7)</code> flag the same as internal wrap counter (set) in step 2. The descriptor table would look like this:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Descriptor table after add the first buffer</strong></p>
</blockquote>
<p>举个例子，如果驱动程序在图中的第1步中在<code>0x80000000</code>位置分配了一个<code>0x1000</code>字节的写缓冲区，并使其成为第一个可用的描述符，在第2步中设置<code>AVAIL(0x7)</code>标志与内部包络计数相同（设置）。描述符表将看起来像这样。</p>
<blockquote>
<p>Note that the avail and used idx columns are in the table just for guidance, they don’t exist in the descriptor table: Each side should have its internal counter to know which position needs to poll or write next, and also the device must track the driver’s wrap counter. Lastly, as with used virtqueue, the driver notifies the device if the latter has notifications enabled (step 3 in the diagram).</p>
</blockquote>
<p>注意，表中的avail和used idx列只是为了指导，它们在描述符表中并不存在。每一方都应该有自己的内部计数器，以知道下一步需要轮询或写入哪个位置，同时设备也必须跟踪驱动的wrap计数器。最后，和使用的virtqueue一样，如果设备启用了通知功能，驱动程序就会通知设备（图中第3步）。</p>
<blockquote>
<p>And the usual diagram of the updates. Note the lack of the avail and used ring, as only the descriptor table is needed now.</p>
</blockquote>
<p>还有通常的更新图。请注意，由于现在只需要描述符表，所以缺少可用和已用环。</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-1.png" class="">

<p><strong>Diagram: Driver makes available a descriptor using a packed queue</strong></p>
<h3 id="Returning-used-descriptors-How-the-device-fills-the-“done”-list"><a href="#Returning-used-descriptors-How-the-device-fills-the-“done”-list" class="headerlink" title="Returning used descriptors: How the device fills the “done” list"></a>Returning used descriptors: How the device fills the “done” list</h3><blockquote>
<p>As the driver, the device maintains an internal single-bit ring wrap counter initialized to 1, and knows that the driver also has its internal ring wrap counter set. When the latter first searches for the first descriptor the driver has made available, it polls the first entry of the ring, looking for the avail flag equal to the driver internal wrap flag (set in this case).</p>
</blockquote>
<p>作为驱动程序，设备维护着一个初始化为1的内部单比特环形缠绕计数器，并且知道驱动程序也设置了其内部环形缠绕计数器。当后者第一次搜索驱动器提供的第一个描述符时，它就会轮询环的第一个条目，寻找等于驱动器内部包络标志的可用标志（在这种情况下是设置的）。</p>
<blockquote>
<p>As with a used ring, the length of the written data is returned in the “length” entry (if any), and the id of the used descriptor. At last, the device will make the avail (A) and used (U) flag the same as the device’s internal wrap counter.</p>
<p>Following the example, the device will let the descriptor table as figure 6. The device will know that the buffer has been returned because the used flag matches the available flag, and with the device internal wrap counter at the moment it wrote the descriptor. The returned address is not important: only the ID.</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Descriptor table after add the first buffer</strong></p>
</blockquote>
<p>与已用环一样，写入数据的长度会在 “length “条目中返回（如果有的话），以及已用描述符的id。最后，设备将使可用(A)和已用(U)标志与设备的内部缠绕计数器相同。</p>
<p>按照这个例子，设备将让描述符表如图6所示。设备将知道缓冲区已经被返回，因为使用的标志与可用的标志相匹配，并且在写描述符的时候与设备内部的wrap计数器相匹配。返回的地址并不重要：只有ID。</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-2.png" class="">

<p><strong>Diagram: Device marks a descriptor as used using a packed queue</strong></p>
<h3 id="Wrapping-the-descriptor-ring-How-the-lanes-keep-separated"><a href="#Wrapping-the-descriptor-ring-How-the-lanes-keep-separated" class="headerlink" title="Wrapping the descriptor ring: How the lanes keep separated?"></a>Wrapping the descriptor ring: How the lanes keep separated?</h3><blockquote>
<p>When the driver fills the complete descriptor table, it wraps and changes its internal Driver Ring Wrap. So, in the second round, the available descriptions will have the avail and used flags clear, so the device will have to poll looking for this condition once it wraps reading descriptors. Let’s see a full example of the different situations.</p>
</blockquote>
<p>当驱动程序填满了完整的描述符表，它就会包裹并改变其内部的驱动程序环形包裹。所以，在第二轮中，可用的描述符将有avail和used标志被清除，所以设备一旦包裹读取描述符，就必须轮询寻找这个条件。让我们来看看不同情况的完整例子。</p>
<blockquote>
<p>If we have a descriptor table with only two entries, the Driver Ring Wrap Counter is set, and it fills the descriptor table making available two buffers at the beginning of the operation, driver will reverse its internal wrap counter, so it will be clear (0). We have the next table:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>→</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Full two-entries descriptor table</strong></p>
</blockquote>
<p>如果我们有一个只有两个条目的描述符表，驱动环形缠绕计数器被设置，它填满描述符表，在操作开始时腾出两个缓冲区，驱动将扭转其内部缠绕计数器，所以它将是clear（0）。我们有下一个表。</p>
<blockquote>
<p>After that, the device realizes that has both descriptors with id #0 and #1 available: it knows that the driver had its wrap counter set when it wrote them, the avail flag is set on them, and the used one is clear on both. If device uses the descriptor with id #1, we have the Figure 8 descriptor table. The buffer #0 still belongs to the device!</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>→</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Using first buffer out of order</strong></p>
</blockquote>
<p>之后，设备意识到有两个ID为#0和#1的描述符是可用的：它知道驱动程序在写它们的时候设置了wrap计数器，它们的avail标志被设置，而且这两个描述符的used标志都是清零的。如果设备使用id为#1的描述符，我们就有了图8的描述符表。缓冲区#0仍然属于设备!</p>
<blockquote>
<p>Now the driver realize the buffer #1 has been used, since avail and used flags are the same (set) and match the device’s internal wrap counter at the moment it wrote it. If device now uses the buffer id #0, it will make the table look like this:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>→</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A|U</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Using second buffer out of order</strong></p>
</blockquote>
<p>现在驱动程序意识到1号缓冲区已经被使用了，因为avail和used标志是一样的（设置），并且与设备的内部wrap计数器在写的时候是一致的。如果设备现在使用缓冲区ID #0，它将使表看起来像这样。</p>
<blockquote>
<p>But there is a more interesting case: Starting from the “first buffer out of order” situation, the driver makes available the buffer #1 again. In that case, the descriptor table goes directly from the “first buffer” to the next figure, “Full two-entries descriptor table.”</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td>←</td>
</tr>
<tr>
<td>→</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Full two-entries descriptor table</strong></p>
</blockquote>
<p>但还有一种更有趣的情况。从 “第一个缓冲区失灵 “的情况开始，驱动程序再次提供了1号缓冲区。在这种情况下，描述符表直接从 “第一个缓冲区 “进入下一个图，”完整的两行描述符表”。</p>
<h3 id="Chained-descriptors-No-more-jumps"><a href="#Chained-descriptors-No-more-jumps" class="headerlink" title="Chained descriptors: No more jumps"></a>Chained descriptors: No more jumps</h3><blockquote>
<p>Chained descriptors work likewise: no need for the next field in the head (or subsequent) descriptor in the chain to search subsequent ones, since the latter always occupies the next position. However, while in the split used ring you only need to return as used the id of the head of the chain, in packed you only need to return the tail id.</p>
</blockquote>
<p>链式描述符的工作原理也是如此：不需要在链中的头部（或后续）描述符的下一个字段来搜索后续的描述符，因为后者总是占据着下一个位置。然而，在分割使用的环中，你只需要返回链头的id作为使用，而在打包中你只需要返回尾部的id。</p>
<blockquote>
<p>Back to the used ring, every time we use chained descriptors, we make the used idx lag regarding the avail idx. More than one descriptor mark as available to the device, but we only send one as used to the driver. While this is not a problem in the split ring, this would cause descriptor entry exhaustion in the packed version.</p>
</blockquote>
<p>回到已用环，每次我们使用链式描述符时，都会使已用idx滞后于可用idx。一个以上的描述符被标记为设备可用，但我们只把一个描述符作为已使用的描述符发送给驱动。虽然这在分割环中不是一个问题，但在打包版本中会导致描述符条目耗尽。</p>
<blockquote>
<p>The straightforward solution is to make the device mark as used every descriptor in the chain. However, this can be expensive, since we are modifying a shared area of memory, and could cause cache bounces.</p>
<p>However, the driver already knows the chain, so it can skip all the chain with only the last id. This is why we need to compare the used/avail pair with the driver/device Wrap Counter: after a jump, we wouldn’t know if the next descriptor has been made available in this driver’s round or in the next if we only have a binary available/used flag.</p>
</blockquote>
<p>直接的解决方案是让设备将链上的每个描述符都标记为已使用。然而，这可能是昂贵的，因为我们正在修改内存的共享区域，并可能导致缓存跳出。</p>
<p>然而，驱动程序已经知道了链，所以它可以跳过所有的链，只保留最后一个ID。这就是为什么我们需要将已用/可用对与驱动/设备的Wrap Counter进行比较：在跳转之后，如果我们只有一个二进制的可用/已用标志，我们就不知道下一个描述符是在这个驱动的回合中还是在下一个回合中被提供的。</p>
<blockquote>
<p>For example, in a four entries ring, the driver makes available the chain of three descriptors:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Three chained descriptors available</strong></p>
</blockquote>
<p>例如，在一个四项环中，驱动器提供了三个描述符的链。</p>
<blockquote>
<p>After that, the device discovers the chain (polling position 0) and marks it as used, overwriting only the position 0. It skips completely the positions 1 and 2. When the driver polls for used, it will skip them too, knowing that the chain was 3 descriptors long:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Using the descriptor chain</strong></p>
</blockquote>
<p>之后，设备会发现这个链（轮询位置0），并将其标记为已用，只覆盖位置0，完全跳过位置1和2。当驱动轮询已使用时，它也会跳过这些位置，因为它知道该链有3个描述符长。</p>
<blockquote>
<p>Now the driver produces another two descriptor long chain, and it has to take into account the wrapping:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Make available another descriptor chain</strong></p>
</blockquote>
<p>现在，驱动程序又产生了一个两根描述符的长链，它必须考虑到包装的问题。</p>
<blockquote>
<p>And the device marks it as used, so only the first descriptor in the chain (4th in the table) needs to be updated.</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Using another descriptor chain</strong></p>
<p>Although the next descriptor (2nd) seems like available, since the avail flag is different from the used one, the device knows that it is not because of knowing the internal Driver Wrap Counter: The right flag combination is avail clear, used set.</p>
</blockquote>
<p>而设备将其标记为已使用，所以只有链中的第一个描述符（表中的第四个）需要更新。</p>
<p>尽管下一个描述符（第2个）看起来是可用的，但由于avail标志与used标志不同，设备知道它不是，因为知道内部的Driver Wrap Counter。正确的标志组合是avail clear，used set。</p>
<h3 id="Indirect-descriptors-When-chains-are-not-enough"><a href="#Indirect-descriptors-When-chains-are-not-enough" class="headerlink" title="Indirect descriptors: When chains are not enough"></a>Indirect descriptors: When chains are not enough</h3><blockquote>
<p>Indirect descriptors work like in the split case. First, the driver allocates a table of indirect descriptors each with the same layout as the regular packed descriptors anywhere in memory. After that, it sets each descriptor in this indirect table to the buffer it wants to make available for the driver (steps 1-2), and inserts a descriptor in the virtqueue with the flag <code>VIRTQ_DESC_F_INDIRECT (0x4)</code> set (step 3). The descriptor’s address and length correspond to the indirect table’s ones.</p>
</blockquote>
<p>间接描述符的工作方式与分割情况类似。首先，驱动程序分配一个间接描述符表，每个描述符的布局与内存中任何地方的常规打包描述符相同。之后，它将这个间接表中的每个描述符设置为它想为驱动提供的缓冲区（步骤1-2），并在virtqueue中插入一个设置了标志VIRTQ_DESC_F_INDIRECT（0x4）的描述符（步骤3）。该描述符的地址和长度对应于间接表的那些。</p>
<blockquote>
<p>In packed layout buffers must come in order in the indirect table, and the ID field is completely ignored. Also, the only valid flag for them is <code>VIRTQ_DESC_F_WRITE</code>, others are reserved and ignored by the device. As usual, the driver will notify the device if the conditions for the notification are met (step 4).</p>
</blockquote>
<p>在打包布局中，缓冲区必须按顺序出现在间接表中，ID字段完全被忽略。另外，它们唯一有效的标志是VIRTQ_DESC_F_WRITE，其他的是保留的，被设备忽略。像往常一样，如果通知的条件得到满足，驱动程序将通知设备（步骤4）。</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-3.png" class="">

<p><strong>Diagram: Driver makes available a descriptor using a packed queue</strong></p>
<p>For example, the driver would need to allocate this 48 bytes table for a 3 descriptors indirect table:</p>
<table>
<thead>
<tr>
<th></th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>…</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>…</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>…</td>
<td>W</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Three descriptor long indirect packed table</strong></p>
<p>And if it introduces the indirect table the first in the descriptor table, assuming it is allocated in <code>0x83000000</code> address:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>48</td>
<td>0</td>
<td>A|I</td>
<td>←</td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Drivers makes an indirect table available</strong></p>
<p>After indirect buffer consumption, the device needs to return the indirect buffer id (0 in the example) in its used descriptor. The table looks like the return of the first buffer, except for the indirect (I) flag set:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>48</td>
<td>0</td>
<td>A|U|I</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Device makes an indirect table used</strong></p>
<p>After that, the device cannot access the memory table anymore unless the driver makes it available again, so the latter can free or reuse it.</p>
<h3 id="Notifications-how-to-manage-interruptions"><a href="#Notifications-how-to-manage-interruptions" class="headerlink" title="Notifications: how to manage interruptions?"></a>Notifications: how to manage interruptions?</h3><blockquote>
<p>Like in the used queue, each side of the communication maintains two identical structures used for controlling notifications between the device and the driver. The driver’s one is read-only by the device, and the device’s one is read-only by the driver.</p>
<p>The struct layout is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct pvirtq_event_suppress &#123; </span><br><span class="line">        le16 desc;</span><br><span class="line">        le16 flags; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Event suppression struct notification</strong></p>
</blockquote>
<p>就像在用过的队列中，通信的每一方都维护着两个相同的结构，用于控制设备和驱动之间的通知。驱动程序的那个结构是设备只读的，而设备的那个结构是驱动程序只读的。</p>
<blockquote>
<p>The member flags can take the values:</p>
<ul>
<li>0: Notifications are enabled</li>
<li>1: Notifications are disabled</li>
<li>2: Notifications are enabled for a specific descriptor, specified from the desc member.</li>
</ul>
<p>If flags value is 2, the other side will notify until the wrap counter matches the most significant bit of desc and the descriptor placed in the position desc discarding that bit is made used/available. For this mode to work, <code>VIRTIO_F_RING_EVENT_IDX</code> flag needs to be negotiated in Virtio device initialization: feature bits.</p>
<p>None of these mechanisms are 100% reliable, since the other side could have sent the notification already when we set the values, so expect it even when disable.</p>
<p>Note that, since the descriptor ring size is not being forced to be a power of two (comparing with the split version), the notification structure can fit in the same page as the descriptor table. This can be advantageous for some implementations.</p>
</blockquote>
<p>成员标志可以采取以下值。</p>
<ul>
<li>0: 通知被启用</li>
<li>1: 通知被禁用</li>
<li>2: 对一个特定的描述符启用通知，由desc成员指定。</li>
</ul>
<p>如果标志值为2，另一方将进行通知，直到wrap计数器与desc的最重要的位相匹配，并且放置在desc位置的描述符放弃该位而被使用/可用。为了使这种模式工作，VIRTIO_F_RING_EVENT_IDX标志需要在Virtio设备初始化中协商：特征位。</p>
<p>这些机制都不是100%可靠的，因为当我们设置这些值时，对方可能已经发送了通知，所以即使在禁用的情况下也要期待它。</p>
<p>请注意，由于描述符环的大小没有被强制为2的幂（与分裂版本相比），通知结构可以与描述符表放在同一页面中。这对某些实现来说是有利的。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><blockquote>
<p>In this series we have taken you through the different virtio data plane layouts and its virtqueues implementations. They are the means for virtio devices and virtio drivers to exchange information.</p>
<p>We start by covering the simpler and less optimized split virtqueue layout. This layout is relatively easy to implement and to debug thus it’s a good entry point for learning the virtio dataplane basics.</p>
<p>We then moved on to the packed virtqueue layout specified in virtio 1.1 which allows requests exchange using a more compact descriptor representation. This avoids all the overhead of scattering the data through memory, avoiding cache contention and reducing the PCI transactions in case of actual hardware.</p>
</blockquote>
<p>在这个系列中，我们已经带你了解了不同的virtio数据平面布局及其virtqueues的实现。它们是virtio设备和virtio驱动交换信息的手段。</p>
<p>我们首先介绍了更简单、更不优化的分离式virtqueue布局。这种布局相对容易实现和调试，因此它是学习virtio数据平面基础知识的一个很好的切入点。</p>
<p>然后，我们转向virtio 1.1中规定的打包式virtqueue布局，它允许使用更紧凑的描述符来交换请求。这避免了在内存中分散数据的所有开销，避免了缓存争用，并在实际硬件的情况下减少了PCI事务。</p>
<blockquote>
<p>We also covered a number of optimizations on top of both ring layouts which depends on the communication/device type or how each part is implemented. Mainly, they are oriented to reduce the communication overhead, both in notifications and in memory transactions. Virtio offers a simple protocol to communicate what features and optimizations support each side, so they can agree on how the data is going to be exchanged and is highly future-proof.</p>
</blockquote>
<p>我们还在这两个环状布局的基础上进行了一些优化，这取决于通信/设备类型或每个部分的实现方式。主要的是，它们的方向是减少通信开销，包括通知和内存事务。Virtio提供了一个简单的协议来沟通每一方支持哪些功能和优化，所以他们可以就数据的交换方式达成一致，并且是高度面向未来的。</p>
<blockquote>
<p>This series covered the essence of the virtio data plane and provided you with the tool to analyze and develop your own virtio device and drivers. It should be noted that this series summarizes the relevant sections from the virtio spec thus you should refer to the spec for additional information and see it as the source of truth.</p>
<p>In the next posts we will return to vDPA including the kernel framework, hands on blogs and vDPA in Kubernetes.</p>
</blockquote>
<p>这个系列涵盖了virtio数据平面的本质，并为你提供了分析和开发自己的virtio设备和驱动的工具。应该注意的是，这个系列总结了virtio规范中的相关部分，因此你应该参考规范以获得更多信息，并将其视为真理的来源。</p>
<p>在接下来的文章中，我们将回到vDPA，包括内核框架、实践博客和Kubernetes中的vDPA。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" data-id="cleh8xpaf0000urwb2g162srp" data-title="Packed virtqueue: How to reduce overhead with virtio" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/03/01/cpu-feature-configuration-code-diving/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Cpu feature configuration code diving
        
      </div>
    </a>
  
  
    <a href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Virtqueues and virtio ring: How the data travels</div>
    </a>
  
</nav>

  
</article>



  <section id="comments" class="vcomment">

  </section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arch-notes/">arch-notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/devops/">devops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/languages/">languages</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/languages/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/languages/python/">python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/memory-management/">memory management</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/management/">management</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-related-works/">project-related-works</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/">virtualization</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/edk2-ovmf/">edk2-ovmf</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/kvm/">kvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/">translation</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/virtio/">virtio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/virtio-networking/">virtio-networking</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/v2v/">v2v</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/virtio-balloon/">virtio-balloon</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BSOD/" rel="tag">BSOD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPDK/" rel="tag">DPDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElementTree/" rel="tag">ElementTree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDP/" rel="tag">TDP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TLB/" rel="tag">TLB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code-reading/" rel="tag">code-reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/edk2-ovmf/" rel="tag">edk2-ovmf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ft/" rel="tag">ft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kvm/" rel="tag">kvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/live-migration/" rel="tag">live-migration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nessus/" rel="tag">nessus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nexus/" rel="tag">nexus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/others/" rel="tag">others</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/paper-reading/" rel="tag">paper-reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perf/" rel="tag">perf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes/" rel="tag">reading notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software-arch/" rel="tag">software-arch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/system-design/" rel="tag">system-design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/v2v/" rel="tag">v2v</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vDPA/" rel="tag">vDPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vhost-net/" rel="tag">vhost-net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virt/" rel="tag">virt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-balloon/" rel="tag">virtio-balloon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-net/" rel="tag">virtio-net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-networking/" rel="tag">virtio-networking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BSOD/" style="font-size: 10px;">BSOD</a> <a href="/tags/DPDK/" style="font-size: 12.86px;">DPDK</a> <a href="/tags/ElementTree/" style="font-size: 10px;">ElementTree</a> <a href="/tags/TDP/" style="font-size: 11.43px;">TDP</a> <a href="/tags/TLB/" style="font-size: 10px;">TLB</a> <a href="/tags/architecture/" style="font-size: 18.57px;">architecture</a> <a href="/tags/code-reading/" style="font-size: 10px;">code-reading</a> <a href="/tags/cpu/" style="font-size: 10px;">cpu</a> <a href="/tags/edk2-ovmf/" style="font-size: 10px;">edk2-ovmf</a> <a href="/tags/ft/" style="font-size: 10px;">ft</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 12.86px;">java</a> <a href="/tags/kernel/" style="font-size: 12.86px;">kernel</a> <a href="/tags/kvm/" style="font-size: 15.71px;">kvm</a> <a href="/tags/libvirt/" style="font-size: 11.43px;">libvirt</a> <a href="/tags/linux/" style="font-size: 15.71px;">linux</a> <a href="/tags/live-migration/" style="font-size: 10px;">live-migration</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/nessus/" style="font-size: 10px;">nessus</a> <a href="/tags/nexus/" style="font-size: 10px;">nexus</a> <a href="/tags/others/" style="font-size: 10px;">others</a> <a href="/tags/paper-reading/" style="font-size: 10px;">paper-reading</a> <a href="/tags/perf/" style="font-size: 10px;">perf</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/qemu/" style="font-size: 20px;">qemu</a> <a href="/tags/reading-notes/" style="font-size: 10px;">reading notes</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/software-arch/" style="font-size: 12.86px;">software-arch</a> <a href="/tags/system-design/" style="font-size: 12.86px;">system-design</a> <a href="/tags/v2v/" style="font-size: 10px;">v2v</a> <a href="/tags/vDPA/" style="font-size: 10px;">vDPA</a> <a href="/tags/vhost-net/" style="font-size: 17.14px;">vhost-net</a> <a href="/tags/virt/" style="font-size: 14.29px;">virt</a> <a href="/tags/virtio/" style="font-size: 15.71px;">virtio</a> <a href="/tags/virtio-balloon/" style="font-size: 10px;">virtio-balloon</a> <a href="/tags/virtio-net/" style="font-size: 17.14px;">virtio-net</a> <a href="/tags/virtio-networking/" style="font-size: 17.14px;">virtio-networking</a> <a href="/tags/windows/" style="font-size: 10px;">windows</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/01/cpu-feature-configuration-code-diving/">Cpu feature configuration code diving</a>
          </li>
        
          <li>
            <a href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/">Packed virtqueue: How to reduce overhead with virtio</a>
          </li>
        
          <li>
            <a href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/">Virtqueues and virtio ring: How the data travels</a>
          </li>
        
          <li>
            <a href="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/">Virtio devices and drivers overview: The headjack and the phone</a>
          </li>
        
          <li>
            <a href="/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/">Windows install virtio then reboot met BSOD</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a></br>
      
      &copy; 2023 Alan Jager<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = '' == true;
    var verify = 'false' == true;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "r30r51B3r5JFqlxR88Jua6So-gzGzoHsz",
        appKey: "wnL9j38siXbLqBHGnWpzmVxv",
        placeholder: "Just go go",
        pageSize:'10',
        avatar:'mm',
        lang:'zh-cn'
    });
</script>

  </div>
</body>
</html>