<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Cpu features about kvm hidden | 花の様に</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="[TOC] What kvm hidden did to qemuBased on last blog, we can see how libvirt cpu feature configuration changes qemu cpuid. And we figure out hypervisor disable configuration have what kind of influence">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpu features about kvm hidden">
<meta property="og:url" content="http://hanayo.cn/2023/03/09/cpu-features-about-kvm-hidden/index.html">
<meta property="og:site_name" content="花の様に">
<meta property="og:description" content="[TOC] What kvm hidden did to qemuBased on last blog, we can see how libvirt cpu feature configuration changes qemu cpuid. And we figure out hypervisor disable configuration have what kind of influence">
<meta property="og:locale">
<meta property="article:published_time" content="2023-03-09T13:48:22.000Z">
<meta property="article:modified_time" content="2023-03-13T14:42:01.595Z">
<meta property="article:author" content="Alan Jager">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="libvirt">
<meta property="article:tag" content="cpu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="花の様に" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">花の様に</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanayo.cn"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-cpu-features-about-kvm-hidden" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/09/cpu-features-about-kvm-hidden/" class="article-date">
  <time class="dt-published" datetime="2023-03-09T13:48:22.000Z" itemprop="datePublished">2023-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/kvm/">kvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Cpu features about kvm hidden
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="What-kvm-hidden-did-to-qemu"><a href="#What-kvm-hidden-did-to-qemu" class="headerlink" title="What kvm hidden did to qemu"></a>What kvm hidden did to qemu</h2><p>Based on last blog, we can see how libvirt cpu feature configuration changes qemu cpuid. And we figure out hypervisor disable configuration have what kind of influence.</p>
<p>Then another recommanded feature from libvirt is kvm hidden. In the same way with last blog, we can find libvirt will configure <code>kvm=off</code> to <code>-cpu</code> and according to qemu:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-relaxed&quot;</span>, X86CPU, hyperv_relaxed_timing, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-vapic&quot;</span>, X86CPU, hyperv_vapic, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-time&quot;</span>, X86CPU, hyperv_time, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-crash&quot;</span>, X86CPU, hyperv_crash, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-reset&quot;</span>, X86CPU, hyperv_reset, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-vpindex&quot;</span>, X86CPU, hyperv_vpindex, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-runtime&quot;</span>, X86CPU, hyperv_runtime, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-synic&quot;</span>, X86CPU, hyperv_synic, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-stimer&quot;</span>, X86CPU, hyperv_stimer, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-frequencies&quot;</span>, X86CPU, hyperv_frequencies, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;check&quot;</span>, X86CPU, check_cpuid, <span class="literal">true</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;enforce&quot;</span>, X86CPU, enforce_cpuid, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;kvm&quot;</span>, X86CPU, expose_kvm, <span class="literal">true</span>),</span><br></pre></td></tr></table></figure>

<p>those configures are defined by <code>target/i386/cpu.c</code> in variable <code>x86_cpu_properties</code>.</p>
<p><code>kvm=off</code> will be treated as “kvm” is false and the local variable of this cpu changes <code>expose_kvm</code> to false.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x86_cpu_realizefn</code> will invoke <code>x86_cpu_expand_features</code> to expand features from configuration, as a result FEAT_KVM will disable all features after realize features.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[FEAT_KVM] = &#123;</span><br><span class="line">    .feat_names = &#123;</span><br><span class="line">        <span class="string">&quot;kvmclock&quot;</span>, <span class="string">&quot;kvm-nopiodelay&quot;</span>, <span class="string">&quot;kvm-mmu&quot;</span>, <span class="string">&quot;kvmclock&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kvm-asyncpf&quot;</span>, <span class="string">&quot;kvm-steal-time&quot;</span>, <span class="string">&quot;kvm-pv-eoi&quot;</span>, <span class="string">&quot;kvm-pv-unhalt&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">&quot;kvm-pv-tlb-flush&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="string">&quot;kvmclock-stable-bit&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .cpuid_eax = KVM_CPUID_FEATURES, .cpuid_reg = R_EAX,</span><br><span class="line">    .tcg_features = TCG_KVM_FEATURES,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>check its definition, almost all kvm related features is disabled.</p>
<p>Then go ahead to linux kernel <code>arch/x86/include/uapi/asm/kvm_para.h</code> defines those features from cpuid:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This CPUID returns a feature bitmap in eax.  Before enabling a particular</span></span><br><span class="line"><span class="comment"> * paravirtualization, the appropriate feature bit should be checked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_CPUID_FEATURES	0x40000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_NOP_IO_DELAY	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_MMU_OP		2</span></span><br><span class="line"><span class="comment">/* This indicates that the new set of kvmclock msrs</span></span><br><span class="line"><span class="comment"> * are available. The use of 0x11 and 0x12 is deprecated</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE2        3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_ASYNC_PF		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_STEAL_TIME		5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_PV_EOI		6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_PV_UNHALT		7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The last 8 bits are used to indicate how to interpret the flags field</span></span><br><span class="line"><span class="comment"> * in pvclock structure. If no bits are set, all flags are ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE_STABLE_BIT	24</span></span><br></pre></td></tr></table></figure>

<p>And before we check all features details let’s check how linux figure kvm feature at first.</p>
<p>For kernel, check kvm by <code>kvm_para_available</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kvm_para_available</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> kvm_cpuid_base() != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which will return a kvm based hypervisor by check <code>cpu_has_hypervisor</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> noinline <span class="keyword">uint32_t</span> __kvm_cpuid_base(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (boot_cpu_data.cpuid_level &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">/* So we don&#x27;t blow up on old processors */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu_has_hypervisor)</span><br><span class="line">		<span class="keyword">return</span> hypervisor_cpuid_base(<span class="string">&quot;KVMKVMKVM\0\0\0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and <code>cpu_has_hypervisor</code>  is defined from the hypervisor feature we mentioned in last post:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_has_hypervisor	boot_cpu_has(X86_FEATURE_HYPERVISOR)</span></span><br></pre></td></tr></table></figure>

<p>So we combine those two part together to check the influence introduced by kvm hidden.</p>
<p>Note: here is the brief description about those features in cpuid:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function: define KVM_CPUID_FEATURES (0x40000001)</span><br><span class="line">returns : ebx, ecx, edx = 0</span><br><span class="line">          eax = and OR&#x27;ed group of (1 &lt;&lt; flag), where each flags is:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag                               || value || meaning</span><br><span class="line">=============================================================================</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE            ||     0 || kvmclock available at msrs</span><br><span class="line">                                   ||       || 0x11 and 0x12.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_NOP_IO_DELAY           ||     1 || not necessary to perform delays</span><br><span class="line">                                   ||       || on PIO operations.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_MMU_OP                 ||     2 || deprecated.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE2           ||     3 || kvmclock available at msrs</span><br><span class="line">                                   ||       || 0x4b564d00 and 0x4b564d01</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_ASYNC_PF               ||     4 || async pf can be enabled by</span><br><span class="line">                                   ||       || writing to msr 0x4b564d02</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_STEAL_TIME             ||     5 || steal time can be enabled by</span><br><span class="line">                                   ||       || writing to msr 0x4b564d03.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_PV_EOI                 ||     6 || paravirtualized end of interrupt</span><br><span class="line">                                   ||       || handler can be enabled by writing</span><br><span class="line">                                   ||       || to msr 0x4b564d04.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_PV_UNHALT              ||     7 || guest checks this feature bit</span><br><span class="line">                                   ||       || before enabling paravirtualized</span><br><span class="line">                                   ||       || spinlock support.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE_STABLE_BIT ||    24 || host will warn if no guest-side</span><br><span class="line">                                   ||       || per-cpu warps are expected in</span><br><span class="line">                                   ||       || kvmclock.</span><br><span class="line">------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-CLOCKSOURCE-amp-KVM-FEATURE-CLOCKSOURCE2"><a href="#KVM-FEATURE-CLOCKSOURCE-amp-KVM-FEATURE-CLOCKSOURCE2" class="headerlink" title="KVM_FEATURE_CLOCKSOURCE &amp; KVM_FEATURE_CLOCKSOURCE2"></a>KVM_FEATURE_CLOCKSOURCE &amp; KVM_FEATURE_CLOCKSOURCE2</h3><p>This feature is used directly when implement <code>kvmclock_init</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvmclock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pvclock_vcpu_time_info</span> *<span class="title">vcpu_time</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mem, mem_wall_clock;</span><br><span class="line">	<span class="keyword">int</span> size, cpu, wall_clock_size;</span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	size = PAGE_ALIGN(<span class="keyword">sizeof</span>(struct pvclock_vsyscall_time_info)*NR_CPUS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvmclock &amp;&amp; kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) &#123;</span><br><span class="line">		msr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;</span><br><span class="line">		msr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(kvmclock &amp;&amp; kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-NOP-IO-DELAY"><a href="#KVM-FEATURE-NOP-IO-DELAY" class="headerlink" title="KVM_FEATURE_NOP_IO_DELAY"></a>KVM_FEATURE_NOP_IO_DELAY</h3><p>During guest init, paravirt_ops_setup will use this feature:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_guest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	paravirt_ops_setup();</span><br></pre></td></tr></table></figure>

<p>which changes <code>io_delay</code> of paravirt cpu ops to <code>kvm_io_delay</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">paravirt_ops_setup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pv_info.name = <span class="string">&quot;KVM&quot;</span>;</span><br><span class="line">	pv_info.paravirt_enabled = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_NOP_IO_DELAY))</span><br><span class="line">		pv_cpu_ops.io_delay = kvm_io_delay;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_IO_APIC</span></span><br><span class="line">	no_timer_check = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which just means without any io delay:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * No need for any &quot;IO delay&quot; on KVM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_io_delay</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-MMU-OP"><a href="#KVM-FEATURE-MMU-OP" class="headerlink" title="KVM_FEATURE_MMU_OP"></a>KVM_FEATURE_MMU_OP</h3><p>Deprecated.</p>
<h3 id="KVM-FEATURE-ASYNC-PF"><a href="#KVM-FEATURE-ASYNC-PF" class="headerlink" title="KVM_FEATURE_ASYNC_PF"></a>KVM_FEATURE_ASYNC_PF</h3><p>When init kvm guest:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_guest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF))</span><br><span class="line">		x86_init.irqs.trap_init = kvm_apf_trap_init;</span><br></pre></td></tr></table></figure>

<p><code>kvm_apf_trap_init</code> will be set to <code>x86_init.irqs.trap_init</code> which will set <code>async_page_fault</code> when interrupt request for trap operations:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">kvm_apf_trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_intr_gate(<span class="number">14</span>, async_page_fault);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then when init kvm guest cpu, will manually enable cpu to allow to write async page fault:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_guest_cpu_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF) &amp;&amp; kvmapf) &#123;</span><br><span class="line">		u64 pa = slow_virt_to_phys(this_cpu_ptr(&amp;apf_reason));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">		pa |= KVM_ASYNC_PF_SEND_ALWAYS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		wrmsrl(MSR_KVM_ASYNC_PF_EN, pa | KVM_ASYNC_PF_ENABLED);</span><br><span class="line">		__this_cpu_write(apf_reason.enabled, <span class="number">1</span>);</span><br><span class="line">		printk(KERN_INFO<span class="string">&quot;KVM setup async PF for cpu %d\n&quot;</span>,</span><br><span class="line">		       smp_processor_id());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Then feature will enable async PF for this cpu.</p>
<p>Note: trap initialize will be done by <code>arch/x86/kernel/traps.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EISA</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *p = early_ioremap(<span class="number">0x0FFFD9</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (readl(p) == <span class="string">&#x27;E&#x27;</span> + (<span class="string">&#x27;I&#x27;</span>&lt;&lt;<span class="number">8</span>) + (<span class="string">&#x27;S&#x27;</span>&lt;&lt;<span class="number">16</span>) + (<span class="string">&#x27;A&#x27;</span>&lt;&lt;<span class="number">24</span>))</span><br><span class="line">		EISA_bus = <span class="number">1</span>;</span><br><span class="line">	early_iounmap(p, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	set_intr_gate(X86_TRAP_DE, divide_error);</span><br><span class="line">	set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);</span><br><span class="line">	<span class="comment">/* int4 can be called from all */</span></span><br><span class="line">	set_system_intr_gate(X86_TRAP_OF, &amp;overflow);</span><br><span class="line">	set_intr_gate(X86_TRAP_BR, bounds);</span><br><span class="line">	set_intr_gate(X86_TRAP_UD, invalid_op);</span><br><span class="line">	set_intr_gate(X86_TRAP_NM, device_not_available);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	set_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);</span><br><span class="line">	set_intr_gate(X86_TRAP_TS, invalid_TSS);</span><br><span class="line">	set_intr_gate(X86_TRAP_NP, segment_not_present);</span><br><span class="line">	set_intr_gate(X86_TRAP_SS, stack_segment);</span><br><span class="line">	set_intr_gate(X86_TRAP_GP, general_protection);</span><br><span class="line">	set_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);</span><br><span class="line">	set_intr_gate(X86_TRAP_MF, coprocessor_error);</span><br><span class="line">	set_intr_gate(X86_TRAP_AC, alignment_check);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_MCE</span></span><br><span class="line">	set_intr_gate_ist(X86_TRAP_MC, &amp;machine_check, MCE_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_intr_gate(X86_TRAP_XF, simd_coprocessor_error);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reserve all the builtin and the syscall vector: */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FIRST_EXTERNAL_VECTOR; i++)</span><br><span class="line">		set_bit(i, used_vectors);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IA32_EMULATION</span></span><br><span class="line">	set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);</span><br><span class="line">	set_bit(IA32_SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</span><br><span class="line">	set_bit(SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set the IDT descriptor to a fixed read-only location, so that the</span></span><br><span class="line"><span class="comment">	 * &quot;sidt&quot; instruction will not leak the location of the kernel, and</span></span><br><span class="line"><span class="comment">	 * to defend the IDT against arbitrary memory write vulnerabilities.</span></span><br><span class="line"><span class="comment">	 * It will be reloaded in cpu_init() */</span></span><br><span class="line">	__set_fixmap(FIX_RO_IDT, __pa_symbol(idt_table), PAGE_KERNEL_RO);</span><br><span class="line">	idt_descr.address = fix_to_virt(FIX_RO_IDT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Should be a barrier for any external CPU state:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu_init();</span><br><span class="line"></span><br><span class="line">	x86_init.irqs.trap_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;debug_idt_table, &amp;idt_table, IDT_ENTRIES * <span class="number">16</span>);</span><br><span class="line">	set_nmi_gate(X86_TRAP_DB, &amp;debug);</span><br><span class="line">	set_nmi_gate(X86_TRAP_BP, &amp;int3);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and <code>x86_init.irqs.trap_init();</code> will be used post other features.    </p>
<h3 id="KVM-FEATURE-STEAL-TIME"><a href="#KVM-FEATURE-STEAL-TIME" class="headerlink" title="KVM_FEATURE_STEAL_TIME"></a>KVM_FEATURE_STEAL_TIME</h3><p>when do kvm guest init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) &#123;</span><br><span class="line">	has_steal_clock = <span class="number">1</span>;</span><br><span class="line">	pv_time_ops.steal_clock = kvm_steal_clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Paravirt steal lock will be replaced by kvm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">kvm_steal_clock</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 steal;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_steal_time</span> *<span class="title">src</span>;</span></span><br><span class="line">	<span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">	src = &amp;per_cpu(steal_time, cpu);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		version = src-&gt;version;</span><br><span class="line">		rmb();</span><br><span class="line">		steal = src-&gt;steal;</span><br><span class="line">		rmb();</span><br><span class="line">	&#125; <span class="keyword">while</span> ((version &amp; <span class="number">1</span>) || (version != src-&gt;version));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> steal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which will steal the time from cpu directly.</p>
<h3 id="KVM-FEATURE-PV-EOI"><a href="#KVM-FEATURE-PV-EOI" class="headerlink" title="KVM_FEATURE_PV_EOI"></a>KVM_FEATURE_PV_EOI</h3><p>From kvm guest init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">	apic_set_eoi_write(kvm_guest_apic_eoi_write);</span><br></pre></td></tr></table></figure>

<p>During kvm guest cpu init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI)) &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pa;</span><br><span class="line">	<span class="comment">/* Size alignment is implied but just to make it explicit. */</span></span><br><span class="line">	BUILD_BUG_ON(__alignof__(kvm_apic_eoi) &lt; <span class="number">4</span>);</span><br><span class="line">	__this_cpu_write(kvm_apic_eoi, <span class="number">0</span>);</span><br><span class="line">	pa = slow_virt_to_phys(this_cpu_ptr(&amp;kvm_apic_eoi))</span><br><span class="line">		| KVM_MSR_ENABLED;</span><br><span class="line">	wrmsrl(MSR_KVM_PV_EOI_EN, pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Besides, those paravirt kvm features is used by kernel so those features need to be disabled if kernel changed, for example, load kernel by kexec, to avoid the features pointing to old memory of old kernel, those features will disabled by write msr manually:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_pv_guest_cpu_reboot</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We disable PV EOI before we load a new kernel by kexec,</span></span><br><span class="line"><span class="comment">	 * since MSR_KVM_PV_EOI_EN stores a pointer into old kernel&#x27;s memory.</span></span><br><span class="line"><span class="comment">	 * New kernel can re-enable when it boots.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">		wrmsrl(MSR_KVM_PV_EOI_EN, <span class="number">0</span>);</span><br><span class="line">	kvm_pv_disable_apf();</span><br><span class="line">	kvm_disable_steal_time();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So does kvm guest cpu offline do:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_guest_cpu_offline</span><span class="params">(<span class="keyword">void</span> *dummy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	kvm_disable_steal_time();</span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">		wrmsrl(MSR_KVM_PV_EOI_EN, <span class="number">0</span>);</span><br><span class="line">	kvm_pv_disable_apf();</span><br><span class="line">	apf_task_wake_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s all due to paravirt use shared memory to use those features between guest and host.</p>
<h3 id="KVM-FEATURE-PV-UNHALT"><a href="#KVM-FEATURE-PV-UNHALT" class="headerlink" title="KVM_FEATURE_PV_UNHALT"></a>KVM_FEATURE_PV_UNHALT</h3><p>Allow to use para-virtualized spinlock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_spinlock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/* Does host kernel support KVM_FEATURE_PV_UNHALT? */</span></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_has_feature(KVM_FEATURE_PV_UNHALT))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-CLOCKSOURCE-STABLE-BIT"><a href="#KVM-FEATURE-CLOCKSOURCE-STABLE-BIT" class="headerlink" title="KVM_FEATURE_CLOCKSOURCE_STABLE_BIT"></a>KVM_FEATURE_CLOCKSOURCE_STABLE_BIT</h3><p>kvm clock will set a <code>PVCLOCK_TSC_STABLE_BIT</code> to pvclock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_INFO <span class="string">&quot;kvm-clock: Using msrs %x and %x&quot;</span>,</span><br><span class="line">       msr_kvm_system_time, msr_kvm_wall_clock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))</span><br><span class="line">	pvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);</span><br></pre></td></tr></table></figure>

<p>when stable source detected:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u64 <span class="title">pvclock_clocksource_read</span><span class="params">(struct pvclock_vcpu_time_info *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> version;</span><br><span class="line">	u64 ret;</span><br><span class="line">	u64 last;</span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		version = pvclock_read_begin(src);</span><br><span class="line">		ret = __pvclock_read_cycles(src, rdtsc_ordered());</span><br><span class="line">		flags = src-&gt;flags;</span><br><span class="line">	&#125; <span class="keyword">while</span> (pvclock_read_retry(src, version));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely((flags &amp; PVCLOCK_GUEST_STOPPED) != <span class="number">0</span>)) &#123;</span><br><span class="line">		src-&gt;flags &amp;= ~PVCLOCK_GUEST_STOPPED;</span><br><span class="line">		pvclock_touch_watchdogs();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((valid_flags &amp; PVCLOCK_TSC_STABLE_BIT) &amp;&amp;</span><br><span class="line">		(flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>

<p>clocksource read will return directly.</p>
<h4 id="Hyper-v-impact"><a href="#Hyper-v-impact" class="headerlink" title="Hyper-v impact"></a>Hyper-v impact</h4><p>linux will converting hyperv and kvmclock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compute_tsc_page_parameters</span><span class="params">(struct pvclock_vcpu_time_info *hv_clock,</span></span></span><br><span class="line"><span class="function"><span class="params">					HV_REFERENCE_TSC_PAGE *tsc_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 max_mul;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(hv_clock-&gt;flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>but if no stable tsc allowed, hypervclock and kvmclock computing will be skipped.</p>
<p>Function chain as following:</p>
<p><code>kvm_guest_time_update</code> -&gt; <code>kvm_hv_setup_tsc_page</code> -&gt; <code>compute_tsc_page_parameters</code></p>
<p>And source is from kvm request:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) &#123;</span><br><span class="line">	r = kvm_guest_time_update(vcpu);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(r))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to know more about <code>KVM_REQ_CLOCK_UPDATE</code> to figure out when. this request will be used.</p>
<p>The clue is <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code> make request usage.</p>
<ul>
<li><p>Ioctl kvm clock set -&gt; <code>KVM_SET_CLOCK</code> -&gt;  <code>kvm_gen_update_masterclock</code> </p>
</li>
<li><p><code>kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu)</code> -&gt;  <code>kvm_gen_update_masterclock</code> </p>
</li>
<li><p><code>kvm_guest_time_update</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code><br>first update is from kvm request:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) &#123;</span><br><span class="line">	r = kvm_guest_time_update(vcpu);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(r))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>then interrupt will be disabled to prevent clock changes:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keep irq disabled to prevent changes to the clock */</span></span><br><span class="line">local_irq_save(flags);</span><br><span class="line">this_tsc_khz = __this_cpu_read(cpu_tsc_khz);</span><br><span class="line"><span class="keyword">if</span> (unlikely(this_tsc_khz == <span class="number">0</span>)) &#123;</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>INIT_DELAYED_WORK(&amp;kvm-&gt;arch.kvmclock_update_work, kvmclock_update_fn);</code> -&gt; <code>kvmclock_update_fn</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code><br>kvm lock will be updated by a schedule:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kvmclock updates which are isolated to a given vcpu, such as</span></span><br><span class="line"><span class="comment"> * vcpu-&gt;cpu migration, should not allow system_timestamp from</span></span><br><span class="line"><span class="comment"> * the rest of the vcpus to remain static. Otherwise ntp frequency</span></span><br><span class="line"><span class="comment"> * correction applies to one vcpu&#x27;s system_timestamp but not</span></span><br><span class="line"><span class="comment"> * the others.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So in those cases, request a kvmclock update for all vcpus.</span></span><br><span class="line"><span class="comment"> * We need to rate-limit these requests though, as they can</span></span><br><span class="line"><span class="comment"> * considerably slow guests that have a large number of vcpus.</span></span><br><span class="line"><span class="comment"> * The time for a remote vcpu to update its kvmclock is bound</span></span><br><span class="line"><span class="comment"> * by the delay we use to rate-limit the updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)</span></span><br></pre></td></tr></table></figure>

<p>and kvmlock sync delays are</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVMCLOCK_SYNC_PERIOD (300 * HZ)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu)</code> -&gt;  <code>kvm_gen_kvmclock_update</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code></p>
<ul>
<li><p>MSR_KVM_SYSTEM_TIME</p>
</li>
<li><p>kvm_arch_vcpu_load<br>update clock if no master clock or host cpu to sync.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On a host with synchronized TSC, there is no need to update</span></span><br><span class="line"><span class="comment"> * kvmclock on vcpu-&gt;cpu migration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!vcpu-&gt;kvm-&gt;arch.use_master_clock || vcpu-&gt;cpu == <span class="number">-1</span>)</span><br><span class="line">	kvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);</span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;cpu != cpu)</span><br><span class="line">	kvm_migrate_timers(vcpu);</span><br><span class="line">vcpu-&gt;cpu = cpu;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>kvm_arch_vcpu_load</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>Adjust time if needed</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Apply any externally detected TSC adjustments (due to suspend) */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(vcpu-&gt;arch.tsc_offset_adjustment)) &#123;</span><br><span class="line">	adjust_tsc_offset_host(vcpu, vcpu-&gt;arch.tsc_offset_adjustment);</span><br><span class="line">	vcpu-&gt;arch.tsc_offset_adjustment = <span class="number">0</span>;</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvm_set_guest_paused</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>if guest kernel stopped by hypervisor use this to update pv clock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kvm_set_guest_paused() indicates to the guest kernel that it has been</span></span><br><span class="line"><span class="comment"> * stopped by the hypervisor.  This function will be called from the host only.</span></span><br><span class="line"><span class="comment"> * EINVAL is returned when the host attempts to set the flag for a guest that</span></span><br><span class="line"><span class="comment"> * does not support pv clocks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kvm_set_guest_paused</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!vcpu-&gt;arch.pv_time_enabled)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	vcpu-&gt;arch.pvclock_set_guest_stopped_request = <span class="literal">true</span>;</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvmclock_cpufreq_notifier</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>see the annotation from code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We allow guests to temporarily run on slowing clocks,</span></span><br><span class="line"><span class="comment"> * provided we notify them after, or to run on accelerating</span></span><br><span class="line"><span class="comment"> * clocks, provided we notify them before.  Thus time never</span></span><br><span class="line"><span class="comment"> * goes backwards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, we have a problem.  We can&#x27;t atomically update</span></span><br><span class="line"><span class="comment"> * the frequency of a given CPU from this function; it is</span></span><br><span class="line"><span class="comment"> * merely a notifier, which can be called from any CPU.</span></span><br><span class="line"><span class="comment"> * Changing the TSC frequency at arbitrary points in time</span></span><br><span class="line"><span class="comment"> * requires a recomputation of local variables related to</span></span><br><span class="line"><span class="comment"> * the TSC for each VCPU.  We must flag these local variables</span></span><br><span class="line"><span class="comment"> * to be updated and be sure the update takes place with the</span></span><br><span class="line"><span class="comment"> * new frequency before any guests proceed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unfortunately, the combination of hotplug CPU and frequency</span></span><br><span class="line"><span class="comment"> * change creates an intractable locking scenario; the order</span></span><br><span class="line"><span class="comment"> * of when these callouts happen is undefined with respect to</span></span><br><span class="line"><span class="comment"> * CPU hotplug, and they can race with each other.  As such,</span></span><br><span class="line"><span class="comment"> * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is</span></span><br><span class="line"><span class="comment"> * undefined; you can actually have a CPU frequency change take</span></span><br><span class="line"><span class="comment"> * place in between the computation of X and the setting of the</span></span><br><span class="line"><span class="comment"> * variable.  To protect against this problem, all updates of</span></span><br><span class="line"><span class="comment"> * the per_cpu tsc_khz variable are done in an interrupt</span></span><br><span class="line"><span class="comment"> * protected IPI, and all callers wishing to update the value</span></span><br><span class="line"><span class="comment"> * must wait for a synchronous IPI to complete (which is trivial</span></span><br><span class="line"><span class="comment"> * if the caller is on the CPU already).  This establishes the</span></span><br><span class="line"><span class="comment"> * necessary total order on variable updates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that because a guest time update may take place</span></span><br><span class="line"><span class="comment"> * anytime after the setting of the VCPU&#x27;s request bit, the</span></span><br><span class="line"><span class="comment"> * correct TSC value must be set before the request.  However,</span></span><br><span class="line"><span class="comment"> * to ensure the update actually makes it to any guest which</span></span><br><span class="line"><span class="comment"> * starts running in hardware virtualization between the set</span></span><br><span class="line"><span class="comment"> * and the acquisition of the spinlock, we must also ping the</span></span><br><span class="line"><span class="comment"> * CPU after setting the request bit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>after <code>kvm_guest_exit();</code><br>update clock if vcpu request clock always up to date.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(vcpu-&gt;arch.tsc_always_catchup))</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hardware_enable_nolock</code> -&gt; <code>kvm_arch_hardware_enable</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>multi functino access hardware_enable_nolock</p>
<ul>
<li><code>kvm_cpu_hotplug</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kvm_cpu_hotplug</span><span class="params">(struct notifier_block *notifier, <span class="keyword">unsigned</span> <span class="keyword">long</span> val,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	val &amp;= ~CPU_TASKS_FROZEN;</span><br><span class="line">	<span class="keyword">switch</span> (val) &#123;</span><br><span class="line">	<span class="keyword">case</span> CPU_DYING:</span><br><span class="line">		hardware_disable();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CPU_STARTING:</span><br><span class="line">		hardware_enable();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kvm_resume</code> </li>
</ul>
</li>
</ul>
<p>Note: for <code>hv_stimer</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * KVM_REQ_HV_STIMER has to be processed after</span></span><br><span class="line"><span class="comment"> * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers</span></span><br><span class="line"><span class="comment"> * depend on the guest clock being up-to-date</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))</span><br><span class="line">	kvm_hv_process_stimers(vcpu);</span><br></pre></td></tr></table></figure>

<p>will be done after guest clock up-to-date.</p>
<h4 id="Hyper-v-impact-conclusion"><a href="#Hyper-v-impact-conclusion" class="headerlink" title="Hyper-v impact conclusion"></a>Hyper-v impact conclusion</h4><p>With kvm hidden, hyper-v tsc compute will be skipped:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compute_tsc_page_parameters</span><span class="params">(struct pvclock_vcpu_time_info *hv_clock,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct ms_hyperv_tsc_page *tsc_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 max_mul;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(hv_clock-&gt;flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>which can be triggered by above kvm code.</p>
<p>During migration, we know that guest will be stopped (paused) by <code>KVM_KVMCLOCK_CTRL</code> and we could check kvm userspace’s (qemu) usage:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvmclock_vm_state_change</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> running,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     RunState state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KVMClockState *s = opaque;</span><br><span class="line">    CPUState *cpu;</span><br><span class="line">    <span class="keyword">int</span> cap_clock_ctrl = kvm_check_extension(kvm_state, KVM_CAP_KVMCLOCK_CTRL);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">data</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the host where s-&gt;clock was read did not support reliable</span></span><br><span class="line"><span class="comment">         * KVM_GET_CLOCK, read kvmclock value from memory.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;clock_is_reliable) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> pvclock_via_mem = kvmclock_current_nsec(s);</span><br><span class="line">            <span class="comment">/* We can&#x27;t rely on the saved clock value, just discard it */</span></span><br><span class="line">            <span class="keyword">if</span> (pvclock_via_mem) &#123;</span><br><span class="line">                s-&gt;clock = pvclock_via_mem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s-&gt;clock_valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        data.clock = s-&gt;clock;</span><br><span class="line">        ret = kvm_vm_ioctl(kvm_state, KVM_SET_CLOCK, &amp;data);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;KVM_SET_CLOCK failed: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cap_clock_ctrl) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CPU_FOREACH(cpu) &#123;</span><br><span class="line">            run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;clock_valid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s-&gt;runstate_paused = runstate_check(RUN_STATE_PAUSED);</span><br><span class="line"></span><br><span class="line">        kvm_synchronize_all_tsc();</span><br><span class="line"></span><br><span class="line">        kvm_update_clock(s);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the VM is stopped, declare the clock state valid to</span></span><br><span class="line"><span class="comment">         * avoid re-reading it on next vmsave (which would return</span></span><br><span class="line"><span class="comment">         * a different value). Will be reset when the VM is continued.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s-&gt;clock_valid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>when set guest to running, qemu will use <code>KVM_SET_CLOCK</code> else will use <code>kvm_update_clock</code>  works as following:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_update_clock</span><span class="params">(KVMClockState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &amp;data);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;KVM_GET_CLOCK failed: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;clock = data.clock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If kvm_has_adjust_clock_stable() is false, KVM_GET_CLOCK returns</span></span><br><span class="line"><span class="comment">     * essentially CLOCK_MONOTONIC plus a guest-specific adjustment.  This</span></span><br><span class="line"><span class="comment">     * can drift from the TSC-based value that is computed by the guest,</span></span><br><span class="line"><span class="comment">     * so we need to go through kvmclock_current_nsec().  If</span></span><br><span class="line"><span class="comment">     * kvm_has_adjust_clock_stable() is true, and the flags contain</span></span><br><span class="line"><span class="comment">     * KVM_CLOCK_TSC_STABLE, then KVM_GET_CLOCK returns a TSC-based value</span></span><br><span class="line"><span class="comment">     * and kvmclock_current_nsec() is not necessary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here, however, we need not check KVM_CLOCK_TSC_STABLE.  This is because:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if the host has disabled the kvmclock master clock, the guest already</span></span><br><span class="line"><span class="comment">     *   has protection against time going backwards.  This &quot;safety net&quot; is only</span></span><br><span class="line"><span class="comment">     *   absent when kvmclock is stable;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - therefore, we can replace a check like</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if last KVM_GET_CLOCK was not reliable then</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   with</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if last KVM_GET_CLOCK was not reliable &amp;&amp; masterclock is enabled</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * However:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if kvm_has_adjust_clock_stable() returns false, the left side is</span></span><br><span class="line"><span class="comment">     *   always true (KVM_GET_CLOCK is never reliable), and the right side is</span></span><br><span class="line"><span class="comment">     *   unknown (because we don&#x27;t have data.flags).  We must assume it&#x27;s true</span></span><br><span class="line"><span class="comment">     *   and read from memory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if kvm_has_adjust_clock_stable() returns true, the result of the &amp;&amp;</span></span><br><span class="line"><span class="comment">     *   is always false (masterclock is enabled iff KVM_GET_CLOCK is reliable)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So we can just use this instead:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if !kvm_has_adjust_clock_stable() then</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s-&gt;clock_is_reliable = kvm_has_adjust_clock_stable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But from the annotation in <code>kvmclock_vm_state_change</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the VM is stopped, declare the clock state valid to</span></span><br><span class="line"><span class="comment"> * avoid re-reading it on next vmsave (which would return</span></span><br><span class="line"><span class="comment"> * a different value). Will be reset when the VM is continued.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>qemu seems to relay on vmsave to reset the guest while vm is continued, we just keep our eyes on that.</p>
<p>Combine qemu guest state change hook:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_SET_CLOCK: &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_arch</span> *<span class="title">ka</span> =</span> &amp;kvm-&gt;arch;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">user_ns</span>;</span></span><br><span class="line">	u64 now_ns;</span><br><span class="line"></span><br><span class="line">	r = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;user_ns, argp, <span class="keyword">sizeof</span>(user_ns)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	r = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (user_ns.flags)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	r = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">TODO:</span> userspace has to take care of races with VCPU_RUN, so</span></span><br><span class="line"><span class="comment">	 * kvm_gen_update_masterclock() can be cut down to locked</span></span><br><span class="line"><span class="comment">	 * pvclock_update_vm_gtod_copy().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kvm_gen_update_masterclock(kvm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This pairs with kvm_guest_time_update(): when masterclock is</span></span><br><span class="line"><span class="comment">	 * in use, we use master_kernel_ns + kvmclock_offset to set</span></span><br><span class="line"><span class="comment">	 * unsigned &#x27;system_time&#x27; so if we use get_kvmclock_ns() (which</span></span><br><span class="line"><span class="comment">	 * is slightly ahead) here we risk going negative on unsigned</span></span><br><span class="line"><span class="comment">	 * &#x27;system_time&#x27; when &#x27;user_ns.clock&#x27; is very small.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_lock_irq(&amp;ka-&gt;pvclock_gtod_sync_lock);</span><br><span class="line">	<span class="keyword">if</span> (kvm-&gt;arch.use_master_clock)</span><br><span class="line">		now_ns = ka-&gt;master_kernel_ns;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		now_ns = get_kvmclock_base_ns();</span><br><span class="line">	ka-&gt;kvmclock_offset = user_ns.clock - now_ns;</span><br><span class="line">	spin_unlock_irq(&amp;ka-&gt;pvclock_gtod_sync_lock);</span><br><span class="line"></span><br><span class="line">	kvm_make_all_cpus_request(kvm, KVM_REQ_CLOCK_UPDATE);</span><br></pre></td></tr></table></figure>

<p>will be used to update guest clock.</p>
<h2 id="Hand-on-test-to-confirm-clock-updates"><a href="#Hand-on-test-to-confirm-clock-updates" class="headerlink" title="Hand on test to confirm clock updates"></a>Hand on test to confirm clock updates</h2><p>Enable kvm trace by:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/kernel/debug/tracing/events/kvm/enable</span><br></pre></td></tr></table></figure>

<p>Then collect the output when vm migrated to this host:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/kernel/debug/tracing/trace_pipe &gt; trace_migrated_vm</span><br></pre></td></tr></table></figure>

<p>We can see following logs at first:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;<span class="number">-89383</span> [<span class="number">001</span>] .... <span class="number">97852.765277</span>: kvm_update_master_clock: masterclock <span class="number">0</span> hostclock <span class="number">0x2</span> offsetmatched <span class="number">0</span></span><br><span class="line">&lt;...&gt;<span class="number">-89441</span> [<span class="number">002</span>] d... <span class="number">97852.785366</span>: kvm_write_tsc_offset: vcpu=<span class="number">0</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89441</span> [<span class="number">002</span>] d... <span class="number">97852.785402</span>: kvm_track_tsc: vcpu_id <span class="number">0</span> masterclock <span class="number">0</span> offsetmatched <span class="number">0</span> nr_online <span class="number">1</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89442</span> [<span class="number">002</span>] d... <span class="number">97852.786522</span>: kvm_write_tsc_offset: vcpu=<span class="number">1</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89442</span> [<span class="number">002</span>] d... <span class="number">97852.786533</span>: kvm_track_tsc: vcpu_id <span class="number">1</span> masterclock <span class="number">0</span> offsetmatched <span class="number">1</span> nr_online <span class="number">2</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89443</span> [<span class="number">002</span>] d... <span class="number">97852.787341</span>: kvm_write_tsc_offset: vcpu=<span class="number">2</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89443</span> [<span class="number">002</span>] d... <span class="number">97852.787348</span>: kvm_track_tsc: vcpu_id <span class="number">2</span> masterclock <span class="number">0</span> offsetmatched <span class="number">2</span> nr_online <span class="number">3</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89444</span> [<span class="number">002</span>] d... <span class="number">97852.788099</span>: kvm_write_tsc_offset: vcpu=<span class="number">3</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89444</span> [<span class="number">002</span>] d... <span class="number">97852.788120</span>: kvm_track_tsc: vcpu_id <span class="number">3</span> masterclock <span class="number">0</span> offsetmatched <span class="number">3</span> nr_online <span class="number">4</span> hostclock <span class="number">0x2</span></span><br></pre></td></tr></table></figure>

<p><code>kvm_update_master_clock</code> is used for vm migration:</p>
<p>And the tsc offset changed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-89441 [002] d... 97852.785366: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89441 [002] d... 97852.785402: kvm_track_tsc: vcpu_id 0 masterclock 0 offsetmatched 0 nr_online 1 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89442 [002] d... 97852.786522: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89442 [002] d... 97852.786533: kvm_track_tsc: vcpu_id 1 masterclock 0 offsetmatched 1 nr_online 2 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89443 [002] d... 97852.787341: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89443 [002] d... 97852.787348: kvm_track_tsc: vcpu_id 2 masterclock 0 offsetmatched 2 nr_online 3 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89444 [002] d... 97852.788099: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line"></span><br><span class="line">&lt;...&gt;-89441 [003] d... 97852.872014: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89442 [003] d... 97852.872105: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89443 [003] d... 97852.872189: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89444 [003] d... 97852.872264: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line"></span><br><span class="line">&lt;...&gt;-89441 [000] d... 97856.399432: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89442 [000] d... 97856.403066: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89443 [000] d... 97856.403273: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89444 [000] d... 97856.403414: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br></pre></td></tr></table></figure>

<p>Follow the trace we can find linux kernel code:</p>
<p><code>kvm_vcpu_write_tsc_offset</code> -&gt; <code>kvm_x86_write_l1_tsc_offset</code> -&gt;  <code>write_l1_tsc_offset</code> -&gt; <code>vmx_write_l1_tsc_offset</code> -&gt; <code>trace_kvm_write_tsc_offset</code></p>
<p>And there are multi usages of <code>kvm_vcpu_write_tsc_offset</code></p>
<ul>
<li><code>kvm_synchronize_tsc</code><ul>
<li><code>MSR_IA32_TSC</code> -&gt; <code>kvm_synchronize_tsc</code></li>
<li><code>kvm_vm_ioctl_create_vcpu</code> -&gt; <code>kvm_arch_vcpu_postcreate</code> -&gt; <code>kvm_synchronize_tsc</code></li>
</ul>
</li>
<li><code>adjust_tsc_offset_guest</code><ul>
<li><code>kvm_guest_time_update</code> -&gt; <code>adjust_tsc_offset_guest</code> and <code>kvm_hv_setup_tsc_page</code> this is hyper-v impacted case</li>
<li><code>MSR_IA32_TSC</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
<li><code>MSR_IA32_TSC_ADJUST</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
<li><code>kvm_arch_vcpu_load</code> -&gt; <code>adjust_tsc_offset_host</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
</ul>
</li>
<li><code>kvm_arch_vcpu_load</code> same as above</li>
</ul>
<p>So the following three parts of <code>kvm_vcpu_write_tsc_offset</code> matches with guest creation.</p>
<ul>
<li>Create vcpu</li>
<li>Load vcpu</li>
<li>Adjust tsc offset</li>
</ul>
<p>In last guest hang post, we can see windows guest try to get counter ref:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_time_ref_counter</span><span class="params">(struct kvm *kvm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_hv</span> *<span class="title">hv</span> =</span> to_kvm_hv(kvm);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span>;</span></span><br><span class="line">	u64 tsc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fall back to get_kvmclock_ns() when TSC page hasn&#x27;t been set up,</span></span><br><span class="line"><span class="comment">	 * is broken, disabled or being updated.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (hv-&gt;hv_tsc_page_status != HV_TSC_PAGE_SET)</span><br><span class="line">		<span class="keyword">return</span> div_u64(get_kvmclock_ns(kvm), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	vcpu = kvm_get_vcpu(kvm, <span class="number">0</span>);</span><br><span class="line">	tsc = kvm_read_l1_tsc(vcpu, rdtsc());</span><br><span class="line">	<span class="keyword">return</span> mul_u64_u64_shr(tsc, hv-&gt;tsc_ref.tsc_scale, <span class="number">64</span>)</span><br><span class="line">		+ hv-&gt;tsc_ref.tsc_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But this is used by MSR read request from guest. And now we need to debug <code>hv_tsc_page_status</code> and <code>kvm_hv_setup_tsc_page</code> usage.</p>
<p>Without kvm hidden:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114210 [002] d... 12255.411580: kvm_exit: vcpu 1 reason MSR_READ rip 0xfffff800ece454c5 info1 0x0000000000000000 info2 0x0000000000000000 intr_info 0x00000000 error_code 0x00000000</span><br><span class="line">&lt;...&gt;-114210 [002] .... 12255.411581: kvm_msr: msr_read 40000020 &#x3D; 0x6fac3c27</span><br><span class="line">&lt;...&gt;-114210 [002] d... 12255.411582: kvm_entry: vcpu 1, rip 0xfffff800ece454c7</span><br><span class="line">&lt;...&gt;-114211 [000] .... 12255.411585: kvm_vcpu_wakeup: wait time 1759974 ns, polling valid</span><br><span class="line">&lt;...&gt;-114211 [000] .... 12255.411585: kvm_hv_timer_state: vcpu_id 2 hv_timer 0</span><br></pre></td></tr></table></figure>

<p>We can find <code>kvm_hv_timer_state</code> in trace, and according to linux kernel code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRACE_EVENT(kvm_hv_timer_state,</span><br><span class="line">		TP_PROTO(<span class="keyword">unsigned</span> <span class="keyword">int</span> vcpu_id, <span class="keyword">unsigned</span> <span class="keyword">int</span> hv_timer_in_use),</span><br></pre></td></tr></table></figure>

<p>There are two ways to show the trace:</p>
<ul>
<li><code>start_sw_timer</code> -&gt; <code>trace_kvm_hv_timer_state(apic-&gt;vcpu-&gt;vcpu_id, false);</code> which is always false (means 0 in trace)</li>
<li><code>start_hv_timer</code> -&gt; <code>trace_kvm_hv_timer_state(vcpu-&gt;vcpu_id, ktimer-&gt;hv_timer_in_use);</code> which returns <code>hv_timer_in_use</code> from  <code>ktimer-&gt;hv_timer_in_use</code></li>
</ul>
<p>Check the code about <code>start_hv_timer</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_hv_timer</span><span class="params">(struct kvm_lapic *apic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_timer</span> *<span class="title">ktimer</span> =</span> &amp;apic-&gt;lapic_timer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> =</span> apic-&gt;vcpu;</span><br><span class="line">	<span class="keyword">bool</span> expired;</span><br><span class="line"></span><br><span class="line">	WARN_ON(preemptible());</span><br><span class="line">	<span class="keyword">if</span> (!kvm_can_use_hv_timer(vcpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ktimer-&gt;tscdeadline)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (static_call(kvm_x86_set_hv_timer)(vcpu, ktimer-&gt;tscdeadline, &amp;expired))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	ktimer-&gt;hv_timer_in_use = <span class="literal">true</span>;</span><br><span class="line">	hrtimer_cancel(&amp;ktimer-&gt;timer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * To simplify handling the periodic timer, leave the hv timer running</span></span><br><span class="line"><span class="comment">	 * even if the deadline timer has expired, i.e. rely on the resulting</span></span><br><span class="line"><span class="comment">	 * VM-Exit to recompute the periodic timer&#x27;s target expiration.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!apic_lvtt_period(apic)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Cancel the hv timer if the sw timer fired while the hv timer</span></span><br><span class="line"><span class="comment">		 * was being programmed, or if the hv timer itself expired.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (atomic_read(&amp;ktimer-&gt;pending)) &#123;</span><br><span class="line">			cancel_hv_timer(apic);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (expired) &#123;</span><br><span class="line">			apic_timer_expired(apic, <span class="literal">false</span>);</span><br><span class="line">			cancel_hv_timer(apic);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_kvm_hv_timer_state(vcpu-&gt;vcpu_id, ktimer-&gt;hv_timer_in_use);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ktimer-&gt;hv_timer_in_use</code> is set to <code>true</code> so we focus on <code>start_sw_timer</code> next.</p>
<p>There are several ways to goes into <code>restart_apic_timer</code></p>
<ul>
<li><code>restart_apic_timer</code> -&gt; <code>start_sw_timer</code><ul>
<li><code>vmx_exit_handlers_fastpath</code> or <code>__vmx_handle_exit</code> -&gt; <code> handle_fastpath_preemption_timer</code> -&gt; <code>kvm_lapic_expired_hv_timer</code>  -&gt; <code>restart_apic_timer</code></li>
<li><code>vcpu_block</code> -&gt; <code>post_block</code> -&gt; <code>vmx_post_block</code> -&gt;  <code>kvm_lapic_switch_to_hv_timer</code> -&gt; <code>restart_apic_timer</code></li>
<li><code>MSR_IA32_TSC_DEADLINE</code> -&gt;<code>handle_fastpath_set_tscdeadline</code> -&gt; <code>kvm_set_lapic_tscdeadline_msr</code> -&gt;  <code>__start_apic_timer</code> -&gt; <code>restart_apic_timer</code></li>
<li><code>APIC_TDCR</code> -&gt; <code>restart_apic_timer</code> </li>
</ul>
</li>
<li><code>vcpu_block</code> -&gt;  <code>vmx_pre_block</code> -&gt; <code>kvm_lapic_switch_to_sw_timer</code> -&gt; <code>start_sw_timer</code></li>
</ul>
<p>Because we see a trace before shows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kvm_vcpu_wakeup: wait time 1759974 ns, polling valid</span><br></pre></td></tr></table></figure>

<p>which is in kvm_vcpu_block, so this means vmx_post_block <code>restart_apic_timer</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trace_kvm_vcpu_wakeup(block_ns, waited, vcpu_valid_wakeup(vcpu));</span><br><span class="line">kvm_arch_vcpu_block_finish(vcpu);</span><br></pre></td></tr></table></figure>

<p>And because the code runs as:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!start_hv_timer(apic))</span><br><span class="line">	start_sw_timer(apic);</span><br></pre></td></tr></table></figure>

<p><code>start_hv_timer</code> must returns false:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_hv_timer</span><span class="params">(struct kvm_lapic *apic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_timer</span> *<span class="title">ktimer</span> =</span> &amp;apic-&gt;lapic_timer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> =</span> apic-&gt;vcpu;</span><br><span class="line">	<span class="keyword">bool</span> expired;</span><br><span class="line"></span><br><span class="line">	WARN_ON(preemptible());</span><br><span class="line">	<span class="keyword">if</span> (!kvm_can_use_hv_timer(vcpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ktimer-&gt;tscdeadline)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (static_call(kvm_x86_set_hv_timer)(vcpu, ktimer-&gt;tscdeadline, &amp;expired))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><code>kvm_can_use_hv_timer</code> check seems works on x86 machine and while <code>X86_FEATURE_MWAIT</code> is supported.</p>
<p>From the trace we could know, when vcpu exit and come back to work, the timer will be updated, and use vcpu 3 as example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114212 [002] d... 12297.437890: kvm_exit: vcpu 3 reason HLT rip 0xfffff800ecc2b36e info1 0x0000000000000000 info2 0x0000000000000000 intr_info 0x00000000 error_code 0x00000000</span><br></pre></td></tr></table></figure>

<p>vcpu 3 HLT and cause kvm_exit.</p>
<p>Then it wakeup after <code>4774180 ns</code>  and hv_timer is traced without usage.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114212 [002] .... 12255.393408: kvm_vcpu_wakeup: wait time 4774180 ns, polling valid</span><br><span class="line">&lt;...&gt;-114212 [002] .... 12255.393410: kvm_hv_timer_state: vcpu_id 3 hv_timer 0</span><br></pre></td></tr></table></figure>

<p>And hv_timer will be cancelled after live migration:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (apic-&gt;lapic_timer.hv_timer_in_use)</span><br><span class="line">	cancel_hv_timer(apic);</span><br></pre></td></tr></table></figure>

<p>Let’s check hv_timer before migration:</p>
<h2 id="Can-we-resolve-compatibility-issues"><a href="#Can-we-resolve-compatibility-issues" class="headerlink" title="Can we resolve compatibility issues?"></a>Can we resolve compatibility issues?</h2><p>See the code of qemu, it will disable features of FEAT_KVM after all features setup, so we can not manually assign those features:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (l = plus_features; l; l = l-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prop = l-&gt;data;</span><br><span class="line">    object_property_set_bool(OBJECT(cpu), <span class="literal">true</span>, prop, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (l = minus_features; l; l = l-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prop = l-&gt;data;</span><br><span class="line">    object_property_set_bool(OBJECT(cpu), <span class="literal">false</span>, prop, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/09/cpu-features-about-kvm-hidden/" data-id="clf6xo0140000ibwb0fajc90n" data-title="Cpu features about kvm hidden" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/09/cpu-features-about-kvm-hidden/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/09/cpu-features-about-kvm-hidden/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          KVM虚拟化性能分析
        
      </div>
    </a>
  
  
    <a href="/2023/03/03/virtio-on-linux/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Virtio on Linux</div>
    </a>
  
</nav>

  
</article>



  <section id="comments" class="vcomment">

  </section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arch-notes/">arch-notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/devops/">devops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/languages/">languages</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/languages/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/languages/python/">python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/memory-management/">memory management</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/management/">management</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-related-works/">project-related-works</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/">virtualization</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/cpu/">cpu</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/edk2-ovmf/">edk2-ovmf</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/kvm/">kvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/">translation</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/virtio/">virtio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/virtio-networking/">virtio-networking</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/v2v/">v2v</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/virtio-balloon/">virtio-balloon</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BSOD/" rel="tag">BSOD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPDK/" rel="tag">DPDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElementTree/" rel="tag">ElementTree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDP/" rel="tag">TDP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TLB/" rel="tag">TLB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code-reading/" rel="tag">code-reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/colo/" rel="tag">colo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/edk2-ovmf/" rel="tag">edk2-ovmf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ft/" rel="tag">ft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kvm/" rel="tag">kvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/live-migration/" rel="tag">live-migration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-balloon/" rel="tag">memory balloon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nessus/" rel="tag">nessus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nexus/" rel="tag">nexus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/others/" rel="tag">others</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/paper-reading/" rel="tag">paper-reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perf/" rel="tag">perf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/performance/" rel="tag">performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes/" rel="tag">reading notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software-arch/" rel="tag">software-arch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sysstat/" rel="tag">sysstat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/system-design/" rel="tag">system-design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/v2v/" rel="tag">v2v</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vDPA/" rel="tag">vDPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vhost-net/" rel="tag">vhost-net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virt/" rel="tag">virt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virt-top/" rel="tag">virt-top</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-balloon/" rel="tag">virtio-balloon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-net/" rel="tag">virtio-net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-networking/" rel="tag">virtio-networking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtualization/" rel="tag">virtualization</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BSOD/" style="font-size: 10px;">BSOD</a> <a href="/tags/DPDK/" style="font-size: 12.86px;">DPDK</a> <a href="/tags/ElementTree/" style="font-size: 10px;">ElementTree</a> <a href="/tags/TDP/" style="font-size: 11.43px;">TDP</a> <a href="/tags/TLB/" style="font-size: 10px;">TLB</a> <a href="/tags/architecture/" style="font-size: 18.57px;">architecture</a> <a href="/tags/code-reading/" style="font-size: 10px;">code-reading</a> <a href="/tags/colo/" style="font-size: 10px;">colo</a> <a href="/tags/cpu/" style="font-size: 12.86px;">cpu</a> <a href="/tags/edk2-ovmf/" style="font-size: 10px;">edk2-ovmf</a> <a href="/tags/ft/" style="font-size: 11.43px;">ft</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 12.86px;">java</a> <a href="/tags/kernel/" style="font-size: 14.29px;">kernel</a> <a href="/tags/kvm/" style="font-size: 15.71px;">kvm</a> <a href="/tags/libvirt/" style="font-size: 12.86px;">libvirt</a> <a href="/tags/linux/" style="font-size: 17.14px;">linux</a> <a href="/tags/live-migration/" style="font-size: 10px;">live-migration</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/memory-balloon/" style="font-size: 10px;">memory balloon</a> <a href="/tags/nessus/" style="font-size: 10px;">nessus</a> <a href="/tags/nexus/" style="font-size: 10px;">nexus</a> <a href="/tags/others/" style="font-size: 10px;">others</a> <a href="/tags/paper-reading/" style="font-size: 10px;">paper-reading</a> <a href="/tags/perf/" style="font-size: 10px;">perf</a> <a href="/tags/performance/" style="font-size: 11.43px;">performance</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/qemu/" style="font-size: 20px;">qemu</a> <a href="/tags/reading-notes/" style="font-size: 10px;">reading notes</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/software-arch/" style="font-size: 12.86px;">software-arch</a> <a href="/tags/sysstat/" style="font-size: 10px;">sysstat</a> <a href="/tags/system-design/" style="font-size: 12.86px;">system-design</a> <a href="/tags/v2v/" style="font-size: 10px;">v2v</a> <a href="/tags/vDPA/" style="font-size: 10px;">vDPA</a> <a href="/tags/vhost-net/" style="font-size: 17.14px;">vhost-net</a> <a href="/tags/virt/" style="font-size: 14.29px;">virt</a> <a href="/tags/virt-top/" style="font-size: 10px;">virt-top</a> <a href="/tags/virtio/" style="font-size: 17.14px;">virtio</a> <a href="/tags/virtio-balloon/" style="font-size: 10px;">virtio-balloon</a> <a href="/tags/virtio-net/" style="font-size: 17.14px;">virtio-net</a> <a href="/tags/virtio-networking/" style="font-size: 17.14px;">virtio-networking</a> <a href="/tags/virtualization/" style="font-size: 10px;">virtualization</a> <a href="/tags/windows/" style="font-size: 10px;">windows</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/12/06/2023-12-06/">The disk in the guest OS is unmounted during the kernel startup process.</a>
          </li>
        
          <li>
            <a href="/2023/05/26/understanding-cpu-topology-for-improved-performance/">Understanding CPU Topology for Improved Performance</a>
          </li>
        
          <li>
            <a href="/2023/04/27/virtio-memory-balloon/">Understand virtio memory balloon</a>
          </li>
        
          <li>
            <a href="/2023/04/13/qemu-colo-details/">Qemu Colo Details</a>
          </li>
        
          <li>
            <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">KVM虚拟化性能分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a></br>
      
      &copy; 2023 Alan Jager<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = '' == true;
    var verify = 'false' == true;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "r30r51B3r5JFqlxR88Jua6So-gzGzoHsz",
        appKey: "wnL9j38siXbLqBHGnWpzmVxv",
        placeholder: "Just go go",
        pageSize:'10',
        avatar:'mm',
        lang:'zh-cn'
    });
</script>

  </div>
</body>
</html>