<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>花の様に</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="花の様に">
<meta property="og:url" content="http://hanayo.cn/index.html">
<meta property="og:site_name" content="花の様に">
<meta property="og:locale">
<meta property="article:author" content="Alan Jager">
<meta property="article:tag" content="ブログ">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="花の様に" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">花の様に</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanayo.cn"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2023-12-06" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/06/2023-12-06/" class="article-date">
  <time class="dt-published" datetime="2023-12-06T06:14:17.000Z" itemprop="datePublished">2023-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/06/2023-12-06/">The disk in the guest OS is unmounted during the kernel startup process.</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Phenomenon: When creating a new virtual machine, after the virtual machine enters the “running” state (libvirt reports running, and the qemu process starts), a disk is loaded. During the kernel startup process, the disk (vdb) is recognized, and then qemu receives a device removal event, which is fed back to libvirt. Libvirt updates the XML, causing inconsistency between the disk state recorded in the zstack database and the XML on the host.</p>
<p>The main issue here is that the libvirt loading device interface returns success, and the XML corresponding to the device is also added. However, this device is deleted according to the event feedback from qemu.</p>
<p>Important log information: Here, let’s first analyze the system logs in the guest OS:</p>
<p>Here, we notice the logs related to pciehp because this virtual machine is UEFI-booted, leading to numerous pcie-related logs (due to UEFI boot requiring the q35 machine type, which defaults to pcie devices).</p>
<p>The initially observed logs include an error log from pcieport:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pci 0000:00:02.7: BAR 13: failed to assign [io size 0x1000]</span><br></pre></td></tr></table></figure>

<p>Followed by the recognition of the vdb device:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_virtio_blk virtio6: [vdb] 104857600 512-byte logical blocks (537 GB&#x2F;500 GiB)</span><br></pre></td></tr></table></figure>

<p>An external interrupt is sent to the virtual machine:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pciehp 0000:00:02.7:pcie004: Slot(0-7): Attention button pressed</span><br></pre></td></tr></table></figure>

<p>Subsequently, through ausearch, it is identified that libvirt received a device deletion event, leading to the removal of the mentioned device:</p>
<p>libvirt received device deleted event, removing the device</p>
<p>Based on these scenarios, we have summarized the steps to reproduce the issue:</p>
<ol>
<li>During the kernel startup process</li>
<li>Load the data disk.</li>
<li>Check for inconsistencies between the XML and the database.</li>
<li>Through repeated testing of VM boot and data disk loading, the issue can be reproduced.</li>
</ol>
<p>Regarding the error logs mentioned above, the explanation is as follows:</p>
<ol>
<li><p><code>pci 0000:00:02.7: BAR 13: failed to assign [io size 0x1000]</code>:</p>
<ul>
<li>According to <a target="_blank" rel="noopener" href="https://access.redhat.com/solutions/3144711">https://access.redhat.com/solutions/3144711</a>, this error may occur because in virtualized environments, there might be more PCIe ports than in a real physical environment, leading to this error. However, it does not have any actual impact.</li>
</ul>
</li>
<li><p><code>_virtio_blk virtio6: [vdb] 104857600 512-byte logical blocks (537 GB/500 GiB)</code>:</p>
<ul>
<li>This indicates that the virtio-blk disk has indeed been successfully loaded, as it has been recognized within the virtual machine.</li>
</ul>
</li>
<li><p><code>pciehp 0000:00:02.7:pcie004: Slot(0-7): Attention button pressed</code>:</p>
<ul>
<li>“Attention button pressed” indicates that when resetting the PCIe slot, QEMU sends the corresponding interrupt. When the host receives this interrupt, the corresponding processing logic prints this log.</li>
</ul>
</li>
</ol>
<p>As for the key QEMU code, by searching the codebase, it has been confirmed that QEMU sends the corresponding interrupt when resetting the PCIe slot, and the host prints the log as part of the corresponding processing logic.</p>
<p>code from <code>pcie.c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pci_word_test_and_clear_mask(exp_cap + PCI_EXP_SLTSTA,</span><br><span class="line">                             PCI_EXP_SLTSTA_EIS |&#x2F;* on reset,</span><br><span class="line">                                                    the lock is released *&#x2F;</span><br><span class="line">                             PCI_EXP_SLTSTA_CC |</span><br><span class="line">                             PCI_EXP_SLTSTA_PDC |</span><br><span class="line">                             PCI_EXP_SLTSTA_ABP);</span><br></pre></td></tr></table></figure>

<p>which is used in <code>qdev.c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">QLIST_FOREACH(bus, &amp;dev-&gt;child_bus, sibling) &#123;</span><br><span class="line">     object_property_set_bool(OBJECT(bus), true, &quot;realized&quot;,</span><br><span class="line">                                  &amp;local_err);</span><br><span class="line">     if (local_err !&#x3D; NULL) &#123;</span><br><span class="line">         goto child_realize_fail;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> if (dev-&gt;hotplugged) &#123;</span><br><span class="line">     device_reset(dev);</span><br><span class="line"> &#125;</span><br><span class="line"> dev-&gt;pending_deleted_event &#x3D; false;</span><br><span class="line"> </span><br><span class="line"> if (hotplug_ctrl) &#123;</span><br><span class="line">     hotplug_handler_plug(hotplug_ctrl, dev, &amp;local_err);</span><br><span class="line">     if (local_err !&#x3D; NULL) &#123;</span><br><span class="line">         goto child_realize_fail;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>During the device hotplug process, there will be a reset action.</p>
<p>Kernel-related code:</p>
<p>from <code>pciehp_hpc.c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static int pciehp_poll(void *data)</span><br><span class="line">&#123;</span><br><span class="line">    struct controller *ctrl &#x3D; data;</span><br><span class="line"> </span><br><span class="line">    schedule_timeout_idle(10 * HZ); &#x2F;* start with 10 sec delay *&#x2F;</span><br><span class="line"> </span><br><span class="line">    while (!kthread_should_stop()) &#123;</span><br><span class="line">        &#x2F;* poll for interrupt events or user requests *&#x2F;</span><br><span class="line">        while (pciehp_isr(IRQ_NOTCONNECTED, ctrl) &#x3D;&#x3D; IRQ_WAKE_THREAD ||</span><br><span class="line">               atomic_read(&amp;ctrl-&gt;pending_events))</span><br><span class="line">            pciehp_ist(IRQ_NOTCONNECTED, ctrl);</span><br><span class="line"> </span><br><span class="line">        if (pciehp_poll_time &lt;&#x3D; 0 || pciehp_poll_time &gt; 60)</span><br><span class="line">            pciehp_poll_time &#x3D; 2; &#x2F;* clamp to sane value *&#x2F;</span><br><span class="line"> </span><br><span class="line">        schedule_timeout_idle(pciehp_poll_time * HZ);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* Check Attention Button Pressed *&#x2F;</span><br><span class="line">    if (events &amp; PCI_EXP_SLTSTA_ABP) &#123;</span><br><span class="line">        ctrl_info(ctrl, &quot;Slot(%s): Attention button pressed\n&quot;,</span><br><span class="line">              slot_name(ctrl));</span><br><span class="line">        pciehp_handle_button_press(ctrl);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>This code represents a kernel function for polling PCIe Hot Plug events. It uses a kernel thread (kthread) to continuously poll for interrupt events or user requests related to PCIe Hot Plug. The function includes a timeout mechanism with an initial delay of 10 seconds and then repeats the polling process based on the specified polling time. The function stops when the kernel thread should stop (kthread_should_stop() returns true).</p>
<p>And pciehp_handle_button_press is implemented as following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void pciehp_handle_button_press(struct controller *ctrl)</span><br><span class="line">&#123;</span><br><span class="line">	mutex_lock(&amp;ctrl-&gt;state_lock);</span><br><span class="line">	switch (ctrl-&gt;state) &#123;</span><br><span class="line">	case OFF_STATE:</span><br><span class="line">	case ON_STATE:</span><br><span class="line">		if (ctrl-&gt;state &#x3D;&#x3D; ON_STATE) &#123;</span><br><span class="line">			ctrl-&gt;state &#x3D; BLINKINGOFF_STATE;</span><br><span class="line">			ctrl_info(ctrl, &quot;Slot(%s): Powering off due to button press\n&quot;,</span><br><span class="line">				  slot_name(ctrl));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			ctrl-&gt;state &#x3D; BLINKINGON_STATE;</span><br><span class="line">			ctrl_info(ctrl, &quot;Slot(%s) Powering on due to button press\n&quot;,</span><br><span class="line">				  slot_name(ctrl));</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;* blink power indicator and turn off attention *&#x2F;</span><br><span class="line">		pciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_BLINK,</span><br><span class="line">				      PCI_EXP_SLTCTL_ATTN_IND_OFF);</span><br><span class="line">		schedule_delayed_work(&amp;ctrl-&gt;button_work, 5 * HZ);</span><br><span class="line">		break;</span><br><span class="line">	case BLINKINGOFF_STATE:</span><br><span class="line">	case BLINKINGON_STATE:</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Cancel if we are still blinking; this means that we</span><br><span class="line">		 * press the attention again before the 5 sec. limit</span><br><span class="line">		 * expires to cancel hot-add or hot-remove</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		ctrl_info(ctrl, &quot;Slot(%s): Button cancel\n&quot;, slot_name(ctrl));</span><br><span class="line">		cancel_delayed_work(&amp;ctrl-&gt;button_work);</span><br><span class="line">		if (ctrl-&gt;state &#x3D;&#x3D; BLINKINGOFF_STATE) &#123;</span><br><span class="line">			ctrl-&gt;state &#x3D; ON_STATE;</span><br><span class="line">			pciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_ON,</span><br><span class="line">					      PCI_EXP_SLTCTL_ATTN_IND_OFF);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			ctrl-&gt;state &#x3D; OFF_STATE;</span><br><span class="line">			pciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF,</span><br><span class="line">					      PCI_EXP_SLTCTL_ATTN_IND_OFF);</span><br><span class="line">		&#125;</span><br><span class="line">		ctrl_info(ctrl, &quot;Slot(%s): Action canceled due to button press\n&quot;,</span><br><span class="line">			  slot_name(ctrl));</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		ctrl_err(ctrl, &quot;Slot(%s): Ignoring invalid state %#x\n&quot;,</span><br><span class="line">			 slot_name(ctrl), ctrl-&gt;state);</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;ctrl-&gt;state_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Both OFF_STATE and ON_STATE could changed to each other by same press request. </p>
<p>Based on the test results, we preliminarily conclude that there is a race condition between hot-plug operations and kernel boot, leading to unexpected changes in the PCIe slot’s state from off → on → off. (Note: The crucial point here is that pciehp_handle_button_press(ctrl); simultaneously handles both on and off scenarios.)</p>
<p>With reference to the above keywords, we identified a related Bugzilla entry for QEMU version 4.2 by searching for ‘qemu pci device kernel boot race condition’:</p>
<p><a target="_blank" rel="noopener" href="https://bugzilla.kernel.org/show_bug.cgi?id=211691">https://bugzilla.kernel.org/show_bug.cgi?id=211691</a></p>
<p>“The document mentions a virtio-net failover mechanism introduced by QEMU 4.2, addressing the issue of hot-plugging network cards failing during the VM startup phase. This problem arises from a race condition in the QEMU code that sets the PCIe slot’s state. The provided QEMU patch resolves the issue:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/qemu/qemu/commit/df72184ec15829053b3bb5a0d5801773b6d9ec25">QEMU Patch Link</a></p>
<p>The title of this patch is: ‘pcie: don’t set link state active if the slot is empty.’</p>
<p>Upon reviewing its content, it appears that during PCIe initialization and the hot-plug phase, the ‘reset’ is called, potentially causing inconsistencies in the slot’s state. This patch addresses the problem by preventing the setting of the link state to active if the slot is empty, eliminating the observed issue.”</p>
<p>TIPs:</p>
<p>Search for changes related to the virtual machine process using <code>ausearch</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ausearch -m <span class="string">&quot;VIRT_RESOURCE&quot;</span> -p 63259</span><br></pre></td></tr></table></figure>

<p>Libvirt’s XML and QEMU event update mechanism: Details can be found in TIC-1360 - Cloud VM disk does not exist, capacity inconsistency between UI interface and underlying view (Closed).</p>
<p>Quick reference for PCIe events:</p>
<p>From linux pci_regs.h:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCI_EXP_SLTCTL      24  <span class="comment">/* Slot Control */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_ABPE    0x0001  <span class="comment">/* Attention Button Pressed Enable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_PFDE    0x0002  <span class="comment">/* Power Fault Detected Enable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_MRLSCE  0x0004  <span class="comment">/* MRL Sensor Changed Enable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_PDCE    0x0008  <span class="comment">/* Presence Detect Changed Enable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_CCIE    0x0010  <span class="comment">/* Command Completed Interrupt Enable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_HPIE    0x0020  <span class="comment">/* Hot-Plug Interrupt Enable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_AIC 0x00c0  <span class="comment">/* Attention Indicator Control */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_ATTN_IND_SHIFT 6      <span class="comment">/* Attention Indicator shift */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_ATTN_IND_ON    0x0040 <span class="comment">/* Attention Indicator on */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_ATTN_IND_BLINK 0x0080 <span class="comment">/* Attention Indicator blinking */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_ATTN_IND_OFF   0x00c0 <span class="comment">/* Attention Indicator off */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_PIC 0x0300  <span class="comment">/* Power Indicator Control */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_PWR_IND_ON     0x0100 <span class="comment">/* Power Indicator on */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_PWR_IND_BLINK  0x0200 <span class="comment">/* Power Indicator blinking */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_PWR_IND_OFF    0x0300 <span class="comment">/* Power Indicator off */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_PCC 0x0400  <span class="comment">/* Power Controller Control */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_PWR_ON         0x0000 <span class="comment">/* Power On */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_PWR_OFF        0x0400 <span class="comment">/* Power Off */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_EIC 0x0800  <span class="comment">/* Electromechanical Interlock Control */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PCI_EXP_SLTCTL_DLLSCE  0x1000  <span class="comment">/* Data Link Layer State Changed Enable */</span></span></span><br></pre></td></tr></table></figure>

<p>QEMU systemtap trace, refer to: <a target="_blank" rel="noopener" href="https://qemu-project.gitlab.io/qemu/devel/tracing.html">QEMU Tracing Documentation</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/qemu-trace-stap run /usr/libexec/qemu-kvm pci_cfg_write</span><br></pre></td></tr></table></figure>

<p>Guest os pcie trace analysis:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pending interrupts 0x0010 from Slot Status</span><br><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pciehp_green_led_on: SLOTCTRL 6c write cmd 100</span><br><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pending interrupts 0x0010 from Slot Status</span><br><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pciehp_set_attention_status: SLOTCTRL 6c write cmd c0</span><br><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: Slot(0-7): Attention button pressed</span><br><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: Slot(0-7): Powering off due to button press</span><br><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pending interrupts 0x0010 from Slot Status</span><br><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pciehp_green_led_blink: SLOTCTRL 6c write cmd 200</span><br><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pending interrupts 0x0010 from Slot Status</span><br><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pciehp_set_attention_status: SLOTCTRL 6c write cmd c0</span><br><span class="line"></span><br><span class="line">[一 12月 4 15:06:53 2023] pciehp 0000:00:02.7:pcie004: pciehp_get_power_status: SLOTCTRL 6c value read 2f1</span><br><span class="line">[一 12月 4 15:06:53 2023] pciehp 0000:00:02.7:pcie004: pciehp_unconfigure_device: domain:bus:dev = 0000:08:00</span><br><span class="line">[一 12月 4 15:06:53 2023] pciehp 0000:00:02.7:pcie004: pending interrupts 0x0010 from Slot Status</span><br><span class="line">[一 12月 4 15:06:53 2023] pciehp 0000:00:02.7:pcie004: pciehp_power_off_slot: SLOTCTRL 6c write cmd 40</span><br><span class="line"></span><br><span class="line">[一 12月 4 15:06:54 2023] pciehp 0000:00:02.7:pcie004: pending interrupts 0x0018 from Slot Status</span><br><span class="line">[一 12月 4 15:06:54 2023] pciehp 0000:00:02.7:pcie004: pciehp_green_led_off: SLOTCTRL 6c write cmd 300</span><br><span class="line"></span><br><span class="line">[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pciehp_green_led_on: SLOTCTRL 6c write cmd 100</span><br></pre></td></tr></table></figure>

<p>cmd 0x0100</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define  PCI_EXP_SLTCTL_PWR_IND_ON     0x0100 &#x2F;* Power Indicator on *&#x2F;</span><br></pre></td></tr></table></figure>
<p>[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pciehp_set_attention_status: SLOTCTRL 6c write cmd c0</p>
<p>cmd 0x00c0<br>0000 0000 1100 0000</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define  PCI_EXP_SLTCTL_ATTN_IND_BLINK 0x0080 &#x2F;* Attention Indicator blinking *&#x2F;</span><br><span class="line">#define  PCI_EXP_SLTCTL_ATTN_IND_ON    0x0040 &#x2F;* Attention Indicator on *&#x2F;</span><br></pre></td></tr></table></figure>

<p>[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pciehp_green_led_blink: SLOTCTRL 6c write cmd 200</p>
<p>cmd 0x0200</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define  PCI_EXP_SLTCTL_PWR_IND_BLINK  0x0200 &#x2F;* Power Indicator blinking *&#x2F;</span><br></pre></td></tr></table></figure>

<p>[一 12月 4 15:06:48 2023] pciehp 0000:00:02.7:pcie004: pciehp_set_attention_status: SLOTCTRL 6c write cmd c0</p>
<p>cmd 0x00c0<br>0000 0000 1100 0000</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define  PCI_EXP_SLTCTL_ATTN_IND_BLINK 0x0080 &#x2F;* Attention Indicator blinking *&#x2F;</span><br><span class="line">#define  PCI_EXP_SLTCTL_ATTN_IND_ON    0x0040 &#x2F;* Attention Indicator on *&#x2F;</span><br></pre></td></tr></table></figure>

<p>[一 12月 4 15:06:53 2023] pciehp 0000:00:02.7:pcie004: pciehp_power_off_slot: SLOTCTRL 6c write cmd 400</p>
<p>cmd 0x0400</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define  PCI_EXP_SLTCTL_PWR_OFF        0x0400 &#x2F;* Power Off *&#x2F;</span><br></pre></td></tr></table></figure>

<p>[一 12月 4 15:06:54 2023] pciehp 0000:00:02.7:pcie004: pciehp_green_led_off: SLOTCTRL 6c write cmd 300<br>cmd 0x0300</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define  PCI_EXP_SLTCTL_PWR_IND_OFF    0x0300 &#x2F;* Power Indicator off *&#x2F;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/12/06/2023-12-06/" data-id="clpte86eu0000aucafvj0077k" data-title="The disk in the guest OS is unmounted during the kernel startup process." class="article-share-link">Share</a>
      
      
        <a href="/2023/12/06/2023-12-06/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/12/06/2023-12-06/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-understanding-cpu-topology-for-improved-performance" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/26/understanding-cpu-topology-for-improved-performance/" class="article-date">
  <time class="dt-published" datetime="2023-05-26T05:44:12.000Z" itemprop="datePublished">2023-05-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/cpu/">cpu</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/26/understanding-cpu-topology-for-improved-performance/">Understanding CPU Topology for Improved Performance</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>The physical layout of CPU cores in a system is known as CPU topology. Understanding CPU topology can significantly impact the performance of a system, as it determines the effectiveness and efficiency of the cores.</p>
<h2 id="What-is-CPU-Topology"><a href="#What-is-CPU-Topology" class="headerlink" title="What is CPU Topology?"></a>What is CPU Topology?</h2><p>CPU topology comprises three primary levels:</p>
<ul>
<li><strong>Socket:</strong> A physical connector that holds a CPU. A system can have multiple sockets, each of which can hold multiple cores.</li>
<li><strong>Core:</strong> A single processing unit within a CPU that can run multiple threads simultaneously.</li>
<li><strong>Thread:</strong> A single flow of execution within a core.</li>
</ul>
<p>The CPU topology can be described using a tree-like structure, with the socket level at the top and the thread level at the bottom. The cores in a socket are connected to each other via a bus, and the threads in a core are connected to each other by a shared cache.</p>
<h2 id="Importance-of-CPU-Topology"><a href="#Importance-of-CPU-Topology" class="headerlink" title="Importance of CPU Topology"></a>Importance of CPU Topology</h2><p>Understanding CPU topology is crucial for improving system performance. The topology can be used to optimize the performance of a system by assigning threads to cores in a way that minimizes the amount of communication between cores. This can enhance the performance of applications that are heavily multithreaded.</p>
<p>Additionally, the CPU topology can be used to troubleshoot performance issues. For example, if an application is running slowly, the CPU topology can be used to identify which cores are being used the most. This information can help identify the source of the performance problem and take appropriate steps to improve it.</p>
<p>Here are some benefits of understanding CPU topology:</p>
<ul>
<li>It helps to optimize system performance by assigning tasks to the most suitable cores.</li>
<li>It helps to troubleshoot performance issues by identifying heavily used cores.</li>
<li>It helps to understand how the system will scale as more cores are added.</li>
</ul>
<h2 id="Tools-to-Display-CPU-Topology"><a href="#Tools-to-Display-CPU-Topology" class="headerlink" title="Tools to Display CPU Topology"></a>Tools to Display CPU Topology</h2><p>There are several tools available to display CPU topology, and one of the most commonly used tools is <code>lscpu</code>. Here is an example of using <code>lscpu</code> to display CPU topology:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@172-20-1-220 ~]# lscpu</span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                80</span><br><span class="line">On-line CPU(s) list:   0-79</span><br><span class="line">Thread(s) per core:    2</span><br><span class="line">Core(s) per socket:    20</span><br><span class="line">Socket(s):             2</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">Vendor ID:             GenuineIntel</span><br><span class="line">CPU family:            6</span><br><span class="line">Model:                 85</span><br><span class="line">Model name:            Intel(R) Xeon(R) Gold 5218R CPU @ 2.10GHz</span><br><span class="line">Stepping:              7</span><br><span class="line">CPU MHz:               2100.000</span><br><span class="line">BogoMIPS:              4200.00</span><br><span class="line">Virtualization:        VT-x</span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              1024K</span><br><span class="line">L3 cache:              28160K</span><br><span class="line">NUMA node0 CPU(s):     0-19,40-59</span><br><span class="line">NUMA node1 CPU(s):     20-39,60-79</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf eagerfpu pni pclmulqdq dtes64 ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch epb cat_l3 cdp_l3 intel_ppin intel_pt ssbd mba ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm cqm mpx rdt_a avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local dtherm ida arat pln pts hwp_epp pku ospke avx512_vnni md_clear spec_ctrl intel_stibp flush_l1d arch_capabilities</span><br></pre></td></tr></table></figure>

<p><code>hwloc-ls</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">[root@172-20-1-220 ~]<span class="comment"># hwloc-ls</span></span><br><span class="line">Machine (767GB total)</span><br><span class="line">  NUMANode L<span class="comment">#0 (P#0 383GB)</span></span><br><span class="line">    Package L<span class="comment">#0 + L3 L#0 (28MB)</span></span><br><span class="line">      L2 L<span class="comment">#0 (1024KB) + L1d L#0 (32KB) + L1i L#0 (32KB) + Core L#0</span></span><br><span class="line">        PU L<span class="comment">#0 (P#0)</span></span><br><span class="line">        PU L<span class="comment">#1 (P#40)</span></span><br><span class="line">      L2 L<span class="comment">#1 (1024KB) + L1d L#1 (32KB) + L1i L#1 (32KB) + Core L#1</span></span><br><span class="line">        PU L<span class="comment">#2 (P#1)</span></span><br><span class="line">        PU L<span class="comment">#3 (P#41)</span></span><br><span class="line">      L2 L<span class="comment">#2 (1024KB) + L1d L#2 (32KB) + L1i L#2 (32KB) + Core L#2</span></span><br><span class="line">        PU L<span class="comment">#4 (P#2)</span></span><br><span class="line">        PU L<span class="comment">#5 (P#42)</span></span><br><span class="line">      L2 L<span class="comment">#3 (1024KB) + L1d L#3 (32KB) + L1i L#3 (32KB) + Core L#3</span></span><br><span class="line">        PU L<span class="comment">#6 (P#3)</span></span><br><span class="line">        PU L<span class="comment">#7 (P#43)</span></span><br><span class="line">      L2 L<span class="comment">#4 (1024KB) + L1d L#4 (32KB) + L1i L#4 (32KB) + Core L#4</span></span><br><span class="line">        PU L<span class="comment">#8 (P#4)</span></span><br><span class="line">        PU L<span class="comment">#9 (P#44)</span></span><br><span class="line">      L2 L<span class="comment">#5 (1024KB) + L1d L#5 (32KB) + L1i L#5 (32KB) + Core L#5</span></span><br><span class="line">        PU L<span class="comment">#10 (P#5)</span></span><br><span class="line">        PU L<span class="comment">#11 (P#45)</span></span><br><span class="line">      L2 L<span class="comment">#6 (1024KB) + L1d L#6 (32KB) + L1i L#6 (32KB) + Core L#6</span></span><br><span class="line">        PU L<span class="comment">#12 (P#6)</span></span><br><span class="line">        PU L<span class="comment">#13 (P#46)</span></span><br><span class="line">      L2 L<span class="comment">#7 (1024KB) + L1d L#7 (32KB) + L1i L#7 (32KB) + Core L#7</span></span><br><span class="line">        PU L<span class="comment">#14 (P#7)</span></span><br><span class="line">        PU L<span class="comment">#15 (P#47)</span></span><br><span class="line">      L2 L<span class="comment">#8 (1024KB) + L1d L#8 (32KB) + L1i L#8 (32KB) + Core L#8</span></span><br><span class="line">        PU L<span class="comment">#16 (P#8)</span></span><br><span class="line">        PU L<span class="comment">#17 (P#48)</span></span><br><span class="line">      L2 L<span class="comment">#9 (1024KB) + L1d L#9 (32KB) + L1i L#9 (32KB) + Core L#9</span></span><br><span class="line">        PU L<span class="comment">#18 (P#9)</span></span><br><span class="line">        PU L<span class="comment">#19 (P#49)</span></span><br><span class="line">      L2 L<span class="comment">#10 (1024KB) + L1d L#10 (32KB) + L1i L#10 (32KB) + Core L#10</span></span><br><span class="line">        PU L<span class="comment">#20 (P#10)</span></span><br><span class="line">        PU L<span class="comment">#21 (P#50)</span></span><br><span class="line">      L2 L<span class="comment">#11 (1024KB) + L1d L#11 (32KB) + L1i L#11 (32KB) + Core L#11</span></span><br><span class="line">        PU L<span class="comment">#22 (P#11)</span></span><br><span class="line">        PU L<span class="comment">#23 (P#51)</span></span><br><span class="line">      L2 L<span class="comment">#12 (1024KB) + L1d L#12 (32KB) + L1i L#12 (32KB) + Core L#12</span></span><br><span class="line">        PU L<span class="comment">#24 (P#12)</span></span><br><span class="line">        PU L<span class="comment">#25 (P#52)</span></span><br><span class="line">      L2 L<span class="comment">#13 (1024KB) + L1d L#13 (32KB) + L1i L#13 (32KB) + Core L#13</span></span><br><span class="line">        PU L<span class="comment">#26 (P#13)</span></span><br><span class="line">        PU L<span class="comment">#27 (P#53)</span></span><br><span class="line">      L2 L<span class="comment">#14 (1024KB) + L1d L#14 (32KB) + L1i L#14 (32KB) + Core L#14</span></span><br><span class="line">        PU L<span class="comment">#28 (P#14)</span></span><br><span class="line">        PU L<span class="comment">#29 (P#54)</span></span><br><span class="line">      L2 L<span class="comment">#15 (1024KB) + L1d L#15 (32KB) + L1i L#15 (32KB) + Core L#15</span></span><br><span class="line">        PU L<span class="comment">#30 (P#15)</span></span><br><span class="line">        PU L<span class="comment">#31 (P#55)</span></span><br><span class="line">      L2 L<span class="comment">#16 (1024KB) + L1d L#16 (32KB) + L1i L#16 (32KB) + Core L#16</span></span><br><span class="line">        PU L<span class="comment">#32 (P#16)</span></span><br><span class="line">        PU L<span class="comment">#33 (P#56)</span></span><br><span class="line">      L2 L<span class="comment">#17 (1024KB) + L1d L#17 (32KB) + L1i L#17 (32KB) + Core L#17</span></span><br><span class="line">        PU L<span class="comment">#34 (P#17)</span></span><br><span class="line">        PU L<span class="comment">#35 (P#57)</span></span><br><span class="line">      L2 L<span class="comment">#18 (1024KB) + L1d L#18 (32KB) + L1i L#18 (32KB) + Core L#18</span></span><br><span class="line">        PU L<span class="comment">#36 (P#18)</span></span><br><span class="line">        PU L<span class="comment">#37 (P#58)</span></span><br><span class="line">      L2 L<span class="comment">#19 (1024KB) + L1d L#19 (32KB) + L1i L#19 (32KB) + Core L#19</span></span><br><span class="line">        PU L<span class="comment">#38 (P#19)</span></span><br><span class="line">        PU L<span class="comment">#39 (P#59)</span></span><br><span class="line">    HostBridge L<span class="comment">#0</span></span><br><span class="line">      PCI 8086:a1d2</span><br><span class="line">      PCI 8086:a182</span><br><span class="line">      PCIBridge</span><br><span class="line">        PCIBridge</span><br><span class="line">          PCI 1a03:2000</span><br><span class="line">            GPU L<span class="comment">#0 &quot;card0&quot;</span></span><br><span class="line">            GPU L<span class="comment">#1 &quot;controlD64&quot;</span></span><br><span class="line">    HostBridge L<span class="comment">#3</span></span><br><span class="line">      PCIBridge</span><br><span class="line">        PCI 1000:0097</span><br><span class="line">          Block(Disk) L<span class="comment">#2 &quot;sda&quot;</span></span><br><span class="line">  NUMANode L<span class="comment">#1 (P#1 384GB)</span></span><br><span class="line">    Package L<span class="comment">#1 + L3 L#1 (28MB)</span></span><br><span class="line">      L2 L<span class="comment">#20 (1024KB) + L1d L#20 (32KB) + L1i L#20 (32KB) + Core L#20</span></span><br><span class="line">        PU L<span class="comment">#40 (P#20)</span></span><br><span class="line">        PU L<span class="comment">#41 (P#60)</span></span><br><span class="line">      L2 L<span class="comment">#21 (1024KB) + L1d L#21 (32KB) + L1i L#21 (32KB) + Core L#21</span></span><br><span class="line">        PU L<span class="comment">#42 (P#21)</span></span><br><span class="line">        PU L<span class="comment">#43 (P#61)</span></span><br><span class="line">      L2 L<span class="comment">#22 (1024KB) + L1d L#22 (32KB) + L1i L#22 (32KB) + Core L#22</span></span><br><span class="line">        PU L<span class="comment">#44 (P#22)</span></span><br><span class="line">        PU L<span class="comment">#45 (P#62)</span></span><br><span class="line">      L2 L<span class="comment">#23 (1024KB) + L1d L#23 (32KB) + L1i L#23 (32KB) + Core L#23</span></span><br><span class="line">        PU L<span class="comment">#46 (P#23)</span></span><br><span class="line">        PU L<span class="comment">#47 (P#63)</span></span><br><span class="line">      L2 L<span class="comment">#24 (1024KB) + L1d L#24 (32KB) + L1i L#24 (32KB) + Core L#24</span></span><br><span class="line">        PU L<span class="comment">#48 (P#24)</span></span><br><span class="line">        PU L<span class="comment">#49 (P#64)</span></span><br><span class="line">      L2 L<span class="comment">#25 (1024KB) + L1d L#25 (32KB) + L1i L#25 (32KB) + Core L#25</span></span><br><span class="line">        PU L<span class="comment">#50 (P#25)</span></span><br><span class="line">        PU L<span class="comment">#51 (P#65)</span></span><br><span class="line">      L2 L<span class="comment">#26 (1024KB) + L1d L#26 (32KB) + L1i L#26 (32KB) + Core L#26</span></span><br><span class="line">        PU L<span class="comment">#52 (P#26)</span></span><br><span class="line">        PU L<span class="comment">#53 (P#66)</span></span><br><span class="line">      L2 L<span class="comment">#27 (1024KB) + L1d L#27 (32KB) + L1i L#27 (32KB) + Core L#27</span></span><br><span class="line">        PU L<span class="comment">#54 (P#27)</span></span><br><span class="line">        PU L<span class="comment">#55 (P#67)</span></span><br><span class="line">      L2 L<span class="comment">#28 (1024KB) + L1d L#28 (32KB) + L1i L#28 (32KB) + Core L#28</span></span><br><span class="line">        PU L<span class="comment">#56 (P#28)</span></span><br><span class="line">        PU L<span class="comment">#57 (P#68)</span></span><br><span class="line">      L2 L<span class="comment">#29 (1024KB) + L1d L#29 (32KB) + L1i L#29 (32KB) + Core L#29</span></span><br><span class="line">        PU L<span class="comment">#58 (P#29)</span></span><br><span class="line">        PU L<span class="comment">#59 (P#69)</span></span><br><span class="line">      L2 L<span class="comment">#30 (1024KB) + L1d L#30 (32KB) + L1i L#30 (32KB) + Core L#30</span></span><br><span class="line">        PU L<span class="comment">#60 (P#30)</span></span><br><span class="line">        PU L<span class="comment">#61 (P#70)</span></span><br><span class="line">      L2 L<span class="comment">#31 (1024KB) + L1d L#31 (32KB) + L1i L#31 (32KB) + Core L#31</span></span><br><span class="line">        PU L<span class="comment">#62 (P#31)</span></span><br><span class="line">        PU L<span class="comment">#63 (P#71)</span></span><br><span class="line">      L2 L<span class="comment">#32 (1024KB) + L1d L#32 (32KB) + L1i L#32 (32KB) + Core L#32</span></span><br><span class="line">        PU L<span class="comment">#64 (P#32)</span></span><br><span class="line">        PU L<span class="comment">#65 (P#72)</span></span><br><span class="line">      L2 L<span class="comment">#33 (1024KB) + L1d L#33 (32KB) + L1i L#33 (32KB) + Core L#33</span></span><br><span class="line">        PU L<span class="comment">#66 (P#33)</span></span><br><span class="line">        PU L<span class="comment">#67 (P#73)</span></span><br><span class="line">      L2 L<span class="comment">#34 (1024KB) + L1d L#34 (32KB) + L1i L#34 (32KB) + Core L#34</span></span><br><span class="line">        PU L<span class="comment">#68 (P#34)</span></span><br><span class="line">        PU L<span class="comment">#69 (P#74)</span></span><br><span class="line">      L2 L<span class="comment">#35 (1024KB) + L1d L#35 (32KB) + L1i L#35 (32KB) + Core L#35</span></span><br><span class="line">        PU L<span class="comment">#70 (P#35)</span></span><br><span class="line">        PU L<span class="comment">#71 (P#75)</span></span><br><span class="line">      L2 L<span class="comment">#36 (1024KB) + L1d L#36 (32KB) + L1i L#36 (32KB) + Core L#36</span></span><br><span class="line">        PU L<span class="comment">#72 (P#36)</span></span><br><span class="line">        PU L<span class="comment">#73 (P#76)</span></span><br><span class="line">      L2 L<span class="comment">#37 (1024KB) + L1d L#37 (32KB) + L1i L#37 (32KB) + Core L#37</span></span><br><span class="line">        PU L<span class="comment">#74 (P#37)</span></span><br><span class="line">        PU L<span class="comment">#75 (P#77)</span></span><br><span class="line">      L2 L<span class="comment">#38 (1024KB) + L1d L#38 (32KB) + L1i L#38 (32KB) + Core L#38</span></span><br><span class="line">        PU L<span class="comment">#76 (P#38)</span></span><br><span class="line">        PU L<span class="comment">#77 (P#78)</span></span><br><span class="line">      L2 L<span class="comment">#39 (1024KB) + L1d L#39 (32KB) + L1i L#39 (32KB) + Core L#39</span></span><br><span class="line">        PU L<span class="comment">#78 (P#39)</span></span><br><span class="line">        PU L<span class="comment">#79 (P#79)</span></span><br><span class="line">    HostBridge L<span class="comment">#5</span></span><br><span class="line">      PCIBridge</span><br><span class="line">        PCI 8086:1521</span><br><span class="line">          Net L<span class="comment">#3 &quot;enp175s0f0&quot;</span></span><br><span class="line">        PCI 8086:1521</span><br><span class="line">          Net L<span class="comment">#4 &quot;enp175s0f1&quot;</span></span><br><span class="line">        PCI 8086:1521</span><br><span class="line">          Net L<span class="comment">#5 &quot;enp175s0f2&quot;</span></span><br><span class="line">        PCI 8086:1521</span><br><span class="line">          Net L<span class="comment">#6 &quot;enp175s0f3&quot;</span></span><br><span class="line">      PCIBridge</span><br><span class="line">        PCI 8086:10fb</span><br><span class="line">          Net L<span class="comment">#7 &quot;enp176s0f0&quot;</span></span><br><span class="line">        PCI 8086:10fb</span><br><span class="line">          Net L<span class="comment">#8 &quot;enp176s0f1&quot;</span></span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br></pre></td></tr></table></figure>

<h2 id="Virtual-Machines-and-CPU-Topology"><a href="#Virtual-Machines-and-CPU-Topology" class="headerlink" title="Virtual Machines and CPU Topology"></a>Virtual Machines and CPU Topology</h2><p>Virtual machines (VMs) are software programs that create an isolated environment for running operating systems and applications. VMs are often used to run various operating systems on the same physical machine or to run applications that require more resources than are available on the host machine.</p>
<p>When a VM is created, the hypervisor, which manages the VMs, assigns a single thread to the VM. This is because assigning multiple threads to a VM can lead to performance issues. Threads share the same resources on a core, and multiple threads can compete for resources, leading to contention and slowdowns. Furthermore, threads may interfere with each other, causing further slowdowns.</p>
<p>To optimize VM performance, it’s generally best to assign a single thread to a VM. However, there are exceptions to this rule. For example, if a VM is running an application that is specifically designed to take advantage of multiple threads, it may be beneficial to assign multiple threads to the VM.</p>
<p>To take advantage of multiple threads in a virtual machine, it’s essential to use a hypervisor that supports thread pinning, an operating system that supports thread scheduling, and an application that is designed to take advantage of multiple threads. Multithreaded applications such as web servers, database servers, and media transcoders are good examples of applications that can take advantage of multiple threads.</p>
<h2 id="Why-thread-of-cpu-toplogy-always-1-or-2"><a href="#Why-thread-of-cpu-toplogy-always-1-or-2" class="headerlink" title="Why thread of cpu toplogy always 1 or 2"></a>Why thread of cpu toplogy always 1 or 2</h2><p>There are two main reasons why the number of threads in a CPU topology is usually limited to 1 or 2:</p>
<ul>
<li><strong>Physical constraints:</strong> A CPU core can only run a single thread at a time due to having a single instruction pointer (IP) and a single set of registers. When two threads run on the same core, they compete for the same resources, leading to performance degradation.</li>
<li><strong>Scheduling overhead:</strong> Scheduling threads on different cores can be expensive, as the operating system has to switch between threads and this may cause context switches. Context switches are costly, as they require the operating system to save the state of the current thread and restore the state of the next.</li>
</ul>
<p>In some cases, having more than two threads per core may be beneficial. For instance, heavily multithreaded applications may take advantage of the extra threads. However, in most cases, the costs of having more than two threads per core outweigh the benefits.</p>
<p>There are a few exceptions to the rule that the number of threads in a CPU topology is usually limited to 1 or 2. For example, some CPUs support hyper-threading, which allows a single core to run two threads simultaneously. However, hyper-threading is not always a good idea, as it can sometimes lead to performance degradation.</p>
<p>Overall, the number of threads in a CPU topology is usually limited to 1 or 2 due to physical constraints and scheduling overhead. While there are exceptions, in most cases, the costs of having more than two threads per core outweigh the benefits.</p>
<h2 id="Sockets-and-cores-with-performance"><a href="#Sockets-and-cores-with-performance" class="headerlink" title="Sockets and cores with performance"></a>Sockets and cores with performance</h2><p>Sockets and cores do have an impact on performance.</p>
<ul>
<li><strong>Sockets:</strong> A socket is a physical connector that holds a CPU. A system can have multiple sockets, each of which can hold multiple cores. The more sockets a system has, the more cores it can have, which can lead to better performance.</li>
<li><strong>Cores:</strong> A core is a single processing unit within a CPU. A core can run multiple threads simultaneously. The more cores a system has, the more threads it can run, which can also lead to better performance.</li>
</ul>
<p>However, it’s important to note that the number of sockets and cores is not the only factor that affects performance. Other factors, such as the clock speed of the CPU, the amount of cache memory, and the type of memory, can also have a significant impact.</p>
<p>In general, systems with more sockets and cores will have better performance than systems with fewer sockets and cores. However, it’s important to choose a system that has the right balance of sockets, cores, clock speed, cache memory, and memory type for your needs.</p>
<p>Here are some examples of how sockets and cores can impact performance:</p>
<ul>
<li>A system with two sockets and four cores will have better performance than a system with one socket and two cores. This is because the system with two sockets can run more threads simultaneously.</li>
<li>A system with a higher clock speed will have better performance than a system with a lower clock speed. This is because the system with a higher clock speed can execute instructions faster.</li>
<li>A system with more cache memory will have better performance than a system with less cache memory. This is because the system with more cache memory can store more data in memory, which reduces the number of times the CPU has to access slower memory.</li>
<li>A system with faster memory will have better performance than a system with slower memory. This is because the system with faster memory can transfer data to the CPU faster, which reduces the amount of time the CPU has to wait for data.</li>
</ul>
<h2 id="Why-aws-only-offer-single-sockets-instance"><a href="#Why-aws-only-offer-single-sockets-instance" class="headerlink" title="Why aws only offer single sockets instance?"></a>Why aws only offer single sockets instance?</h2><p>There are a few reasons why cloud providers like AWS do not offer multi-socket instances.</p>
<ul>
<li><strong>Cost:</strong> Multi-socket instances are more expensive than single-socket instances. This is because they require more hardware, such as more CPUs and more memory.</li>
<li><strong>Complexity:</strong> Multi-socket instances are more complex to manage than single-socket instances. This is because they have more components, such as more CPUs, more memory, and more storage.</li>
<li><strong>Performance:</strong> Multi-socket instances do not always offer better performance than single-socket instances. This is because the performance of a multi-socket instance can be limited by the speed of the interconnect between the sockets.</li>
</ul>
<p>For these reasons, cloud providers like AWS choose to offer single-socket instances. Single-socket instances are less expensive, easier to manage, and offer the same or better performance than multi-socket instances.</p>
<p>However, there are some cases where multi-socket instances may be a good choice. For example, if you need a lot of CPU power, or if you need to run applications that are not well-optimized for multi-threading, then a multi-socket instance may be a good option.</p>
<p>If you are considering using a multi-socket instance, it is important to weigh the costs and benefits carefully. You should also make sure that your applications are well-optimized for multi-threading.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/05/26/understanding-cpu-topology-for-improved-performance/" data-id="cli452qai00005qca451qe2yh" data-title="Understanding CPU Topology for Improved Performance" class="article-share-link">Share</a>
      
      
        <a href="/2023/05/26/understanding-cpu-topology-for-improved-performance/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/05/26/understanding-cpu-topology-for-improved-performance/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/performance/" rel="tag">performance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtualization/" rel="tag">virtualization</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-virtio-memory-balloon" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/27/virtio-memory-balloon/" class="article-date">
  <time class="dt-published" datetime="2023-04-27T06:20:37.000Z" itemprop="datePublished">2023-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/virtio-balloon/">virtio-balloon</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/27/virtio-memory-balloon/">Understand virtio memory balloon</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Virtio memory ballooning is a technique that adjusts memory allocation in virtualized environments. The hypervisor can add or remove memory from a virtual machine based on demand, using a balloon driver in the guest operating system. When demand is high, the balloon driver inflates and the guest operating system releases memory. When demand is low, the balloon driver deflates and the guest operating system can use more memory.</p>
<p>This technique optimizes memory usage and reduces the risk of memory exhaustion, making it useful in cloud computing environments. However, it also has trade-offs to consider. Inflating the balloon driver can cause performance issues if the guest operating system can’t release memory quickly enough. It may also struggle with high memory pressure. Understanding these limitations is key to making informed decisions about using virtio memory ballooning.</p>
<h2 id="Overview-of-Virtio-Memory-Ballooning"><a href="#Overview-of-Virtio-Memory-Ballooning" class="headerlink" title="Overview of Virtio Memory Ballooning"></a>Overview of Virtio Memory Ballooning</h2><p>Based on wiki <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_ballooning">memory ballooning</a> is a technique used to eliminate the need to overprovision host memory used by a virtual machine. To implement it, the virtual machine’s kernel implements a “balloon driver” which allocates unused memory within the VM’s address space into a reserved memory pool (the “balloon”) so that it is unavailable to other processes on the VM. However, rather than being reserved for other uses within the VM, the physical memory mapped to those pages within the VM is actually unmapped from the VM by the host operating system’s hypervisor, making it available for other uses by the host machine. Depending on the amount of memory required by the VM, the size of the “balloon” may be increased or decreased dynamically, mapping and unmapping physical memory as required by the VM.</p>
<p>According to the Virtio v1.2 specification, Virtio Memory Ballooning follows the Virtio protocol. Including:</p>
<h3 id="Feature-bits"><a href="#Feature-bits" class="headerlink" title="Feature bits"></a>Feature bits</h3><ul>
<li><strong>VIRTIO_BALLOON_F_MUST_TELL_HOST (0):</strong> Host must be notified before balloon pages are used.</li>
<li><strong>VIRTIO_BALLOON_F_STATS_VQ (1):</strong> A virtqueue is present for reporting guest memory statistics.</li>
<li><strong>VIRTIO_BALLOON_F_DEFLATE_ON_OOM (2):</strong> Balloon deflates when guest is out of memory.</li>
<li><strong>VIRTIO_BALLOON_F_FREE_PAGE_HINT (3):</strong> The device supports free page hinting. The configuration field <em>free_page_hint_cmd_id</em> is valid.</li>
<li><strong>VIRTIO_BALLOON_F_PAGE_POISON (4):</strong> The driver will immediately write <em>poison_val</em> to pages after deflating them. The configuration field <em>poison_val</em> is valid.</li>
<li><strong>VIRTIO_BALLOON_F_PAGE_REPORTING (5):</strong> The device supports free page reporting. A virtqueue is present for reporting free guest memory.</li>
</ul>
<h3 id="Memory-Statistics-Tags"><a href="#Memory-Statistics-Tags" class="headerlink" title="Memory Statistics Tags"></a>Memory Statistics Tags</h3><ul>
<li><strong>VIRTIO_BALLOON_S_SWAP_IN (0)</strong>: Amount of memory swapped in (in bytes).</li>
<li><strong>VIRTIO_BALLOON_S_SWAP_OUT (1)</strong>: Amount of memory swapped out to disk (in bytes).</li>
<li><strong>VIRTIO_BALLOON_S_MAJFLT (2)</strong>: Number of major page faults that have occurred.</li>
<li><strong>VIRTIO_BALLOON_S_MINFLT (3)</strong>: Number of minor page faults that have occurred.</li>
<li><strong>VIRTIO_BALLOON_S_MEMFREE (4)</strong>: Amount of memory not being used (in bytes).</li>
<li><strong>VIRTIO_BALLOON_S_MEMTOT (5)</strong>: Total amount of memory available (in bytes).</li>
<li><strong>VIRTIO_BALLOON_S_AVAIL (6)</strong>: Estimate of available memory (in bytes) for starting new applications.</li>
<li><strong>VIRTIO_BALLOON_S_CACHES (7)</strong>: Amount of memory (in bytes) that can be quickly reclaimed without I/O.</li>
<li><strong>VIRTIO_BALLOON_S_HTLB_PGALLOC (8)</strong>: Number of successful hugetlb page allocations in the guest.</li>
<li><strong>VIRTIO_BALLOON_S_HTLB_PGFAIL (9)</strong>: Number of failed hugetlb page allocations in the guest.</li>
</ul>
<h3 id="Free-page-hinting"><a href="#Free-page-hinting" class="headerlink" title="Free page hinting"></a>Free page hinting</h3><p>Free page hinting is used during migration to determine which pages within the guest are not being used. These pages are then skipped over while migrating the guest. The device will indicate it is ready to start hinting by setting the <em>free_page_hint_cmd_id</em> to one of the non-reserved values that can be used as a command ID. The driver is notified of the following reserved values:</p>
<ul>
<li>VIRTIO_BALLOON_CMD_ID_STOP (0): any previously supplied command ID is invalid. The driver should stop hinting free pages until a new command ID is supplied, but should not release any hinted pages for use by the guest.</li>
<li>VIRTIO_BALLOON_CMD_ID_DONE (1): any previously supplied command ID is invalid. The driver should stop hinting free pages and release all hinted pages for use by the guest.</li>
</ul>
<p>When a hint is provided, it indicates that the data contained in the given page is no longer needed and can be discarded. If the driver writes to the page, this overrides the hint and the data will be retained. Any stale pages that have not been written to since the page was hinted may lose their content. If read, the contents of such pages will be uninitialized memory.</p>
<h3 id="Page-Poison"><a href="#Page-Poison" class="headerlink" title="Page Poison"></a>Page Poison</h3><p>Page Poison is a feature that lets the host know when the guest is initializing free pages with <em>poison_val</em>. When enabled, the driver immediately writes to pages after deflating and pages reported as free will retain <em>poison_val</em>. If the guest is not initializing freed pages, the driver should reject the VIRTIO_BALLOON_F_PAGE_POISON feature. If the feature has been negotiated, the driver will place the initialization value into the <em>poison_val</em> configuration field data.</p>
<h3 id="Free-Page-Reporting"><a href="#Free-Page-Reporting" class="headerlink" title="Free Page Reporting"></a>Free Page Reporting</h3><p>Free Page Reporting is a method similar to balloon inflation, but without a deflation queue. Reported free pages can be reused by the driver after the request is acknowledged, without notifying the device.</p>
<p>The driver initiates reporting by gathering free pages into a scatter-gather list, which is then added to the reporting_vq. The exact timing and selection of free pages is determined by the driver.</p>
<p>Once the driver has enough pages available, it sends a reporting request to the device, which acknowledges the request using the reporting_vq descriptor. After acknowledgement, the driver can reuse the reported free pages by returning them to the free page lists in the guest operating system.</p>
<p>The driver can continue to gather and report free pages until it has reached the desired number of pages.</p>
<h2 id="Comparison-to-Other-Memory-Management-Techniques"><a href="#Comparison-to-Other-Memory-Management-Techniques" class="headerlink" title="Comparison to Other Memory Management Techniques"></a>Comparison to Other Memory Management Techniques</h2><p>Virtio memory ballooning is just one of several memory management techniques available in virtualized environments. Here are some other techniques that are commonly used:</p>
<h3 id="Overcommitment"><a href="#Overcommitment" class="headerlink" title="Overcommitment"></a>Overcommitment</h3><p>Overcommitment is a technique that allows virtual machines to use more memory than physically available. This is useful when memory demand is highly variable. However, overcommitment can cause performance issues if the host system runs out of memory and needs to swap memory pages to disk.</p>
<p>KVM hypervisor automatically overcommits CPUs and memory. This means that more virtualized CPUs and memory can be allocated to virtual machines than there are physical resources. This saves system resources, resulting in less power, cooling, and investment in server hardware while still allowing under-utilized virtualized servers or desktops to run on fewer hosts.</p>
<h3 id="Memory-Compression"><a href="#Memory-Compression" class="headerlink" title="Memory Compression"></a>Memory Compression</h3><p>Memory compression compresses memory pages to free up memory in high demand situations. However, this technique can lead to performance problems if the compression algorithm is slow or if memory demand is high.</p>
<p>Zram, zcache, and zswap advance in-kernel compression in different ways. Zram and zcache, both found in the staging tree, have improved in design and implementation, but they are not stable enough for promotion into the core kernel. Zswap proposes a simplified frontswap-only fork of zcache for direct merging into the MM subsystem. While simpler than zcache, zswap is entirely dependent on still-in-staging zsmalloc and has limitations. If zswap is merged, it remains to be seen if it will ever be extended adequately.</p>
<h3 id="Hypervisor-Swapping"><a href="#Hypervisor-Swapping" class="headerlink" title="Hypervisor Swapping"></a>Hypervisor Swapping</h3><p>Hypervisor swapping is a technique in which the hypervisor swaps memory pages between the host and guest operating systems in order to optimize memory usage. This can be useful in situations where there is a high demand for memory or when the host system is running low on memory. However, hypervisor swapping can also lead to performance issues if the guest operating system can’t release memory quickly enough.</p>
<p>Compared to these techniques, virtio memory ballooning has some unique advantages. It optimizes memory usage within the guest operating system itself, reducing the risk of memory exhaustion and improving performance. However, it also has some trade-offs to consider, such as the potential for performance issues if the guest operating system can’t release memory quickly enough.</p>
<h2 id="How-to-use-Virtio-Memory-Ballooning-on-linux"><a href="#How-to-use-Virtio-Memory-Ballooning-on-linux" class="headerlink" title="How to use Virtio Memory Ballooning on linux"></a>How to use Virtio Memory Ballooning on linux</h2><h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p>On host side we use libvirt to setup a vm.</p>
<p>The memory tag means: The maximum allocation of memory for the guest at boot time.</p>
<p>The currentMemory tag means: The actual allocation of memory for the guest.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">maxMemory</span> <span class="attr">slots</span>=<span class="string">&#x27;16&#x27;</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>1524288<span class="tag">&lt;/<span class="name">maxMemory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>8388608<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">currentMemory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>8388608<span class="tag">&lt;/<span class="name">currentMemory</span>&gt;</span></span><br></pre></td></tr></table></figure>

<aside>
💡 The maxMemory tag means: the run time maximum memory allocation of the guest. The initial memory specified by either the <memory> element or the NUMA cell size configuration can be increased by hot-plugging of memory to the limit specified by this element.

</aside>

<p>And add memballoon virtio device in vm xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">memballoon</span> <span class="attr">model</span>=<span class="string">&#x27;virtio&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>To use Virtio Memory Ballooning on Linux guest, you’ll need to ensure that your kernel has support for the virtio_balloon driver. You can check for this by running the following command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep virtio_balloon</span><br></pre></td></tr></table></figure>

<aside>
💡 If you want to test pm_sleep make sure CONFIG_PM_SLEEP is enabled

</aside>

<p>If the virtio_balloon driver is not listed, you may need to load it manually by running the following command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe virtio_balloon</span><br></pre></td></tr></table></figure>

<p>We can do some test to confirm balloon driver is working:</p>
<h3 id="Basic-usage"><a href="#Basic-usage" class="headerlink" title="Basic usage"></a>Basic usage</h3><p>Explaination from </p>
<p><a target="_blank" rel="noopener" href="https://github.com/libvirt/libvirt/blob/master/docs/manpages/virsh.rst">libvirt/virsh.rst at master · libvirt/libvirt</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh dommemstat YOUR_VM_NAME          </span></span><br><span class="line">actual 8388608          <span class="comment"># Current balloon value (in KB)</span></span><br><span class="line">swap_in 7011156         <span class="comment"># The amount of data read from swap space (in kB)</span></span><br><span class="line">swap_out 664776         <span class="comment"># The amount of memory written out to swap space (in kB)</span></span><br><span class="line">major_fault 234565      <span class="comment"># The number of page faults where disk IO was required</span></span><br><span class="line">minor_fault 84722778    <span class="comment"># The number of other page faults</span></span><br><span class="line">unused 6291308          <span class="comment"># The amount of memory left unused by the system (in kB)</span></span><br><span class="line">available 8388044       <span class="comment"># The amount of usable memory as seen by the domain (in kB)</span></span><br><span class="line">usable 6349618          <span class="comment"># The amount of memory which can be reclaimed by balloon without causing host swapping (in KB) *</span></span><br><span class="line">last_update 1682566755  <span class="comment"># Timestamp of the last update of statistics (in seconds)</span></span><br><span class="line">disk_caches 116620      <span class="comment"># The amount of memory that can be reclaimed without additional I/O, typically disk caches (in KiB)</span></span><br><span class="line">rss 8529188             <span class="comment"># Resident Set Size of the running domain&#x27;s process (in kB)</span></span><br></pre></td></tr></table></figure>

<p>with memory balloon we can get details about guest usage which matches the Memory Statistics Tags we metioned above.</p>
<p>And from dominfo we can see the memory usage directly</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh dominfo YOUR_VM_NAME</span></span><br><span class="line">Id:             7</span><br><span class="line">Name:           1970b0ef25e44adc834767fe81f155d5</span><br><span class="line">UUID:           1970b0ef-25e4-4adc-8347-67fe81f155d5</span><br><span class="line">OS Type:        hvm</span><br><span class="line">State:          running</span><br><span class="line">CPU(s):         4</span><br><span class="line">CPU time:       214084.1s</span><br><span class="line">Max memory:     8388608 KiB</span><br><span class="line">Used memory:    8388608 KiB</span><br><span class="line">Persistent:     yes</span><br><span class="line">Autostart:      <span class="built_in">disable</span></span><br><span class="line">Managed save:   no</span><br><span class="line">Security model: none</span><br><span class="line">Security DOI:   0</span><br></pre></td></tr></table></figure>

<h3 id="Shrinking-memory"><a href="#Shrinking-memory" class="headerlink" title="Shrinking memory"></a>Shrinking memory</h3><p>At first, check the unused memory of your guest</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh dommemstat YOUR_VM_NAME | grep unused</span></span><br><span class="line">unused 2868704</span><br></pre></td></tr></table></figure>

<p>then we try to set memory to a size we want</p>
<p>Simply, </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use actual - unused = 8388608 - 2868704 = 5519904</span><br></pre></td></tr></table></figure>

<p>Then we use setmem</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh setmem YOUR_VM_NAME --size 5519904KiB --current</span></span><br></pre></td></tr></table></figure>

<p>Check the shrink take effects:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh dommemstat YOUR_VM_NAME</span></span><br><span class="line">actual 5519904</span><br><span class="line">swap_in 0</span><br><span class="line">swap_out 2592</span><br><span class="line">major_fault 6236</span><br><span class="line">minor_fault 181380396</span><br><span class="line">unused 140212</span><br><span class="line">available 5139400</span><br><span class="line">usable 3424496</span><br><span class="line">last_update 1682567978</span><br><span class="line">rss 5583008</span><br></pre></td></tr></table></figure>

<p>actual changed to 5519904 and we check the guest on the other side</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># free -hm</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           4.9G        862M        134M        299M        3.9G        3.3G</span><br><span class="line">Swap:          7.9G        3.5M        7.9G</span><br></pre></td></tr></table></figure>

<p>Total memory changed even smaller than 5519904 ~= 5.26G about 7% memory missing and almost same with available 5139400</p>
<aside>
💡 Qemu level vm statistics may different from the statistics inside guest.

</aside>

<h3 id="Expanding-memory"><a href="#Expanding-memory" class="headerlink" title="Expanding memory"></a><strong><strong>Expanding</strong></strong> memory</h3><p>To increase the memory allocation of a virtual machine using virtio memory ballooning, you can use the <code>virsh setmem</code> command. For example, to increase the memory allocation to 8GB, you would run:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh setmem YOUR_VM_NAME --size 8G --current</span><br></pre></td></tr></table></figure>

<p>This will increase the memory allocation of the virtual machine to 8GB. However, it’s important to note that the guest operating system must have support for virtio memory ballooning in order to take advantage of this feature.</p>
<p>In addition, it’s important to monitor the memory usage of virtual machines to ensure that they have enough memory to operate effectively. This can be done using tools like <code>virsh dommemstat</code> to monitor memory usage statistics.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh dommemstat YOUR_VM_NAME</span></span><br><span class="line">actual 8388608</span><br><span class="line">swap_in 0</span><br><span class="line">swap_out 2592</span><br><span class="line">major_fault 6236</span><br><span class="line">minor_fault 181827159</span><br><span class="line">unused 3008116</span><br><span class="line">available 8008104</span><br><span class="line">usable 6293140</span><br><span class="line">last_update 1682571788</span><br><span class="line">rss 7545844</span><br></pre></td></tr></table></figure>

<aside>
💡 Unused memory after increase may not changed right now, wait for a minute to see its changes.

</aside>

<p>Inside guest</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># free -hm</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.6G        862M        2.9G        299M        3.9G        6.0G</span><br><span class="line">Swap:          7.9G        3.5M        7.9G</span><br></pre></td></tr></table></figure>

<p>With 8GB memory from qemu side, guest have total 7.6G memory. There is still a 5% missing.</p>
<h2 id="Industry-Practices"><a href="#Industry-Practices" class="headerlink" title="Industry Practices"></a>Industry Practices</h2><h3 id="Proxmox"><a href="#Proxmox" class="headerlink" title="Proxmox"></a>Proxmox</h3><p><a target="_blank" rel="noopener" href="https://pve.proxmox.com/wiki/Dynamic_Memory_Management">Dynamic memory management</a> shows that KSM and memory balloon works on windows and linux guest, a memory range from min and max will be required and guest’s memory will dynamicly changed between the range to impelement memory ballooning.</p>
<h3 id="Google-cloud"><a href="#Google-cloud" class="headerlink" title="Google cloud"></a>Google cloud</h3><p><a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/dynamic-resource-management">Dynamic resource management</a> Memory ballooning is an interface mechanism between host and guest to dynamically adjust the size of the reserved memory for the guest. A <a target="_blank" rel="noopener" href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html#x1-2790005">virtio memory balloon device</a> <br> is used to implement memory ballooning. Through the virtio memory balloon device, a host can explicitly ask a guest to yield a certain amount of free memory pages (also called memory balloon inflation), and reclaim the memory so that the host can use the free memory for other VMs. Likewise, the virtio memory balloon device can return memory pages back to the guest by deflating the memory balloon.</p>
<p>Compute Engine E2 VM instances that are based on a <a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/images#os-compute-support">public image</a><br> have a <a target="_blank" rel="noopener" href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html#x1-2790005">virtio memory balloon device</a> , which monitors the guest operating system’s memory use. The guest operating system communicates its available memory to the host system. The host reallocates any unused memory to other processes on demand, thereby using memory more effectively. Compute Engine collects and uses this data to make more accurate <a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/instances/apply-machine-type-recommendations-for-instances">rightsizing recommendations</a>.</p>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_kernel_version_history">Linux kernels</a> before 5.2, the Linux memory system sometimes mistakenly prevents large allocations when the balloon device is present. This is rarely an issue in practice, but we recommend changing the virtual memory <code>overcommit_memory</code> setting to <code>1</code> to prevent the issue from occurring. This change is already made by default in all Google-provided images published since February 9, 2021.</p>
<p>To fix the setting, use the following command to change the value from <code>0</code> to <code>1</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;sbin&#x2F;sysctl -w vm.overcommit_memory&#x3D;1</span><br></pre></td></tr></table></figure>

<p>To persist this change across reboots, add the following to your <code>/etc/sysctl.conf</code> file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.overcommit_memory&#x3D;1</span><br></pre></td></tr></table></figure>

<h3 id="Nutanix"><a href="#Nutanix" class="headerlink" title="Nutanix"></a>Nutanix</h3><p><a target="_blank" rel="noopener" href="https://www.nutanix.dev/2022/05/05/squeeze-even-more-out-of-your-hci/">Squeeze even more memory of your HCI</a> </p>
<p>Memory overcommit allows more memory to be assigned to VMs than is physically present in the server hardware. Unused memory allocated to a VM can be reclaimed by the hypervisor and made available to other VMs on the host. AHV adjusts memory usage for each VM according to its usage, allowing the host to use excess memory to satisfy the requirements of other VMs. This reduces hardware costs for large deployments or increases the utilization of an existing environment that can’t be immediately expanded with new nodes. VMs without memory overcommit will operate with their pre-assigned memory, and can coexist with overcommit enabled VMs. Nutanix uses a multi-tier approach combining ballooning and hypervisor-level swap to optimize performance. Metrics are presented to the administrator in Prism Central to indicate the gains achieved through overcommit and its impact on VM performance. Memory overcommit may not be appropriate for performance-sensitive workloads due to its dynamic nature.</p>
<p><a target="_blank" rel="noopener" href="https://portal.nutanix.com/page/documents/details?targetId=AHV-Admin-Guide-v6_1:ahv-vm-limitations-memory-overcommit-c.html">Limits of Memory Overcommit</a></p>
<p>Memory overcommit has the following limitations:</p>
<ul>
<li>You can enable or disable Memory Overcommit only while the VM is powered off.</li>
<li>Power off the VM enabled with memory overcommit before you change the memory allocation for the VM.<br>For example, you cannot update the memory of a VM that is enabled with memory overcommit when it is still running. The system displays the following alert: InvalidVmState: Cannot complete request in state on.</li>
<li>Memory overcommit is not supported with VMs that use GPU passthrough and vNUMA.<br>For example, you cannot update a VM to a vNUMA VM when it is enabled with memory overcommit. The system displays the following alert: InvalidArgument: Cannot use memory overcommit feature for a vNUMA VM error.</li>
<li>Memory overcommit feature can slow down the performance and the predictable performance of the VM<br>For example, migrating a VM enabled with Memory Overcommit takes longer than migrating a VM not enabled with Memory Overcommit.</li>
<li>There may be a temporary spike in the aggregate memory usage in the cluster during the migration of a VM enabled with Memory Overcommit from one node to another.<br>For example, when you migrate a VM from Node A to Node B, the total memory used in the cluster during migration is greater than the memory usage before the migration.<br>The memory usage of the cluster eventually drops back to pre-migration levels when the cluster reclaims the memory for other VM operations.</li>
<li>Using Memory Overcommit heavily can cause a spike in the disk space utilization in the cluster. This spike is caused because the Host Swap uses some of the disk space in the cluster.<br>If the VMs do not have a swap disk, then in case of memory pressure, AHV uses space from the swap disk created on ADSF to provide memory to the VM. This can lead to an increase in disk space consumption on the cluster.</li>
<li>All DR operations except Cross Cluster Live Migration (CCLM) are supported<br>On the destination side, if a VM fails when you enable Memory Overcommit, the failed VM fails over (creating the VM on the remote site) as a fixed size VM. You can enable Memory Overcommit on this VM after the failover is complete.</li>
</ul>
<h2 id="Limitations-and-Challenges"><a href="#Limitations-and-Challenges" class="headerlink" title="Limitations and Challenges"></a>Limitations and Challenges</h2><p>Guest should support virtio memory ballooning, if the balloon driver not available there is no effective way to do it.</p>
<table>
<thead>
<tr>
<th>Distribution</th>
<th>No Balloon Driver</th>
<th>Partially Supported</th>
<th>Fully Supported</th>
</tr>
</thead>
<tbody><tr>
<td>CentOS</td>
<td>6.1, 6.2</td>
<td>6.3–6.9, 7.1, 7.2</td>
<td>7.3–7.7, 8.0–8.2</td>
</tr>
<tr>
<td>Oracle</td>
<td>7.3</td>
<td>7.4, 7.5</td>
<td>7.6, 7.7</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>See note.</td>
<td>12.04</td>
<td>14.04 and newer</td>
</tr>
</tbody></table>
<aside>
💡 Some Ubuntu versions have a working balloon driver but it may be disabled by default.

</aside>

<p>Not all situations are suitable for memory ballooning. Frequent expansion and contraction of memory can be harmful if the memory usage changes dynamically.</p>
<h2 id="Future-Development"><a href="#Future-Development" class="headerlink" title="Future Development"></a>Future Development</h2><p><a target="_blank" rel="noopener" href="https://www.linux-kvm.org/page/Projects/auto-ballooning">https://www.linux-kvm.org/page/Projects/auto-ballooning</a> The auto ballooning project was initiated in 2013. The hypervisor and Linux kernel need to be updated to support the project, which has not been upstreamed yet.</p>
<h2 id="Real-World-Implementation-Case-Study"><a href="#Real-World-Implementation-Case-Study" class="headerlink" title="Real-World Implementation Case Study"></a>Real-World Implementation Case Study</h2><ul>
<li><strong><strong><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=r1wxgLTG40g">Lessons Learned Building a Production Memory-Overcommit Solution</a></strong></strong></li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Virtualization is important in modern computing for flexible and efficient resource allocation. Memory management is challenging in virtualized environments when multiple virtual machines run on a single physical server. Virtio memory ballooning optimizes memory usage by dynamically adjusting guest memory reservation. It improves performance and reduces the risk of memory exhaustion. This article explains how to use virtio memory ballooning on Linux, compares it to other memory management techniques, and discusses industry practices, limitations, and future developments.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/libvirt/libvirt/blob/master/docs/manpages/virsh.rst">libvirt/virsh.rst at master · libvirt/libvirt</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html#x1-2790005">virtio-v1.1-csprd01/virtio-v1.1-csprd01.html#x1-2790005</a></li>
<li><a target="_blank" rel="noopener" href="https://pve.proxmox.com/wiki/Dynamic_Memory_Management">Dynamic memory management</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/dynamic-resource-management">Dynamic resource management</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nutanix.dev/2022/05/05/squeeze-even-more-out-of-your-hci/">Squeeze even more memory of your HCI</a></li>
<li><a target="_blank" rel="noopener" href="https://portal.nutanix.com/page/documents/details?targetId=AHV-Admin-Guide-v6_1:ahv-vm-limitations-memory-overcommit-c.html">Limits of Memory Overcommit</a></li>
<li><a target="_blank" rel="noopener" href="https://www.linux-kvm.org/page/Projects/auto-ballooning">https://www.linux-kvm.org/page/Projects/auto-ballooning</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=r1wxgLTG40g">Lessons Learned Building a Production Memory-Overcommit Solution</a></li>
</ul>
<p>Powered by Notion AI</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/04/27/virtio-memory-balloon/" data-id="clgyqlnf10000ayca8dho589n" data-title="Understand virtio memory balloon" class="article-share-link">Share</a>
      
      
        <a href="/2023/04/27/virtio-memory-balloon/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/04/27/virtio-memory-balloon/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memory-balloon/" rel="tag">memory balloon</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-qemu-colo-details" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/13/qemu-colo-details/" class="article-date">
  <time class="dt-published" datetime="2023-04-13T15:49:38.000Z" itemprop="datePublished">2023-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/13/qemu-colo-details/">Qemu Colo Details</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="qemu-quorum-block-filter"><a href="#qemu-quorum-block-filter" class="headerlink" title="qemu quorum block filter"></a>qemu quorum block filter</h2><p>Based on the code design of blkverify.c and blkmirror.c, the main purpose is to mirror write requests to all the qcow images hanging in the quorum, and the read operation is to check whether the number of occurrences of the qiov version meets the value set by the threshold through the parameters set by the threshold. Then it returns the &gt; value of the result with the highest number of occurrences, if the number of occurrences i is less than the threshold then it returns the quourm exception and the read operation returns -EIO.</p>
<p>The main use of this feature is for people who use NFS devices affected by bitflip errors.</p>
<p>If you set the read-pattern to FIFO and set the threshold to 1, you can construct a read-only first disk scenario.</p>
<h2 id="block-replication"><a href="#block-replication" class="headerlink" title="block-replication"></a>block-replication</h2><p>The micro checkpoint and COLO mentioned in the introduction to the QEMU FT solution will continuously create checkpoints, and the state of the pvm and svm will be the same at the moment the checkpoint is completed. But it will not be consistent until the next checkpoint.</p>
<p>To ensure consistency, the SVM changes need to be cached and discarded at the next checkpoint. To reduce the stress of network transfers between checkpoints, changes on the PVM disk are synchronized asynchronously to the SVM node.</p>
<p>For example, the first time VM1 does a checkpoint, it is recorded as state C1, then VM2’s state is also C1, at this time VM2’s disk changes start to cache, VM1’s changes are written to VM2’s node through this mechanism, if an error occurs at this time how should it be handled?</p>
<p>Suppose we discuss the simplest case of VM1 hanging, then because the next checkpoint has not yet been executed, VM2 continues to run the state of C1 for a period of time and the disk changes are cached, at this time it is only necessary to flush the cached data to VM2’s disk single point to continue to run or wait for FT reconstruction, which is the reason for the need to do SVM disk changes caching (here the data (including two copies, one is to restore to VM2 last checkpoint cache, the other is to VM2 in C1 after the cache of changes)</p>
<p>The following is the structure of block-replication:</p>
<img src="/2023/04/13/qemu-colo-details/fig1.png" class="">

<ol>
<li>The block device on the primary node mounts two sub-devices via quorum, providing backup from the primary node to the secondary host. The read pattern (FIFO) is extended to meet the situation where the primary node will only read the local disk (the threshold needs to be set to 1 so that read operations will only be performed locally)</li>
<li>A newly implemented filter called replication is responsible for controlling block replication</li>
<li>The secondary node receives disk write requests from the primary node through the embedded nbd server</li>
<li>The device on the secondary node is a custom block device, we call it an active disk. it should be an empty device at the beginning, but the block device needs to support bdrv_make_empty() and backing_file</li>
<li>The hidden-disk is created automatically, and this file caches the contents modified by what is written from the primary node. It should also be an empty device at the beginning and support bdrv_make_empty() and backing_file</li>
<li>The blockdev-backup job (sync=none) will synchronize all the contents of the hidden-disk cache that should have been overwritten by nbd-induced writes, so the primary and secondary nodes should have the same disk contents before the replication starts</li>
<li>The secondary node also has a quorum node, so that the secondary can become the new primary after the failover and continue to perform the replication</li>
</ol>
<p>There are seven types of internal errors that can exist when block replication runs:</p>
<ol>
<li>Primary disk I/O errors</li>
<li>Primary disk forwarding errors</li>
<li>blockdev-backup error</li>
<li>secondary disk I/O errors</li>
<li>active disk I/O error</li>
<li>Error clearing hidden disk and active disk</li>
<li>failover failure</li>
</ol>
<p>For error 1 and error 5, just report block level errors directly upwards.</p>
<p>For 2, 3, 4, and 6 need to be reported to the control plane of FT for failover process control.</p>
<p>In the case of 7, if the active commit fails, it will prompt a secondary node write operation error and let the person performing the failover decide how to handle it.</p>
<h2 id="colo-checkpoint"><a href="#colo-checkpoint" class="headerlink" title="colo checkpoint "></a>colo checkpoint </h2><p>colo uses vm’s live migration to achieve the checkpoint function</p>
<p>Based on the above block-replication to achieve disk synchronization, the other part is how to synchronize the running state data of virtual machines, here directly using the existing live migration, that is, cloud host hot migration, so that after each checkpoint can be considered pvm and svm disk/memory are consistent, so need to be in This event depends on the time of live migration.</p>
<p>First, let’s organize the checkpoint process, which is divided into two major parts</p>
<h3 id="Configuration-phase"><a href="#Configuration-phase" class="headerlink" title="Configuration phase"></a>Configuration phase</h3><p>This part will be executed mainly when the colo is first set up, we know that by default at the beginning we will configure the disk synchronization of pvm and svm, but the memory is not actually synchronized yet, so at the beginning we will ask the svm to be pused at first after the startup, and then submit two synchronization operations from the pvm side</p>
<ol>
<li>Submit the drive-mirror task to mirror the contents of the disk from the pvm to the remote svm’s disk (embedded nbd is used here, which is also the target disk of the block replicaton later) to ensure that the pvm’s contents are consistent with the svm’s</li>
<li>Submit a migration task to synchronize memory from pvm to svm, and since both pvm and svm are required to be paired at this point, you actually wait until both pvm and svm are synchronized, then you need to cancel the drive-mirror task, start block replication, and continue running vm<br>Of course, the paused state mentioned in 2 has been changed to be similar to hot migration after the improvements made by intel. After the drive-mirror task is submitted, the id of the task and the information of the block replication disks are used as parameters for the colo migration, which will actually be automatically changed when migrating in the line of online migration. After the migration is completed, the drive-mirror task is automatically cancelled and block-replication is automatically started before running vm, which simplifies the steps a lot.</li>
</ol>
<p>After the configuration, you need to manually issue a migrate command to the colo pvm, and the checkpoint will enter the cycle of monitoring after the first migrate.</p>
<img src="/2023/04/13/qemu-colo-details/fig2.png" class="">

<h3 id="Start-the-checkpoint"><a href="#Start-the-checkpoint" class="headerlink" title="Start the checkpoint"></a>Start the checkpoint</h3><p>The checkpoint mechanism consists mainly of a loop, and the code flow of qemu is as follows:</p>
<img src="/2023/04/13/qemu-colo-details/fig3.png" class="">

<p>Combined with this picture we explain the more important parts inside</p>
<h4 id="Process-phase"><a href="#Process-phase" class="headerlink" title="Process phase"></a>Process phase</h4><p>COLO-FT initializes some key variables such as migration status, FAILOVER status and listens to the internal checkpoint notify (triggered from COLO compare)</p>
<p>After the first successful migrate, the discount state is initialized and the migration state is changed to COLO</p>
<p>After receiving a request for a checkpoint, a series of checkpoint creation processes are performed</p>
<h4 id="Colo-Status"><a href="#Colo-Status" class="headerlink" title="Colo Status"></a>Colo Status</h4><p>For the COLO-FT virtual machine, there are two important states</p>
<p>One is the MigrationState, which on the COLO-FT virtual machine is MIGRATION_STATUS_COLO corresponding to the string “COLO”, which is a prerequisite state to allow checkpointing, and the cloud host must have established the COLO-FT mechanism. FT mechanism, that is, through the above configuration phase to complete the configuration and the first checkpoint, will enter this state and the main loop</p>
<p>Another state is failover_state, which is a global variable defined in colo_failover.c, which is accessed by colo.c through failover_get_state(), and this parameter is set to FAILOVER_STATUS at the start of the checkpoint loop _NONE, which means that failover is not needed. The bottom half of qemu mounts the mechanism for modifying this state, so it can be triggered by user state commands, so you need to pay attention to whether failover is triggered or not when actually doing checkpoint</p>
<h4 id="Communitaion"><a href="#Communitaion" class="headerlink" title="Communitaion"></a>Communitaion</h4><p>COLO communicates through messages to get the status of the SVM, as well as to send and confirm the start and completion of the checkpoint, and the message process inside has the following main steps</p>
<ol>
<li>Sending COLO_MESSAGE_CHECKPOINT_REQUEST</li>
<li>After the SVM receives the message, pause the SVM and send COLO_MESSAGE_CHECKPOINT_READY</li>
<li>PVM starts saving and live migration of VMSTATE</li>
<li>SVM gets the migrated information and does the CPU synchronization and VM state LOAD locally.</li>
<li>SVM will wait for a check message from PVM after the migration is completed, and PVM will send a message after the live migration is completed.</li>
<li>PVM sends COLO_MESSAGE_VMSTATE_SIZE with the size of VMSTATE sent via QIOChannelBuffer</li>
<li>SVM receives the message and checks if the size received locally is the same as the size sent, if it is, it replies COLO_MESSAGE_VMSTATE_RECEIVED</li>
<li>After confirming the VMSTATE transfer, the SVM will do some migration and subsequent synchronization and cleanup.</li>
<li>After completion, the SVM executes vm_start() and sends COLO_MESSAGE_VMSTATE_LOADED.</li>
<li>After the PVM receives the message that the SVM has successfully loaded, the PVM will also execute vm_start().</li>
</ol>
<p>The logic of suspend, migrate and resume the operation of PVM SVM is realized through the message collaboration between PVM and SVM</p>
<img src="/2023/04/13/qemu-colo-details/fig4.png" class="">

<p>Existing problems, because the current checkpoint are notified to each other through the message, once the corresponding packet is sent and not returned, the next wait may always exist, can not be closed, assuming that at this time from the bottom half (bottom half) to send a request also did not do to clean up the wait state.</p>
<p>It should be noted that: the default checkpoint once the failure occurs, the vm will be a direct exit, requiring the rebuilding of COLO-FT, so the establishment of COLO-FT failure needs to be analyzed from two parts</p>
<p>Whether the configuration phase migration has failed<br>Whether the configuration is complete (migration has become colo state) but the checkpoint failed (the above process failed) resulting in COLO-FT exit</p>
<h3 id="colo-proxy"><a href="#colo-proxy" class="headerlink" title="colo proxy"></a>colo proxy</h3><p>colo proxy as the core component of COLO-FT, this article mainly focuses on the functionality of colo proxy in QEMU</p>
<p>When QEMU implements the net module, it actually treats the actual device in the guest as a receiver, so the corresponding relationship is as follows</p>
<p>TX RX</p>
<p>qemu side network device (sender) ——————-→ guest inside driver (receiver)</p>
<p>Combined with the code, the filter will be executed before actually doing transimission, and then go to sender processing.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NetQueue *queue;</span><br><span class="line">size_t size &#x3D; iov_size(iov, iovcnt);</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">if (size &gt; NET_BUFSIZE) &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (sender-&gt;link_down || !sender-&gt;peer) &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Let filters handle the packet first *&#x2F;</span><br><span class="line">ret &#x3D; filter_receive_iov(sender, NET_FILTER_DIRECTION_TX, sender,</span><br><span class="line">                         QEMU_NET_PACKET_FLAG_NONE, iov, iovcnt, sent_cb);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret &#x3D; filter_receive_iov(sender-&gt;peer, NET_FILTER_DIRECTION_RX, sender,</span><br><span class="line">                         QEMU_NET_PACKET_FLAG_NONE, iov, iovcnt, sent_cb);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &#x3D; sender-&gt;peer-&gt;incoming_queue;</span><br><span class="line"></span><br><span class="line">return qemu_net_queue_send_iov(queue, sender,</span><br><span class="line">                               QEMU_NET_PACKET_FLAG_NONE,</span><br><span class="line">                               iov, iovcnt, sent_cb);</span><br></pre></td></tr></table></figure>

<p>The filter-mirror and filter-redirect in the network-filter implemented by colo act as the forwarding function of the proxy</p>
<p>The classic process for a network card is as follows:</p>
<img src="/2023/04/13/qemu-colo-details/fig5.png" class="">

<p>The host device receives the network packet and sends it to the guest</p>
<ol>
<li>First execute the first filter-mirror, for qemu is transimission, so execute mirror action, the network packet mirror a copy sent off through outdev (chardev), and then call the next filter (because it is TX, so other filters will not be executed, so pvm on (the packet is sent directly to the guest)</li>
<li>SVM’s indev connects to PVM’s mirror’s outdev (via socket), so it receives the packet sent by 1. The filter does not specify an outdev after receiving the packet, so it calls the next filter directly</li>
<li>SVM calls filter-rewrite, the direction of this filter is ALL, so the packets to and from SVM will be processed by this filter, if the target is sent, because it is sent to VM so the first direction is TX, COLO will record the various states of this TCP packet</li>
<li>Because there is no next filter so it is sent to the qemu network device, and then take the process of sending to the guest</li>
<li>From the guest to the qemu network packet, the direction is RX so the filter processing order will be reversed and sent to the rewrite first</li>
<li>SVM calls filter-rewrite this time in the direction of RX, so when processing, it will process the tcp packets returned by SVM, compare the input and output of tcp packets through the tcp packets table, and if the processing fails, it will put the packet in the queue and resend it again (note: need to continue deeper analysis), and then the filter- redirector</li>
<li>Also in the PVM mirror filter, because there is no subsequent TX filter, the packet is sent directly to the qemu net device and then to the PVM guest.</li>
<li>The packets coming out of the PVM guest will be sent to the primary in interface of the colo-compare thing by filter-redirector because it is in the RX direction, so some filters will be performed in the reverse direction</li>
<li>SVM will send the return of SVM to the secondary in interface of colo-compare of PVM via redirector’s outdev<br>colo-compare receives the packet and starts to do the relevant analysis to decide whether checkpoint is needed</li>
<li>The filter-redirector’s indev receives the return from colo-compare after comparison and forwards it to the host net device via outdev</li>
</ol>
<p>This is the end of a complete packet processing process.</p>
<p>Since colo-compare is responsible for comparing pvm and svm packets, there are some metrics that need to be understood</p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>payload_size = total size - header_size i.e. the size of the whole packet minus the length of the header</p>
<p>packet data offset packet header size after the distance and payload_size comparison is consistent</p>
<p>The following is a summary of what needs to be done here</p>
<p>The logic of colo-compare comparison is organized:</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>Compare whether the payloads are the same. If it is the same and the ack is the same then it is over. If it is the same but the ack of pvm is larger than the ack of svm, the packet sent to svm is dropped and the packet of pvm will not be sent (meaning sent back to the host NIC). So we will record the maximum ack in the current queue (both pvm and svm queues) until the ack exceeds the smaller of the two maximum ack values, and we can ensure that the packet payload is confirmed by both sides</td>
</tr>
<tr>
<td>UDP</td>
<td>only palyload checked</td>
</tr>
<tr>
<td>ICMP</td>
<td>only palyload checked</td>
</tr>
<tr>
<td>Other</td>
<td>only packet size checked</td>
</tr>
</tbody></table>
<p>Possible reasons for network packet loss are therefore:</p>
<ol>
<li>colo-compare did not receive the packet correctly</li>
<li>svm’s redirector did not successfully forward packets to rewrite</li>
<li>mirror did not replicate the packet successfully</li>
<li>pvm’s redirector did not successfully send pvm’s return to colo-compare</li>
<li>svm’s rewrite did not send/receive packets successfully</li>
<li>colo-compare is not sending packets correctly</li>
<li>svm’s redirector did not successfully forward packets to colo-compare</li>
</ol>
<p>Problem processing</p>
<p>The processing of 1 mainly relies on the colo compare mechanism itself, for tcp packets will determine whether there are subsequent packets returned by ack, if there are subsequent packets, it means that the previous is missed</p>
<p>2 If the packet is not successfully sent to rewrite, it will not be processed by svm, so finally colo compare will encounter the situation where pvm has a packet but svm does not have a packet, and the processing is similar to 1</p>
<p>3 If mirror does not successfully copy the package, then there will also be a situation similar to 1, pvm exists package, svm no package</p>
<p>4 if pvm redirector did not successfully send the packet, then it seems from colo compare is pvm lost packets, but the same 1 processing, will wait for the pvm and svm minimum ack is exceeded, that is, both pvm or svm even if packet loss occurs, colo compare will wait for the updated packet to appear before returning the packet otherwise will always card does not reverse the current packet</p>
<p>5 If rewritte’s send-receive fails, this situation will cause the svm to not receive the packet and not return, similar to 1, but if failover occurs at this time, the svm packet is lost</p>
<p>6 this exception will lead to colo send and receive packet exceptions, network anomalies, not very well handled because itself colo compare is the core component</p>
<p>7 similar situation svm seems to have replied or actively sent the packet, but because colo compare did not receive, resulting in the svm within the data that did not reply, the benefit is that if the subsequent failover can occur, rewrite because the packet was recorded, will send the packet again, then it seems to be working again (need to test)</p>
<h3 id="Trigger-checkpoint"><a href="#Trigger-checkpoint" class="headerlink" title="Trigger checkpoint"></a>Trigger checkpoint</h3><p>There are two conditions for triggering from colo-comare, because COLO-FT will establish a notification mechanism when it is established, and colo compare will trigger checkpoint from inside actively through this mechanism</p>
<ol>
<li>Checkpoint will be triggered if the payload of the compare tcp packet is inconsistent</li>
<li>Timed to check if there is a certain period of time but has not received the same return packet (i.e., pvm, svm packet chain table content is inconsistent) trigger checkpoint</li>
<li>If there is a packet in the pvm list but not in the secondary packet, then it means that the packet reply is late, this situation is handled by 2, if the comparison finds that the non-tcp packet comparison is inconsistent will trigger a checkpoint</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/04/13/qemu-colo-details/" data-id="clgfbjhl80000e7wb9imx6mfo" data-title="Qemu Colo Details" class="article-share-link">Share</a>
      
      
        <a href="/2023/04/13/qemu-colo-details/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/04/13/qemu-colo-details/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/colo/" rel="tag">colo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ft/" rel="tag">ft</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-KVM虚拟化性能分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2023-03-13T14:36:38.000Z" itemprop="datePublished">2023-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/kvm/">kvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">KVM虚拟化性能分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>KVM虚拟化是一种常用的虚拟化技术，它可以将一台物理服务器划分为多个虚拟机，从而提高服务器的利用率和灵活性。然而，由于虚拟化带来的额外开销，KVM虚拟化的性能问题是一个常见的挑战。为了解决这些问题，我们需要使用一些性能诊断工具来分析和优化KVM虚拟化的性能。</p>
<p>以下是一些常用的KVM虚拟化性能诊断工具：</p>
<h2 id="Perf"><a href="#Perf" class="headerlink" title="Perf"></a>Perf</h2><p>Perf是一种Linux性能分析工具，可以用于监视系统性能和调试性能问题。它基于Linux内核提供的性能事件接口，并提供了一个命令行界面，可以用于监视CPU使用率、内存使用情况、磁盘I/O等性能指标。</p>
<p>以下是使用Perf进行KVM虚拟化性能分析的最佳实践：</p>
<ol>
<li>安装Perf</li>
</ol>
<p>要安装Perf，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-tools-common linux-tools-generic linux-tools-&#96;uname -r&#96;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>收集Perf数据</li>
</ol>
<p>要使用Perf收集性能数据，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -g -p &#96;pidof qemu-system-x86_64&#96; -F 99</span><br></pre></td></tr></table></figure>

<p>在这个例子中，-g选项表示收集函数调用图（用于生成Flame Graph），-p选项表示监视qemu-system-x86_64进程，-F选项表示使用99Hz的采样频率来收集性能数据。</p>
<ol start="3">
<li>生成Flame Graph</li>
</ol>
<p>要生成Flame Graph，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf script | stackcollapse-perf.pl | flamegraph.pl &gt; output.svg</span><br></pre></td></tr></table></figure>

<p>在这个例子中，perf script命令将Perf数据转换为脚本输出，stackcollapse-perf.pl命令将脚本输出转换为折叠栈，flamegraph.pl命令将折叠栈转换为Flame Graph。最终的Flame Graph将保存在output.svg文件中。</p>
<h2 id="Sysstat"><a href="#Sysstat" class="headerlink" title="Sysstat"></a>Sysstat</h2><p>Sysstat是一个Linux系统性能监控工具，可以用于监视CPU、内存、磁盘I/O等性能指标。在KVM虚拟化中，您可以使用Sysstat来监视虚拟机的性能。以下是使用Sysstat进行KVM虚拟化性能分析的最佳实践：</p>
<ol>
<li>安装Sysstat</li>
</ol>
<p>要安装Sysstat，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install sysstat</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置Sysstat</li>
</ol>
<p>要配置Sysstat，请编辑/etc/default/sysstat文件，并更改以下变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HISTORY&#x3D;7</span><br><span class="line">INTERVAL&#x3D;60</span><br></pre></td></tr></table></figure>

<p>在这个例子中，Sysstat将每1分钟收集一次性能数据，并将数据保存最近7天。</p>
<ol start="3">
<li>分析Sysstat数据</li>
</ol>
<p>Sysstat收集的数据保存在/var/log/sysstat目录下。您可以使用以下命令来查看Sysstat数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sar -u</span><br><span class="line">sar -r</span><br><span class="line">sar -b</span><br><span class="line">sar -d</span><br></pre></td></tr></table></figure>

<p>这些命令将分别显示CPU使用率、内存使用情况、磁盘I/O等性能数据。</p>
<ol start="4">
<li>使用Sysstat报告</li>
</ol>
<p>Sysstat还提供了一个报告生成工具，可以根据Sysstat数据生成报告。要生成报告，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sar -A -o &lt;outfile&gt;</span><br><span class="line">sadf -dh &lt;outfile&gt; &gt; &lt;reportfile&gt;</span><br></pre></td></tr></table></figure>

<p>这将生成一个包含所有性能数据的输出文件<outfile>，然后使用sadf命令将输出文件转换为HTML格式的报告文件<reportfile>。</p>
<p>希望这些最佳实践可以帮助您更好地使用Sysstat进行KVM虚拟化性能分析。</p>
<p>如果您希望通过Sysstat数据进行趋势分析，可以使用一个名为<code>ksar</code>的工具。</p>
<p><code>ksar</code>是一个Java应用程序，可以将Sysstat数据转换为图表，从而更方便地进行趋势分析。</p>
<p>要使用<code>ksar</code>，请按照以下步骤操作：</p>
<ol>
<li>安装Java</li>
</ol>
<p><code>ksar</code>是一个Java应用程序，因此您需要安装Java才能运行它。您可以从Oracle官方网站下载Java。</p>
<ol start="2">
<li>下载和安装<code>ksar</code></li>
</ol>
<p>您可以从<code>ksar</code>的官方网站下载最新的版本。下载完成后，将压缩文件解压缩到您选择的目录中。</p>
<ol start="3">
<li>运行<code>ksar</code></li>
</ol>
<p>要运行<code>ksar</code>，请打开终端并导航到<code>ksar</code>目录。然后，运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ksar.jar</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>加载Sysstat数据文件</li>
</ol>
<p>在<code>ksar</code>窗口中，单击“File”菜单，然后选择“Open”选项。选择您要加载的Sysstat数据文件。</p>
<ol start="5">
<li>生成图表</li>
</ol>
<p>在<code>ksar</code>窗口中，单击“Graphs”菜单，然后选择要生成的图表类型。<code>ksar</code>将生成一个图表，显示Sysstat数据的趋势。</p>
<p>如果您在KVM虚拟化中遇到了网络性能问题，可以使用以下工具来进行诊断：</p>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>tcpdump是一种常用的网络抓包工具。在KVM虚拟化中，您可以在宿主机上使用tcpdump来监视虚拟机的网络流量。以下是一个示例命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i &lt;interface&gt; -w &lt;output-file&gt;</span><br></pre></td></tr></table></figure>

<p>在这个命令中，<interface>是您要监视的网络接口，<output-file>是保存抓包数据的输出文件。运行此命令后，tcpdump将开始监视指定的网络接口上的流量，并将所有数据保存到输出文件中。</p>
<h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p>Wireshark是一种网络协议分析工具，可以用于分析网络流量。在KVM虚拟化中，您可以在宿主机上使用Wireshark来分析虚拟机的网络流量。以下是一个示例命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tshark -i &lt;interface&gt; -w &lt;output-file&gt;</span><br></pre></td></tr></table></figure>

<h2 id="virt-top"><a href="#virt-top" class="headerlink" title="virt-top"></a>virt-top</h2><p>一个整合KVM虚拟化性能诊断工具的项目是<code>virt-top</code>。<code>virt-top</code>是一个基于ncurses的交互式监视器，可以用于监视KVM虚拟机的性能。以下是使用<code>virt-top</code>进行KVM虚拟化性能分析的最佳实践：</p>
<ol>
<li>安装<code>virt-top</code></li>
</ol>
<p>要安装<code>virt-top</code>，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install virt-top</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行<code>virt-top</code></li>
</ol>
<p>要运行<code>virt-top</code>，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virt-top</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>监视虚拟机性能</li>
</ol>
<p>在<code>virt-top</code>窗口中，您可以使用上下方向键选择要监视的虚拟机。然后，您可以查看虚拟机的CPU使用率、内存使用情况、磁盘I/O等性能指标。</p>
<p>希望这些最佳实践可以帮助您更好地使用KVM虚拟化性能诊断工具。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" data-id="clf6xlaht0000cqwbf3o8cy3v" data-title="KVM虚拟化性能分析" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kvm/" rel="tag">kvm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/performance/" rel="tag">performance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sysstat/" rel="tag">sysstat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virt-top/" rel="tag">virt-top</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cpu-features-about-kvm-hidden" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/09/cpu-features-about-kvm-hidden/" class="article-date">
  <time class="dt-published" datetime="2023-03-09T13:48:22.000Z" itemprop="datePublished">2023-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/kvm/">kvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/09/cpu-features-about-kvm-hidden/">Cpu features about kvm hidden</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="What-kvm-hidden-did-to-qemu"><a href="#What-kvm-hidden-did-to-qemu" class="headerlink" title="What kvm hidden did to qemu"></a>What kvm hidden did to qemu</h2><p>Based on last blog, we can see how libvirt cpu feature configuration changes qemu cpuid. And we figure out hypervisor disable configuration have what kind of influence.</p>
<p>Then another recommanded feature from libvirt is kvm hidden. In the same way with last blog, we can find libvirt will configure <code>kvm=off</code> to <code>-cpu</code> and according to qemu:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-relaxed&quot;</span>, X86CPU, hyperv_relaxed_timing, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-vapic&quot;</span>, X86CPU, hyperv_vapic, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-time&quot;</span>, X86CPU, hyperv_time, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-crash&quot;</span>, X86CPU, hyperv_crash, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-reset&quot;</span>, X86CPU, hyperv_reset, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-vpindex&quot;</span>, X86CPU, hyperv_vpindex, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-runtime&quot;</span>, X86CPU, hyperv_runtime, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-synic&quot;</span>, X86CPU, hyperv_synic, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-stimer&quot;</span>, X86CPU, hyperv_stimer, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-frequencies&quot;</span>, X86CPU, hyperv_frequencies, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;check&quot;</span>, X86CPU, check_cpuid, <span class="literal">true</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;enforce&quot;</span>, X86CPU, enforce_cpuid, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;kvm&quot;</span>, X86CPU, expose_kvm, <span class="literal">true</span>),</span><br></pre></td></tr></table></figure>

<p>those configures are defined by <code>target/i386/cpu.c</code> in variable <code>x86_cpu_properties</code>.</p>
<p><code>kvm=off</code> will be treated as “kvm” is false and the local variable of this cpu changes <code>expose_kvm</code> to false.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x86_cpu_realizefn</code> will invoke <code>x86_cpu_expand_features</code> to expand features from configuration, as a result FEAT_KVM will disable all features after realize features.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[FEAT_KVM] = &#123;</span><br><span class="line">    .feat_names = &#123;</span><br><span class="line">        <span class="string">&quot;kvmclock&quot;</span>, <span class="string">&quot;kvm-nopiodelay&quot;</span>, <span class="string">&quot;kvm-mmu&quot;</span>, <span class="string">&quot;kvmclock&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kvm-asyncpf&quot;</span>, <span class="string">&quot;kvm-steal-time&quot;</span>, <span class="string">&quot;kvm-pv-eoi&quot;</span>, <span class="string">&quot;kvm-pv-unhalt&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">&quot;kvm-pv-tlb-flush&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="string">&quot;kvmclock-stable-bit&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .cpuid_eax = KVM_CPUID_FEATURES, .cpuid_reg = R_EAX,</span><br><span class="line">    .tcg_features = TCG_KVM_FEATURES,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>check its definition, almost all kvm related features is disabled.</p>
<p>Then go ahead to linux kernel <code>arch/x86/include/uapi/asm/kvm_para.h</code> defines those features from cpuid:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This CPUID returns a feature bitmap in eax.  Before enabling a particular</span></span><br><span class="line"><span class="comment"> * paravirtualization, the appropriate feature bit should be checked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_CPUID_FEATURES	0x40000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_NOP_IO_DELAY	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_MMU_OP		2</span></span><br><span class="line"><span class="comment">/* This indicates that the new set of kvmclock msrs</span></span><br><span class="line"><span class="comment"> * are available. The use of 0x11 and 0x12 is deprecated</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE2        3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_ASYNC_PF		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_STEAL_TIME		5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_PV_EOI		6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_PV_UNHALT		7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The last 8 bits are used to indicate how to interpret the flags field</span></span><br><span class="line"><span class="comment"> * in pvclock structure. If no bits are set, all flags are ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE_STABLE_BIT	24</span></span><br></pre></td></tr></table></figure>

<p>And before we check all features details let’s check how linux figure kvm feature at first.</p>
<p>For kernel, check kvm by <code>kvm_para_available</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kvm_para_available</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> kvm_cpuid_base() != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which will return a kvm based hypervisor by check <code>cpu_has_hypervisor</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> noinline <span class="keyword">uint32_t</span> __kvm_cpuid_base(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (boot_cpu_data.cpuid_level &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">/* So we don&#x27;t blow up on old processors */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu_has_hypervisor)</span><br><span class="line">		<span class="keyword">return</span> hypervisor_cpuid_base(<span class="string">&quot;KVMKVMKVM\0\0\0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and <code>cpu_has_hypervisor</code>  is defined from the hypervisor feature we mentioned in last post:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_has_hypervisor	boot_cpu_has(X86_FEATURE_HYPERVISOR)</span></span><br></pre></td></tr></table></figure>

<p>So we combine those two part together to check the influence introduced by kvm hidden.</p>
<p>Note: here is the brief description about those features in cpuid:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function: define KVM_CPUID_FEATURES (0x40000001)</span><br><span class="line">returns : ebx, ecx, edx = 0</span><br><span class="line">          eax = and OR&#x27;ed group of (1 &lt;&lt; flag), where each flags is:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag                               || value || meaning</span><br><span class="line">=============================================================================</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE            ||     0 || kvmclock available at msrs</span><br><span class="line">                                   ||       || 0x11 and 0x12.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_NOP_IO_DELAY           ||     1 || not necessary to perform delays</span><br><span class="line">                                   ||       || on PIO operations.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_MMU_OP                 ||     2 || deprecated.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE2           ||     3 || kvmclock available at msrs</span><br><span class="line">                                   ||       || 0x4b564d00 and 0x4b564d01</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_ASYNC_PF               ||     4 || async pf can be enabled by</span><br><span class="line">                                   ||       || writing to msr 0x4b564d02</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_STEAL_TIME             ||     5 || steal time can be enabled by</span><br><span class="line">                                   ||       || writing to msr 0x4b564d03.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_PV_EOI                 ||     6 || paravirtualized end of interrupt</span><br><span class="line">                                   ||       || handler can be enabled by writing</span><br><span class="line">                                   ||       || to msr 0x4b564d04.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_PV_UNHALT              ||     7 || guest checks this feature bit</span><br><span class="line">                                   ||       || before enabling paravirtualized</span><br><span class="line">                                   ||       || spinlock support.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE_STABLE_BIT ||    24 || host will warn if no guest-side</span><br><span class="line">                                   ||       || per-cpu warps are expected in</span><br><span class="line">                                   ||       || kvmclock.</span><br><span class="line">------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-CLOCKSOURCE-amp-KVM-FEATURE-CLOCKSOURCE2"><a href="#KVM-FEATURE-CLOCKSOURCE-amp-KVM-FEATURE-CLOCKSOURCE2" class="headerlink" title="KVM_FEATURE_CLOCKSOURCE &amp; KVM_FEATURE_CLOCKSOURCE2"></a>KVM_FEATURE_CLOCKSOURCE &amp; KVM_FEATURE_CLOCKSOURCE2</h3><p>This feature is used directly when implement <code>kvmclock_init</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvmclock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pvclock_vcpu_time_info</span> *<span class="title">vcpu_time</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mem, mem_wall_clock;</span><br><span class="line">	<span class="keyword">int</span> size, cpu, wall_clock_size;</span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	size = PAGE_ALIGN(<span class="keyword">sizeof</span>(struct pvclock_vsyscall_time_info)*NR_CPUS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvmclock &amp;&amp; kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) &#123;</span><br><span class="line">		msr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;</span><br><span class="line">		msr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(kvmclock &amp;&amp; kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-NOP-IO-DELAY"><a href="#KVM-FEATURE-NOP-IO-DELAY" class="headerlink" title="KVM_FEATURE_NOP_IO_DELAY"></a>KVM_FEATURE_NOP_IO_DELAY</h3><p>During guest init, paravirt_ops_setup will use this feature:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_guest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	paravirt_ops_setup();</span><br></pre></td></tr></table></figure>

<p>which changes <code>io_delay</code> of paravirt cpu ops to <code>kvm_io_delay</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">paravirt_ops_setup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pv_info.name = <span class="string">&quot;KVM&quot;</span>;</span><br><span class="line">	pv_info.paravirt_enabled = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_NOP_IO_DELAY))</span><br><span class="line">		pv_cpu_ops.io_delay = kvm_io_delay;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_IO_APIC</span></span><br><span class="line">	no_timer_check = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which just means without any io delay:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * No need for any &quot;IO delay&quot; on KVM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_io_delay</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-MMU-OP"><a href="#KVM-FEATURE-MMU-OP" class="headerlink" title="KVM_FEATURE_MMU_OP"></a>KVM_FEATURE_MMU_OP</h3><p>Deprecated.</p>
<h3 id="KVM-FEATURE-ASYNC-PF"><a href="#KVM-FEATURE-ASYNC-PF" class="headerlink" title="KVM_FEATURE_ASYNC_PF"></a>KVM_FEATURE_ASYNC_PF</h3><p>When init kvm guest:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_guest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF))</span><br><span class="line">		x86_init.irqs.trap_init = kvm_apf_trap_init;</span><br></pre></td></tr></table></figure>

<p><code>kvm_apf_trap_init</code> will be set to <code>x86_init.irqs.trap_init</code> which will set <code>async_page_fault</code> when interrupt request for trap operations:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">kvm_apf_trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_intr_gate(<span class="number">14</span>, async_page_fault);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then when init kvm guest cpu, will manually enable cpu to allow to write async page fault:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_guest_cpu_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF) &amp;&amp; kvmapf) &#123;</span><br><span class="line">		u64 pa = slow_virt_to_phys(this_cpu_ptr(&amp;apf_reason));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">		pa |= KVM_ASYNC_PF_SEND_ALWAYS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		wrmsrl(MSR_KVM_ASYNC_PF_EN, pa | KVM_ASYNC_PF_ENABLED);</span><br><span class="line">		__this_cpu_write(apf_reason.enabled, <span class="number">1</span>);</span><br><span class="line">		printk(KERN_INFO<span class="string">&quot;KVM setup async PF for cpu %d\n&quot;</span>,</span><br><span class="line">		       smp_processor_id());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Then feature will enable async PF for this cpu.</p>
<p>Note: trap initialize will be done by <code>arch/x86/kernel/traps.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EISA</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *p = early_ioremap(<span class="number">0x0FFFD9</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (readl(p) == <span class="string">&#x27;E&#x27;</span> + (<span class="string">&#x27;I&#x27;</span>&lt;&lt;<span class="number">8</span>) + (<span class="string">&#x27;S&#x27;</span>&lt;&lt;<span class="number">16</span>) + (<span class="string">&#x27;A&#x27;</span>&lt;&lt;<span class="number">24</span>))</span><br><span class="line">		EISA_bus = <span class="number">1</span>;</span><br><span class="line">	early_iounmap(p, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	set_intr_gate(X86_TRAP_DE, divide_error);</span><br><span class="line">	set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);</span><br><span class="line">	<span class="comment">/* int4 can be called from all */</span></span><br><span class="line">	set_system_intr_gate(X86_TRAP_OF, &amp;overflow);</span><br><span class="line">	set_intr_gate(X86_TRAP_BR, bounds);</span><br><span class="line">	set_intr_gate(X86_TRAP_UD, invalid_op);</span><br><span class="line">	set_intr_gate(X86_TRAP_NM, device_not_available);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	set_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);</span><br><span class="line">	set_intr_gate(X86_TRAP_TS, invalid_TSS);</span><br><span class="line">	set_intr_gate(X86_TRAP_NP, segment_not_present);</span><br><span class="line">	set_intr_gate(X86_TRAP_SS, stack_segment);</span><br><span class="line">	set_intr_gate(X86_TRAP_GP, general_protection);</span><br><span class="line">	set_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);</span><br><span class="line">	set_intr_gate(X86_TRAP_MF, coprocessor_error);</span><br><span class="line">	set_intr_gate(X86_TRAP_AC, alignment_check);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_MCE</span></span><br><span class="line">	set_intr_gate_ist(X86_TRAP_MC, &amp;machine_check, MCE_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_intr_gate(X86_TRAP_XF, simd_coprocessor_error);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reserve all the builtin and the syscall vector: */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FIRST_EXTERNAL_VECTOR; i++)</span><br><span class="line">		set_bit(i, used_vectors);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IA32_EMULATION</span></span><br><span class="line">	set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);</span><br><span class="line">	set_bit(IA32_SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</span><br><span class="line">	set_bit(SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set the IDT descriptor to a fixed read-only location, so that the</span></span><br><span class="line"><span class="comment">	 * &quot;sidt&quot; instruction will not leak the location of the kernel, and</span></span><br><span class="line"><span class="comment">	 * to defend the IDT against arbitrary memory write vulnerabilities.</span></span><br><span class="line"><span class="comment">	 * It will be reloaded in cpu_init() */</span></span><br><span class="line">	__set_fixmap(FIX_RO_IDT, __pa_symbol(idt_table), PAGE_KERNEL_RO);</span><br><span class="line">	idt_descr.address = fix_to_virt(FIX_RO_IDT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Should be a barrier for any external CPU state:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu_init();</span><br><span class="line"></span><br><span class="line">	x86_init.irqs.trap_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;debug_idt_table, &amp;idt_table, IDT_ENTRIES * <span class="number">16</span>);</span><br><span class="line">	set_nmi_gate(X86_TRAP_DB, &amp;debug);</span><br><span class="line">	set_nmi_gate(X86_TRAP_BP, &amp;int3);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and <code>x86_init.irqs.trap_init();</code> will be used post other features.    </p>
<h3 id="KVM-FEATURE-STEAL-TIME"><a href="#KVM-FEATURE-STEAL-TIME" class="headerlink" title="KVM_FEATURE_STEAL_TIME"></a>KVM_FEATURE_STEAL_TIME</h3><p>when do kvm guest init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) &#123;</span><br><span class="line">	has_steal_clock = <span class="number">1</span>;</span><br><span class="line">	pv_time_ops.steal_clock = kvm_steal_clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Paravirt steal lock will be replaced by kvm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">kvm_steal_clock</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 steal;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_steal_time</span> *<span class="title">src</span>;</span></span><br><span class="line">	<span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">	src = &amp;per_cpu(steal_time, cpu);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		version = src-&gt;version;</span><br><span class="line">		rmb();</span><br><span class="line">		steal = src-&gt;steal;</span><br><span class="line">		rmb();</span><br><span class="line">	&#125; <span class="keyword">while</span> ((version &amp; <span class="number">1</span>) || (version != src-&gt;version));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> steal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which will steal the time from cpu directly.</p>
<h3 id="KVM-FEATURE-PV-EOI"><a href="#KVM-FEATURE-PV-EOI" class="headerlink" title="KVM_FEATURE_PV_EOI"></a>KVM_FEATURE_PV_EOI</h3><p>From kvm guest init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">	apic_set_eoi_write(kvm_guest_apic_eoi_write);</span><br></pre></td></tr></table></figure>

<p>During kvm guest cpu init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI)) &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pa;</span><br><span class="line">	<span class="comment">/* Size alignment is implied but just to make it explicit. */</span></span><br><span class="line">	BUILD_BUG_ON(__alignof__(kvm_apic_eoi) &lt; <span class="number">4</span>);</span><br><span class="line">	__this_cpu_write(kvm_apic_eoi, <span class="number">0</span>);</span><br><span class="line">	pa = slow_virt_to_phys(this_cpu_ptr(&amp;kvm_apic_eoi))</span><br><span class="line">		| KVM_MSR_ENABLED;</span><br><span class="line">	wrmsrl(MSR_KVM_PV_EOI_EN, pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Besides, those paravirt kvm features is used by kernel so those features need to be disabled if kernel changed, for example, load kernel by kexec, to avoid the features pointing to old memory of old kernel, those features will disabled by write msr manually:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_pv_guest_cpu_reboot</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We disable PV EOI before we load a new kernel by kexec,</span></span><br><span class="line"><span class="comment">	 * since MSR_KVM_PV_EOI_EN stores a pointer into old kernel&#x27;s memory.</span></span><br><span class="line"><span class="comment">	 * New kernel can re-enable when it boots.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">		wrmsrl(MSR_KVM_PV_EOI_EN, <span class="number">0</span>);</span><br><span class="line">	kvm_pv_disable_apf();</span><br><span class="line">	kvm_disable_steal_time();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So does kvm guest cpu offline do:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_guest_cpu_offline</span><span class="params">(<span class="keyword">void</span> *dummy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	kvm_disable_steal_time();</span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">		wrmsrl(MSR_KVM_PV_EOI_EN, <span class="number">0</span>);</span><br><span class="line">	kvm_pv_disable_apf();</span><br><span class="line">	apf_task_wake_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s all due to paravirt use shared memory to use those features between guest and host.</p>
<h3 id="KVM-FEATURE-PV-UNHALT"><a href="#KVM-FEATURE-PV-UNHALT" class="headerlink" title="KVM_FEATURE_PV_UNHALT"></a>KVM_FEATURE_PV_UNHALT</h3><p>Allow to use para-virtualized spinlock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_spinlock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/* Does host kernel support KVM_FEATURE_PV_UNHALT? */</span></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_has_feature(KVM_FEATURE_PV_UNHALT))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-CLOCKSOURCE-STABLE-BIT"><a href="#KVM-FEATURE-CLOCKSOURCE-STABLE-BIT" class="headerlink" title="KVM_FEATURE_CLOCKSOURCE_STABLE_BIT"></a>KVM_FEATURE_CLOCKSOURCE_STABLE_BIT</h3><p>kvm clock will set a <code>PVCLOCK_TSC_STABLE_BIT</code> to pvclock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_INFO <span class="string">&quot;kvm-clock: Using msrs %x and %x&quot;</span>,</span><br><span class="line">       msr_kvm_system_time, msr_kvm_wall_clock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))</span><br><span class="line">	pvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);</span><br></pre></td></tr></table></figure>

<p>when stable source detected:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u64 <span class="title">pvclock_clocksource_read</span><span class="params">(struct pvclock_vcpu_time_info *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> version;</span><br><span class="line">	u64 ret;</span><br><span class="line">	u64 last;</span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		version = pvclock_read_begin(src);</span><br><span class="line">		ret = __pvclock_read_cycles(src, rdtsc_ordered());</span><br><span class="line">		flags = src-&gt;flags;</span><br><span class="line">	&#125; <span class="keyword">while</span> (pvclock_read_retry(src, version));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely((flags &amp; PVCLOCK_GUEST_STOPPED) != <span class="number">0</span>)) &#123;</span><br><span class="line">		src-&gt;flags &amp;= ~PVCLOCK_GUEST_STOPPED;</span><br><span class="line">		pvclock_touch_watchdogs();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((valid_flags &amp; PVCLOCK_TSC_STABLE_BIT) &amp;&amp;</span><br><span class="line">		(flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>

<p>clocksource read will return directly.</p>
<h4 id="Hyper-v-impact"><a href="#Hyper-v-impact" class="headerlink" title="Hyper-v impact"></a>Hyper-v impact</h4><p>linux will converting hyperv and kvmclock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compute_tsc_page_parameters</span><span class="params">(struct pvclock_vcpu_time_info *hv_clock,</span></span></span><br><span class="line"><span class="function"><span class="params">					HV_REFERENCE_TSC_PAGE *tsc_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 max_mul;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(hv_clock-&gt;flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>but if no stable tsc allowed, hypervclock and kvmclock computing will be skipped.</p>
<p>Function chain as following:</p>
<p><code>kvm_guest_time_update</code> -&gt; <code>kvm_hv_setup_tsc_page</code> -&gt; <code>compute_tsc_page_parameters</code></p>
<p>And source is from kvm request:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) &#123;</span><br><span class="line">	r = kvm_guest_time_update(vcpu);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(r))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to know more about <code>KVM_REQ_CLOCK_UPDATE</code> to figure out when. this request will be used.</p>
<p>The clue is <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code> make request usage.</p>
<ul>
<li><p>Ioctl kvm clock set -&gt; <code>KVM_SET_CLOCK</code> -&gt;  <code>kvm_gen_update_masterclock</code> </p>
</li>
<li><p><code>kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu)</code> -&gt;  <code>kvm_gen_update_masterclock</code> </p>
</li>
<li><p><code>kvm_guest_time_update</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code><br>first update is from kvm request:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) &#123;</span><br><span class="line">	r = kvm_guest_time_update(vcpu);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(r))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>then interrupt will be disabled to prevent clock changes:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keep irq disabled to prevent changes to the clock */</span></span><br><span class="line">local_irq_save(flags);</span><br><span class="line">this_tsc_khz = __this_cpu_read(cpu_tsc_khz);</span><br><span class="line"><span class="keyword">if</span> (unlikely(this_tsc_khz == <span class="number">0</span>)) &#123;</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>INIT_DELAYED_WORK(&amp;kvm-&gt;arch.kvmclock_update_work, kvmclock_update_fn);</code> -&gt; <code>kvmclock_update_fn</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code><br>kvm lock will be updated by a schedule:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kvmclock updates which are isolated to a given vcpu, such as</span></span><br><span class="line"><span class="comment"> * vcpu-&gt;cpu migration, should not allow system_timestamp from</span></span><br><span class="line"><span class="comment"> * the rest of the vcpus to remain static. Otherwise ntp frequency</span></span><br><span class="line"><span class="comment"> * correction applies to one vcpu&#x27;s system_timestamp but not</span></span><br><span class="line"><span class="comment"> * the others.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So in those cases, request a kvmclock update for all vcpus.</span></span><br><span class="line"><span class="comment"> * We need to rate-limit these requests though, as they can</span></span><br><span class="line"><span class="comment"> * considerably slow guests that have a large number of vcpus.</span></span><br><span class="line"><span class="comment"> * The time for a remote vcpu to update its kvmclock is bound</span></span><br><span class="line"><span class="comment"> * by the delay we use to rate-limit the updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)</span></span><br></pre></td></tr></table></figure>

<p>and kvmlock sync delays are</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVMCLOCK_SYNC_PERIOD (300 * HZ)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu)</code> -&gt;  <code>kvm_gen_kvmclock_update</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code></p>
<ul>
<li><p>MSR_KVM_SYSTEM_TIME</p>
</li>
<li><p>kvm_arch_vcpu_load<br>update clock if no master clock or host cpu to sync.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On a host with synchronized TSC, there is no need to update</span></span><br><span class="line"><span class="comment"> * kvmclock on vcpu-&gt;cpu migration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!vcpu-&gt;kvm-&gt;arch.use_master_clock || vcpu-&gt;cpu == <span class="number">-1</span>)</span><br><span class="line">	kvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);</span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;cpu != cpu)</span><br><span class="line">	kvm_migrate_timers(vcpu);</span><br><span class="line">vcpu-&gt;cpu = cpu;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>kvm_arch_vcpu_load</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>Adjust time if needed</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Apply any externally detected TSC adjustments (due to suspend) */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(vcpu-&gt;arch.tsc_offset_adjustment)) &#123;</span><br><span class="line">	adjust_tsc_offset_host(vcpu, vcpu-&gt;arch.tsc_offset_adjustment);</span><br><span class="line">	vcpu-&gt;arch.tsc_offset_adjustment = <span class="number">0</span>;</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvm_set_guest_paused</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>if guest kernel stopped by hypervisor use this to update pv clock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kvm_set_guest_paused() indicates to the guest kernel that it has been</span></span><br><span class="line"><span class="comment"> * stopped by the hypervisor.  This function will be called from the host only.</span></span><br><span class="line"><span class="comment"> * EINVAL is returned when the host attempts to set the flag for a guest that</span></span><br><span class="line"><span class="comment"> * does not support pv clocks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kvm_set_guest_paused</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!vcpu-&gt;arch.pv_time_enabled)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	vcpu-&gt;arch.pvclock_set_guest_stopped_request = <span class="literal">true</span>;</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvmclock_cpufreq_notifier</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>see the annotation from code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We allow guests to temporarily run on slowing clocks,</span></span><br><span class="line"><span class="comment"> * provided we notify them after, or to run on accelerating</span></span><br><span class="line"><span class="comment"> * clocks, provided we notify them before.  Thus time never</span></span><br><span class="line"><span class="comment"> * goes backwards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, we have a problem.  We can&#x27;t atomically update</span></span><br><span class="line"><span class="comment"> * the frequency of a given CPU from this function; it is</span></span><br><span class="line"><span class="comment"> * merely a notifier, which can be called from any CPU.</span></span><br><span class="line"><span class="comment"> * Changing the TSC frequency at arbitrary points in time</span></span><br><span class="line"><span class="comment"> * requires a recomputation of local variables related to</span></span><br><span class="line"><span class="comment"> * the TSC for each VCPU.  We must flag these local variables</span></span><br><span class="line"><span class="comment"> * to be updated and be sure the update takes place with the</span></span><br><span class="line"><span class="comment"> * new frequency before any guests proceed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unfortunately, the combination of hotplug CPU and frequency</span></span><br><span class="line"><span class="comment"> * change creates an intractable locking scenario; the order</span></span><br><span class="line"><span class="comment"> * of when these callouts happen is undefined with respect to</span></span><br><span class="line"><span class="comment"> * CPU hotplug, and they can race with each other.  As such,</span></span><br><span class="line"><span class="comment"> * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is</span></span><br><span class="line"><span class="comment"> * undefined; you can actually have a CPU frequency change take</span></span><br><span class="line"><span class="comment"> * place in between the computation of X and the setting of the</span></span><br><span class="line"><span class="comment"> * variable.  To protect against this problem, all updates of</span></span><br><span class="line"><span class="comment"> * the per_cpu tsc_khz variable are done in an interrupt</span></span><br><span class="line"><span class="comment"> * protected IPI, and all callers wishing to update the value</span></span><br><span class="line"><span class="comment"> * must wait for a synchronous IPI to complete (which is trivial</span></span><br><span class="line"><span class="comment"> * if the caller is on the CPU already).  This establishes the</span></span><br><span class="line"><span class="comment"> * necessary total order on variable updates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that because a guest time update may take place</span></span><br><span class="line"><span class="comment"> * anytime after the setting of the VCPU&#x27;s request bit, the</span></span><br><span class="line"><span class="comment"> * correct TSC value must be set before the request.  However,</span></span><br><span class="line"><span class="comment"> * to ensure the update actually makes it to any guest which</span></span><br><span class="line"><span class="comment"> * starts running in hardware virtualization between the set</span></span><br><span class="line"><span class="comment"> * and the acquisition of the spinlock, we must also ping the</span></span><br><span class="line"><span class="comment"> * CPU after setting the request bit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>after <code>kvm_guest_exit();</code><br>update clock if vcpu request clock always up to date.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(vcpu-&gt;arch.tsc_always_catchup))</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hardware_enable_nolock</code> -&gt; <code>kvm_arch_hardware_enable</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>multi functino access hardware_enable_nolock</p>
<ul>
<li><code>kvm_cpu_hotplug</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kvm_cpu_hotplug</span><span class="params">(struct notifier_block *notifier, <span class="keyword">unsigned</span> <span class="keyword">long</span> val,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	val &amp;= ~CPU_TASKS_FROZEN;</span><br><span class="line">	<span class="keyword">switch</span> (val) &#123;</span><br><span class="line">	<span class="keyword">case</span> CPU_DYING:</span><br><span class="line">		hardware_disable();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CPU_STARTING:</span><br><span class="line">		hardware_enable();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kvm_resume</code> </li>
</ul>
</li>
</ul>
<p>Note: for <code>hv_stimer</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * KVM_REQ_HV_STIMER has to be processed after</span></span><br><span class="line"><span class="comment"> * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers</span></span><br><span class="line"><span class="comment"> * depend on the guest clock being up-to-date</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))</span><br><span class="line">	kvm_hv_process_stimers(vcpu);</span><br></pre></td></tr></table></figure>

<p>will be done after guest clock up-to-date.</p>
<h4 id="Hyper-v-impact-conclusion"><a href="#Hyper-v-impact-conclusion" class="headerlink" title="Hyper-v impact conclusion"></a>Hyper-v impact conclusion</h4><p>With kvm hidden, hyper-v tsc compute will be skipped:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compute_tsc_page_parameters</span><span class="params">(struct pvclock_vcpu_time_info *hv_clock,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct ms_hyperv_tsc_page *tsc_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 max_mul;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(hv_clock-&gt;flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>which can be triggered by above kvm code.</p>
<p>During migration, we know that guest will be stopped (paused) by <code>KVM_KVMCLOCK_CTRL</code> and we could check kvm userspace’s (qemu) usage:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvmclock_vm_state_change</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> running,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     RunState state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KVMClockState *s = opaque;</span><br><span class="line">    CPUState *cpu;</span><br><span class="line">    <span class="keyword">int</span> cap_clock_ctrl = kvm_check_extension(kvm_state, KVM_CAP_KVMCLOCK_CTRL);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">data</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the host where s-&gt;clock was read did not support reliable</span></span><br><span class="line"><span class="comment">         * KVM_GET_CLOCK, read kvmclock value from memory.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;clock_is_reliable) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> pvclock_via_mem = kvmclock_current_nsec(s);</span><br><span class="line">            <span class="comment">/* We can&#x27;t rely on the saved clock value, just discard it */</span></span><br><span class="line">            <span class="keyword">if</span> (pvclock_via_mem) &#123;</span><br><span class="line">                s-&gt;clock = pvclock_via_mem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s-&gt;clock_valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        data.clock = s-&gt;clock;</span><br><span class="line">        ret = kvm_vm_ioctl(kvm_state, KVM_SET_CLOCK, &amp;data);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;KVM_SET_CLOCK failed: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cap_clock_ctrl) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CPU_FOREACH(cpu) &#123;</span><br><span class="line">            run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;clock_valid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s-&gt;runstate_paused = runstate_check(RUN_STATE_PAUSED);</span><br><span class="line"></span><br><span class="line">        kvm_synchronize_all_tsc();</span><br><span class="line"></span><br><span class="line">        kvm_update_clock(s);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the VM is stopped, declare the clock state valid to</span></span><br><span class="line"><span class="comment">         * avoid re-reading it on next vmsave (which would return</span></span><br><span class="line"><span class="comment">         * a different value). Will be reset when the VM is continued.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s-&gt;clock_valid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>when set guest to running, qemu will use <code>KVM_SET_CLOCK</code> else will use <code>kvm_update_clock</code>  works as following:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_update_clock</span><span class="params">(KVMClockState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &amp;data);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;KVM_GET_CLOCK failed: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;clock = data.clock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If kvm_has_adjust_clock_stable() is false, KVM_GET_CLOCK returns</span></span><br><span class="line"><span class="comment">     * essentially CLOCK_MONOTONIC plus a guest-specific adjustment.  This</span></span><br><span class="line"><span class="comment">     * can drift from the TSC-based value that is computed by the guest,</span></span><br><span class="line"><span class="comment">     * so we need to go through kvmclock_current_nsec().  If</span></span><br><span class="line"><span class="comment">     * kvm_has_adjust_clock_stable() is true, and the flags contain</span></span><br><span class="line"><span class="comment">     * KVM_CLOCK_TSC_STABLE, then KVM_GET_CLOCK returns a TSC-based value</span></span><br><span class="line"><span class="comment">     * and kvmclock_current_nsec() is not necessary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here, however, we need not check KVM_CLOCK_TSC_STABLE.  This is because:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if the host has disabled the kvmclock master clock, the guest already</span></span><br><span class="line"><span class="comment">     *   has protection against time going backwards.  This &quot;safety net&quot; is only</span></span><br><span class="line"><span class="comment">     *   absent when kvmclock is stable;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - therefore, we can replace a check like</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if last KVM_GET_CLOCK was not reliable then</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   with</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if last KVM_GET_CLOCK was not reliable &amp;&amp; masterclock is enabled</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * However:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if kvm_has_adjust_clock_stable() returns false, the left side is</span></span><br><span class="line"><span class="comment">     *   always true (KVM_GET_CLOCK is never reliable), and the right side is</span></span><br><span class="line"><span class="comment">     *   unknown (because we don&#x27;t have data.flags).  We must assume it&#x27;s true</span></span><br><span class="line"><span class="comment">     *   and read from memory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if kvm_has_adjust_clock_stable() returns true, the result of the &amp;&amp;</span></span><br><span class="line"><span class="comment">     *   is always false (masterclock is enabled iff KVM_GET_CLOCK is reliable)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So we can just use this instead:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if !kvm_has_adjust_clock_stable() then</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s-&gt;clock_is_reliable = kvm_has_adjust_clock_stable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But from the annotation in <code>kvmclock_vm_state_change</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the VM is stopped, declare the clock state valid to</span></span><br><span class="line"><span class="comment"> * avoid re-reading it on next vmsave (which would return</span></span><br><span class="line"><span class="comment"> * a different value). Will be reset when the VM is continued.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>qemu seems to relay on vmsave to reset the guest while vm is continued, we just keep our eyes on that.</p>
<p>Combine qemu guest state change hook:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_SET_CLOCK: &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_arch</span> *<span class="title">ka</span> =</span> &amp;kvm-&gt;arch;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">user_ns</span>;</span></span><br><span class="line">	u64 now_ns;</span><br><span class="line"></span><br><span class="line">	r = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;user_ns, argp, <span class="keyword">sizeof</span>(user_ns)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	r = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (user_ns.flags)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	r = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">TODO:</span> userspace has to take care of races with VCPU_RUN, so</span></span><br><span class="line"><span class="comment">	 * kvm_gen_update_masterclock() can be cut down to locked</span></span><br><span class="line"><span class="comment">	 * pvclock_update_vm_gtod_copy().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kvm_gen_update_masterclock(kvm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This pairs with kvm_guest_time_update(): when masterclock is</span></span><br><span class="line"><span class="comment">	 * in use, we use master_kernel_ns + kvmclock_offset to set</span></span><br><span class="line"><span class="comment">	 * unsigned &#x27;system_time&#x27; so if we use get_kvmclock_ns() (which</span></span><br><span class="line"><span class="comment">	 * is slightly ahead) here we risk going negative on unsigned</span></span><br><span class="line"><span class="comment">	 * &#x27;system_time&#x27; when &#x27;user_ns.clock&#x27; is very small.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_lock_irq(&amp;ka-&gt;pvclock_gtod_sync_lock);</span><br><span class="line">	<span class="keyword">if</span> (kvm-&gt;arch.use_master_clock)</span><br><span class="line">		now_ns = ka-&gt;master_kernel_ns;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		now_ns = get_kvmclock_base_ns();</span><br><span class="line">	ka-&gt;kvmclock_offset = user_ns.clock - now_ns;</span><br><span class="line">	spin_unlock_irq(&amp;ka-&gt;pvclock_gtod_sync_lock);</span><br><span class="line"></span><br><span class="line">	kvm_make_all_cpus_request(kvm, KVM_REQ_CLOCK_UPDATE);</span><br></pre></td></tr></table></figure>

<p>will be used to update guest clock.</p>
<h2 id="Hand-on-test-to-confirm-clock-updates"><a href="#Hand-on-test-to-confirm-clock-updates" class="headerlink" title="Hand on test to confirm clock updates"></a>Hand on test to confirm clock updates</h2><p>Enable kvm trace by:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/kernel/debug/tracing/events/kvm/enable</span><br></pre></td></tr></table></figure>

<p>Then collect the output when vm migrated to this host:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/kernel/debug/tracing/trace_pipe &gt; trace_migrated_vm</span><br></pre></td></tr></table></figure>

<p>We can see following logs at first:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;<span class="number">-89383</span> [<span class="number">001</span>] .... <span class="number">97852.765277</span>: kvm_update_master_clock: masterclock <span class="number">0</span> hostclock <span class="number">0x2</span> offsetmatched <span class="number">0</span></span><br><span class="line">&lt;...&gt;<span class="number">-89441</span> [<span class="number">002</span>] d... <span class="number">97852.785366</span>: kvm_write_tsc_offset: vcpu=<span class="number">0</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89441</span> [<span class="number">002</span>] d... <span class="number">97852.785402</span>: kvm_track_tsc: vcpu_id <span class="number">0</span> masterclock <span class="number">0</span> offsetmatched <span class="number">0</span> nr_online <span class="number">1</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89442</span> [<span class="number">002</span>] d... <span class="number">97852.786522</span>: kvm_write_tsc_offset: vcpu=<span class="number">1</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89442</span> [<span class="number">002</span>] d... <span class="number">97852.786533</span>: kvm_track_tsc: vcpu_id <span class="number">1</span> masterclock <span class="number">0</span> offsetmatched <span class="number">1</span> nr_online <span class="number">2</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89443</span> [<span class="number">002</span>] d... <span class="number">97852.787341</span>: kvm_write_tsc_offset: vcpu=<span class="number">2</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89443</span> [<span class="number">002</span>] d... <span class="number">97852.787348</span>: kvm_track_tsc: vcpu_id <span class="number">2</span> masterclock <span class="number">0</span> offsetmatched <span class="number">2</span> nr_online <span class="number">3</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89444</span> [<span class="number">002</span>] d... <span class="number">97852.788099</span>: kvm_write_tsc_offset: vcpu=<span class="number">3</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89444</span> [<span class="number">002</span>] d... <span class="number">97852.788120</span>: kvm_track_tsc: vcpu_id <span class="number">3</span> masterclock <span class="number">0</span> offsetmatched <span class="number">3</span> nr_online <span class="number">4</span> hostclock <span class="number">0x2</span></span><br></pre></td></tr></table></figure>

<p><code>kvm_update_master_clock</code> is used for vm migration:</p>
<p>And the tsc offset changed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-89441 [002] d... 97852.785366: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89441 [002] d... 97852.785402: kvm_track_tsc: vcpu_id 0 masterclock 0 offsetmatched 0 nr_online 1 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89442 [002] d... 97852.786522: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89442 [002] d... 97852.786533: kvm_track_tsc: vcpu_id 1 masterclock 0 offsetmatched 1 nr_online 2 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89443 [002] d... 97852.787341: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89443 [002] d... 97852.787348: kvm_track_tsc: vcpu_id 2 masterclock 0 offsetmatched 2 nr_online 3 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89444 [002] d... 97852.788099: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line"></span><br><span class="line">&lt;...&gt;-89441 [003] d... 97852.872014: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89442 [003] d... 97852.872105: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89443 [003] d... 97852.872189: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89444 [003] d... 97852.872264: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line"></span><br><span class="line">&lt;...&gt;-89441 [000] d... 97856.399432: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89442 [000] d... 97856.403066: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89443 [000] d... 97856.403273: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89444 [000] d... 97856.403414: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br></pre></td></tr></table></figure>

<p>Follow the trace we can find linux kernel code:</p>
<p><code>kvm_vcpu_write_tsc_offset</code> -&gt; <code>kvm_x86_write_l1_tsc_offset</code> -&gt;  <code>write_l1_tsc_offset</code> -&gt; <code>vmx_write_l1_tsc_offset</code> -&gt; <code>trace_kvm_write_tsc_offset</code></p>
<p>And there are multi usages of <code>kvm_vcpu_write_tsc_offset</code></p>
<ul>
<li><code>kvm_synchronize_tsc</code><ul>
<li><code>MSR_IA32_TSC</code> -&gt; <code>kvm_synchronize_tsc</code></li>
<li><code>kvm_vm_ioctl_create_vcpu</code> -&gt; <code>kvm_arch_vcpu_postcreate</code> -&gt; <code>kvm_synchronize_tsc</code></li>
</ul>
</li>
<li><code>adjust_tsc_offset_guest</code><ul>
<li><code>kvm_guest_time_update</code> -&gt; <code>adjust_tsc_offset_guest</code> and <code>kvm_hv_setup_tsc_page</code> this is hyper-v impacted case</li>
<li><code>MSR_IA32_TSC</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
<li><code>MSR_IA32_TSC_ADJUST</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
<li><code>kvm_arch_vcpu_load</code> -&gt; <code>adjust_tsc_offset_host</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
</ul>
</li>
<li><code>kvm_arch_vcpu_load</code> same as above</li>
</ul>
<p>So the following three parts of <code>kvm_vcpu_write_tsc_offset</code> matches with guest creation.</p>
<ul>
<li>Create vcpu</li>
<li>Load vcpu</li>
<li>Adjust tsc offset</li>
</ul>
<p>In last guest hang post, we can see windows guest try to get counter ref:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_time_ref_counter</span><span class="params">(struct kvm *kvm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_hv</span> *<span class="title">hv</span> =</span> to_kvm_hv(kvm);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span>;</span></span><br><span class="line">	u64 tsc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fall back to get_kvmclock_ns() when TSC page hasn&#x27;t been set up,</span></span><br><span class="line"><span class="comment">	 * is broken, disabled or being updated.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (hv-&gt;hv_tsc_page_status != HV_TSC_PAGE_SET)</span><br><span class="line">		<span class="keyword">return</span> div_u64(get_kvmclock_ns(kvm), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	vcpu = kvm_get_vcpu(kvm, <span class="number">0</span>);</span><br><span class="line">	tsc = kvm_read_l1_tsc(vcpu, rdtsc());</span><br><span class="line">	<span class="keyword">return</span> mul_u64_u64_shr(tsc, hv-&gt;tsc_ref.tsc_scale, <span class="number">64</span>)</span><br><span class="line">		+ hv-&gt;tsc_ref.tsc_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But this is used by MSR read request from guest. And now we need to debug <code>hv_tsc_page_status</code> and <code>kvm_hv_setup_tsc_page</code> usage.</p>
<p>Without kvm hidden:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114210 [002] d... 12255.411580: kvm_exit: vcpu 1 reason MSR_READ rip 0xfffff800ece454c5 info1 0x0000000000000000 info2 0x0000000000000000 intr_info 0x00000000 error_code 0x00000000</span><br><span class="line">&lt;...&gt;-114210 [002] .... 12255.411581: kvm_msr: msr_read 40000020 &#x3D; 0x6fac3c27</span><br><span class="line">&lt;...&gt;-114210 [002] d... 12255.411582: kvm_entry: vcpu 1, rip 0xfffff800ece454c7</span><br><span class="line">&lt;...&gt;-114211 [000] .... 12255.411585: kvm_vcpu_wakeup: wait time 1759974 ns, polling valid</span><br><span class="line">&lt;...&gt;-114211 [000] .... 12255.411585: kvm_hv_timer_state: vcpu_id 2 hv_timer 0</span><br></pre></td></tr></table></figure>

<p>We can find <code>kvm_hv_timer_state</code> in trace, and according to linux kernel code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRACE_EVENT(kvm_hv_timer_state,</span><br><span class="line">		TP_PROTO(<span class="keyword">unsigned</span> <span class="keyword">int</span> vcpu_id, <span class="keyword">unsigned</span> <span class="keyword">int</span> hv_timer_in_use),</span><br></pre></td></tr></table></figure>

<p>There are two ways to show the trace:</p>
<ul>
<li><code>start_sw_timer</code> -&gt; <code>trace_kvm_hv_timer_state(apic-&gt;vcpu-&gt;vcpu_id, false);</code> which is always false (means 0 in trace)</li>
<li><code>start_hv_timer</code> -&gt; <code>trace_kvm_hv_timer_state(vcpu-&gt;vcpu_id, ktimer-&gt;hv_timer_in_use);</code> which returns <code>hv_timer_in_use</code> from  <code>ktimer-&gt;hv_timer_in_use</code></li>
</ul>
<p>Check the code about <code>start_hv_timer</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_hv_timer</span><span class="params">(struct kvm_lapic *apic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_timer</span> *<span class="title">ktimer</span> =</span> &amp;apic-&gt;lapic_timer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> =</span> apic-&gt;vcpu;</span><br><span class="line">	<span class="keyword">bool</span> expired;</span><br><span class="line"></span><br><span class="line">	WARN_ON(preemptible());</span><br><span class="line">	<span class="keyword">if</span> (!kvm_can_use_hv_timer(vcpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ktimer-&gt;tscdeadline)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (static_call(kvm_x86_set_hv_timer)(vcpu, ktimer-&gt;tscdeadline, &amp;expired))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	ktimer-&gt;hv_timer_in_use = <span class="literal">true</span>;</span><br><span class="line">	hrtimer_cancel(&amp;ktimer-&gt;timer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * To simplify handling the periodic timer, leave the hv timer running</span></span><br><span class="line"><span class="comment">	 * even if the deadline timer has expired, i.e. rely on the resulting</span></span><br><span class="line"><span class="comment">	 * VM-Exit to recompute the periodic timer&#x27;s target expiration.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!apic_lvtt_period(apic)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Cancel the hv timer if the sw timer fired while the hv timer</span></span><br><span class="line"><span class="comment">		 * was being programmed, or if the hv timer itself expired.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (atomic_read(&amp;ktimer-&gt;pending)) &#123;</span><br><span class="line">			cancel_hv_timer(apic);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (expired) &#123;</span><br><span class="line">			apic_timer_expired(apic, <span class="literal">false</span>);</span><br><span class="line">			cancel_hv_timer(apic);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_kvm_hv_timer_state(vcpu-&gt;vcpu_id, ktimer-&gt;hv_timer_in_use);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ktimer-&gt;hv_timer_in_use</code> is set to <code>true</code> so we focus on <code>start_sw_timer</code> next.</p>
<p>There are several ways to goes into <code>restart_apic_timer</code></p>
<ul>
<li><code>restart_apic_timer</code> -&gt; <code>start_sw_timer</code><ul>
<li><code>vmx_exit_handlers_fastpath</code> or <code>__vmx_handle_exit</code> -&gt; <code> handle_fastpath_preemption_timer</code> -&gt; <code>kvm_lapic_expired_hv_timer</code>  -&gt; <code>restart_apic_timer</code></li>
<li><code>vcpu_block</code> -&gt; <code>post_block</code> -&gt; <code>vmx_post_block</code> -&gt;  <code>kvm_lapic_switch_to_hv_timer</code> -&gt; <code>restart_apic_timer</code></li>
<li><code>MSR_IA32_TSC_DEADLINE</code> -&gt;<code>handle_fastpath_set_tscdeadline</code> -&gt; <code>kvm_set_lapic_tscdeadline_msr</code> -&gt;  <code>__start_apic_timer</code> -&gt; <code>restart_apic_timer</code></li>
<li><code>APIC_TDCR</code> -&gt; <code>restart_apic_timer</code> </li>
</ul>
</li>
<li><code>vcpu_block</code> -&gt;  <code>vmx_pre_block</code> -&gt; <code>kvm_lapic_switch_to_sw_timer</code> -&gt; <code>start_sw_timer</code></li>
</ul>
<p>Because we see a trace before shows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kvm_vcpu_wakeup: wait time 1759974 ns, polling valid</span><br></pre></td></tr></table></figure>

<p>which is in kvm_vcpu_block, so this means vmx_post_block <code>restart_apic_timer</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trace_kvm_vcpu_wakeup(block_ns, waited, vcpu_valid_wakeup(vcpu));</span><br><span class="line">kvm_arch_vcpu_block_finish(vcpu);</span><br></pre></td></tr></table></figure>

<p>And because the code runs as:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!start_hv_timer(apic))</span><br><span class="line">	start_sw_timer(apic);</span><br></pre></td></tr></table></figure>

<p><code>start_hv_timer</code> must returns false:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_hv_timer</span><span class="params">(struct kvm_lapic *apic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_timer</span> *<span class="title">ktimer</span> =</span> &amp;apic-&gt;lapic_timer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> =</span> apic-&gt;vcpu;</span><br><span class="line">	<span class="keyword">bool</span> expired;</span><br><span class="line"></span><br><span class="line">	WARN_ON(preemptible());</span><br><span class="line">	<span class="keyword">if</span> (!kvm_can_use_hv_timer(vcpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ktimer-&gt;tscdeadline)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (static_call(kvm_x86_set_hv_timer)(vcpu, ktimer-&gt;tscdeadline, &amp;expired))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><code>kvm_can_use_hv_timer</code> check seems works on x86 machine and while <code>X86_FEATURE_MWAIT</code> is supported.</p>
<p>From the trace we could know, when vcpu exit and come back to work, the timer will be updated, and use vcpu 3 as example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114212 [002] d... 12297.437890: kvm_exit: vcpu 3 reason HLT rip 0xfffff800ecc2b36e info1 0x0000000000000000 info2 0x0000000000000000 intr_info 0x00000000 error_code 0x00000000</span><br></pre></td></tr></table></figure>

<p>vcpu 3 HLT and cause kvm_exit.</p>
<p>Then it wakeup after <code>4774180 ns</code>  and hv_timer is traced without usage.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114212 [002] .... 12255.393408: kvm_vcpu_wakeup: wait time 4774180 ns, polling valid</span><br><span class="line">&lt;...&gt;-114212 [002] .... 12255.393410: kvm_hv_timer_state: vcpu_id 3 hv_timer 0</span><br></pre></td></tr></table></figure>

<p>And hv_timer will be cancelled after live migration:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (apic-&gt;lapic_timer.hv_timer_in_use)</span><br><span class="line">	cancel_hv_timer(apic);</span><br></pre></td></tr></table></figure>

<p>Let’s check hv_timer before migration:</p>
<h2 id="Can-we-resolve-compatibility-issues"><a href="#Can-we-resolve-compatibility-issues" class="headerlink" title="Can we resolve compatibility issues?"></a>Can we resolve compatibility issues?</h2><p>See the code of qemu, it will disable features of FEAT_KVM after all features setup, so we can not manually assign those features:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (l = plus_features; l; l = l-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prop = l-&gt;data;</span><br><span class="line">    object_property_set_bool(OBJECT(cpu), <span class="literal">true</span>, prop, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (l = minus_features; l; l = l-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prop = l-&gt;data;</span><br><span class="line">    object_property_set_bool(OBJECT(cpu), <span class="literal">false</span>, prop, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/09/cpu-features-about-kvm-hidden/" data-id="clf6xo0140000ibwb0fajc90n" data-title="Cpu features about kvm hidden" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/09/cpu-features-about-kvm-hidden/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/09/cpu-features-about-kvm-hidden/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-virtio-on-linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/virtio-on-linux/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T14:38:09.000Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>►<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/virtio-on-linux/">Virtio on Linux</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote>
<p>Virtio is an open standard that defines a protocol for communication between drivers and devices of different types, see Chapter 5 (“Device Types”) of the virtio spec ([<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id2">1]</a>). Originally developed as a standard for paravirtualized devices implemented by a hypervisor, it can be used to interface any compliant device (real or emulated) with a driver.</p>
</blockquote>
<p>Virtio是一个开放的标准，它定义了驱动程序和不同类型的设备之间的通信协议，见virtio规范（[<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id2">1]</a>）的第五章（”设备类型”）。它最初是作为由管理程序实现的准虚拟化设备的标准而开发的，但它可以用来将任何符合要求的设备（真实的或模拟的）与驱动程序连接。</p>
<blockquote>
<p>For illustrative purposes, this document will focus on the common case of a Linux kernel running in a virtual machine and using paravirtualized devices provided by the hypervisor, which exposes them as virtio devices via standard mechanisms such as PCI.</p>
</blockquote>
<p>为了说明问题，本文将重点讨论Linux内核在虚拟机中运行并使用由管理程序提供的准虚拟化设备的常见情况，管理程序通过标准机制（如PCI）将它们暴露为virtio设备。</p>
<h2 id="Device-Driver-communication-virtqueues"><a href="#Device-Driver-communication-virtqueues" class="headerlink" title="Device - Driver communication: virtqueues"></a>Device - Driver communication: virtqueues</h2><blockquote>
<p>Although the virtio devices are really an abstraction layer in the hypervisor, they’re exposed to the guest as if they are physical devices using a specific transport method – PCI, MMIO or CCW – that is orthogonal to the device itself. The virtio spec defines these transport methods in detail, including device discovery, capabilities and interrupt handling.</p>
</blockquote>
<p>尽管virtio设备实际上是管理程序中的一个抽象层，但它们被暴露给客户，就像它们是使用特定的传输方法–PCI、MMIO或CCW–的物理设备一样，这与设备本身是正交的。virtio规范详细定义了这些传输方法，包括设备发现、能力和中断处理。</p>
<blockquote>
<p>The communication between the driver in the guest OS and the device in the hypervisor is done through shared memory (that’s what makes virtio devices so efficient) using specialized data structures called virtqueues, which are actually ring buffers <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#f1">1</a> of buffer descriptors similar to the ones used in a network device:</p>
</blockquote>
<p>客户操作系统中的驱动程序和管理程序中的设备之间的通信是通过共享内存完成的（这就是virtio设备如此高效的原因），使用称为virtqueues的专门数据结构，这实际上是类似于网络设备中使用的缓冲区描述符的环形缓冲区<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#f1">1</a>。</p>
<p>struct <strong>vring_desc</strong></p>
<p>Virtio ring descriptors, 16 bytes long. These can chain together via <strong>next</strong>.</p>
<p><strong>Definition</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct vring_desc &#123;</span><br><span class="line">    __virtio64 addr;</span><br><span class="line">    __virtio32 len;</span><br><span class="line">    __virtio16 flags;</span><br><span class="line">    __virtio16 next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Members</strong></p>
<ul>
<li><p><code>addr</code></p>
<p>buffer address (guest-physical)</p>
</li>
<li><p><code>len</code></p>
<p>buffer length</p>
</li>
<li><p><code>flags</code></p>
<p>descriptor flags</p>
</li>
<li><p><code>next</code></p>
<p>index of the next descriptor in the chain, if the VRING_DESC_F_NEXT flag is set. We chain unused descriptors via this, too.</p>
</li>
</ul>
<blockquote>
<p>All the buffers the descriptors point to are allocated by the guest and used by the host either for reading or for writing but not for both.</p>
<p>Refer to Chapter 2.5 (“Virtqueues”) of the virtio spec ([<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id2">1]</a>) for the reference definitions of virtqueues and “Virtqueues and virtio ring: How the data travels” blog post ([<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id3">2]</a>) for an illustrated overview of how the host device and the guest driver communicate.</p>
</blockquote>
<p>描述符指向的所有缓冲区都是由guest分配的，并由host用于读取或写入，但不能同时使用。</p>
<p>请参考virtio规范（[1]）的第2.5章（”虚拟队列”），了解虚拟队列的参考定义和 “虚拟队列和virtio环。数据是如何传输的 “博文（[2]），以图文并茂的方式概述了主机设备和客户驱动的通信方式。</p>
<p>The <code>vring_virtqueue</code> struct models a virtqueue, including the ring buffers and management data. Embedded in this struct is the <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.virtqueue"><code>virtqueue</code></a> struct, which is the data structure that’s ultimately used by virtio drivers:</p>
<p>struct <strong>virtqueue</strong></p>
<p>a queue to register buffers for sending or receiving.</p>
<p><strong>Definition</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct virtqueue &#123;</span><br><span class="line">    struct list_head list;</span><br><span class="line">    void (*callback)(struct virtqueue *vq);</span><br><span class="line">    const char *name;</span><br><span class="line">    struct virtio_device *vdev;</span><br><span class="line">    unsigned int index;</span><br><span class="line">    unsigned int num_free;</span><br><span class="line">    unsigned int num_max;</span><br><span class="line">    void *priv;</span><br><span class="line">    bool reset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Members</strong></p>
<ul>
<li><p><code>list</code></p>
<p>the chain of virtqueues for this device</p>
</li>
<li><p><code>callback</code></p>
<p>the function to call when buffers are consumed (can be NULL).</p>
</li>
<li><p><code>name</code></p>
<p>the name of this virtqueue (mainly for debugging)</p>
</li>
<li><p><code>vdev</code></p>
<p>the virtio device this queue was created for.</p>
</li>
<li><p><code>index</code></p>
<p>the zero-based ordinal number for this queue.</p>
</li>
<li><p><code>num_free</code></p>
<p>number of elements we expect to be able to fit.</p>
</li>
<li><p><code>num_max</code></p>
<p>the maximum number of elements supported by the device.</p>
</li>
<li><p><code>priv</code></p>
<p>a pointer for the virtqueue implementation to use.</p>
</li>
<li><p><code>reset</code></p>
<p>vq is in reset state or not.</p>
</li>
</ul>
<p><strong>Description</strong></p>
<blockquote>
<p> A note on <strong>num_free</strong>: with indirect buffers, each buffer needs one element in the queue, otherwise a buffer will need one element per sg element.</p>
<p>The callback function pointed by this struct is triggered when the device has consumed the buffers provided by the driver. More specifically, the trigger will be an interrupt issued by the hypervisor (see <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.vring_interrupt"><code>vring_interrupt()</code></a>). Interrupt request handlers are registered for a virtqueue during the virtqueue setup process (transport-specific).</p>
</blockquote>
<p>关于<strong>num_free</strong>的说明：对于间接缓冲区，每个缓冲区需要队列中的一个元素，否则一个缓冲区将需要每个sg元素的一个元素。</p>
<p>当设备消耗完驱动提供的缓冲区时，这个结构所指向的回调函数会被触发。更具体地说，触发器将是由管理程序发出的中断（见<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.vring_interrupt"><code>vring_interrupt()</code></a>）。中断请求处理程序是在虚拟队列设置过程中为虚拟队列注册的（特定于传输）。</p>
<p>irqreturn_t <strong>vring_interrupt</strong>(int irq, void *_vq)</p>
<p>notify a virtqueue on an interrupt</p>
<p><strong>Parameters</strong></p>
<ul>
<li><p><code>int irq</code></p>
<p>the IRQ number (ignored)</p>
</li>
<li><p><code>void *_vq</code></p>
<p>the <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.virtqueue"><code>struct virtqueue</code></a> to notify</p>
</li>
</ul>
<p><strong>Description</strong></p>
<p>Calls the callback function of <strong>_vq</strong> to process the virtqueue notification.</p>
<h2 id="Device-discovery-and-probing"><a href="#Device-discovery-and-probing" class="headerlink" title="Device discovery and probing"></a>Device discovery and probing</h2><blockquote>
<p>In the kernel, the virtio core contains the virtio bus driver and transport-specific drivers like virtio-pci and virtio-mmio. Then there are individual virtio drivers for specific device types that are registered to the virtio bus driver.</p>
</blockquote>
<p>在内核中，virtio核心包含virtio总线驱动和特定的传输驱动，如virtio-pci和virtio-mmio。然后，还有针对特定设备类型的单独的virtio驱动程序，它们被注册到virtio总线驱动程序上。</p>
<blockquote>
<p>How a virtio device is found and configured by the kernel depends on how the hypervisor defines it. Taking the QEMU virtio-console device as an example. When using PCI as a transport method, the device will present itself on the PCI bus with vendor 0x1af4 (Red Hat, Inc.) and device id 0x1003 (virtio console), as defined in the spec, so the kernel will detect it as it would do with any other PCI device.</p>
</blockquote>
<p>内核如何发现和配置virtio设备，取决于管理程序如何定义它。以QEMU virtio-console设备为例。当使用PCI作为传输方式时，该设备将在PCI总线上以供应商0x1af4（Red Hat, Inc.）和设备ID 0x1003（virtio console）的形式出现，正如规范中所定义的那样，所以内核会像检测其他PCI设备那样检测它。</p>
<blockquote>
<p>During the PCI enumeration process, if a device is found to match the virtio-pci driver (according to the virtio-pci device table, any PCI device with vendor id = 0x1af4):</p>
</blockquote>
<p>在PCI枚举过程中，如果发现一个设备与virtio-pci驱动相匹配（根据virtio-pci设备表，任何PCI设备的厂商ID=0x1af4）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Qumranet donated their vendor ID for devices 0x1000 thru 0x10FF. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> <span class="title">virtio_pci_id_table</span>[] =</span> &#123;</span><br><span class="line">        &#123; PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_ANY_ID) &#125;,</span><br><span class="line">        &#123; <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>then the virtio-pci driver is probed and, if the probing goes well, the device is registered to the virtio bus:</p>
</blockquote>
<p>然后对virtio-pci驱动进行探测，如果探测顺利，该设备就被注册到virtio总线上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">virtio_pci_probe</span><span class="params">(struct pci_dev *pci_dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct pci_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (force_legacy) &#123;</span><br><span class="line">                rc = virtio_pci_legacy_probe(vp_dev);</span><br><span class="line">                <span class="comment">/* Also try modern mode if we can&#x27;t map BAR0 (no IO space). */</span></span><br><span class="line">                <span class="keyword">if</span> (rc == -ENODEV || rc == -ENOMEM)</span><br><span class="line">                        rc = virtio_pci_modern_probe(vp_dev);</span><br><span class="line">                <span class="keyword">if</span> (rc)</span><br><span class="line">                        <span class="keyword">goto</span> err_probe;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rc = virtio_pci_modern_probe(vp_dev);</span><br><span class="line">                <span class="keyword">if</span> (rc == -ENODEV)</span><br><span class="line">                        rc = virtio_pci_legacy_probe(vp_dev);</span><br><span class="line">                <span class="keyword">if</span> (rc)</span><br><span class="line">                        <span class="keyword">goto</span> err_probe;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        rc = register_virtio_device(&amp;vp_dev-&gt;vdev);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>When the device is registered to the virtio bus the kernel will look for a driver in the bus that can handle the device and call that driver’s probe method.</p>
<p>At this point, the virtqueues will be allocated and configured by calling the appropriate virtio_find helper function, such as virtio_find_single_vq() or virtio_find_vqs(), which will end up calling a transport-specific find_vqs method.</p>
</blockquote>
<p>当设备被注册到virtio总线上时，内核将在总线上寻找一个可以处理该设备的驱动程序，并调用该驱动程序的探测方法。</p>
<p>此时，将通过调用适当的virtio_find辅助函数，如virtio_find_single_vq()或virtio_find_vqs()来分配和配置virtqueues，最终会调用一个特定于传输的find_vqs方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/03/virtio-on-linux/" data-id="clesn3uub00004xwb5f94h8vb" data-title="Virtio on Linux" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/03/virtio-on-linux/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/03/virtio-on-linux/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cpu-feature-configuration-code-diving" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/cpu-feature-configuration-code-diving/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:48:22.000Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/libvirt/">libvirt</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/cpu-feature-configuration-code-diving/">Cpu feature configuration code diving</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>If disable a feature in libvirt domain xml configuration, what will happen?</p>
<h2 id="General-code-about-libvirt-cpu-conf"><a href="#General-code-about-libvirt-cpu-conf" class="headerlink" title="General code about libvirt cpu conf"></a>General code about libvirt cpu conf</h2><p>Read cpu_conf.c main entrance is <code>virCPUDefFormatBuf</code></p>
<p>Libvirt have two types format:</p>
<ul>
<li><code>CUSTOM</code>: user define model and features of a cpu conf</li>
<li><code>HOST_MODEL</code>: matches a most suitable feature list with host</li>
</ul>
<p>And while handle conf definition:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">formatModel = (def-&gt;mode == VIR_CPU_MODE_CUSTOM ||</span><br><span class="line">               def-&gt;mode == VIR_CPU_MODE_HOST_MODEL);</span><br><span class="line">formatFallback = (def-&gt;type == VIR_CPU_TYPE_GUEST &amp;&amp;</span><br><span class="line">                  (def-&gt;mode == VIR_CPU_MODE_HOST_MODEL ||</span><br><span class="line">                   (def-&gt;mode == VIR_CPU_MODE_CUSTOM &amp;&amp; def-&gt;model)));</span><br></pre></td></tr></table></figure>

<p>see the enum:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    VIR_CPU_TYPE_HOST,</span><br><span class="line">    VIR_CPU_TYPE_GUEST,</span><br><span class="line">    VIR_CPU_TYPE_AUTO,</span><br><span class="line"></span><br><span class="line">    VIR_CPU_TYPE_LAST</span><br><span class="line">&#125; virCPUType;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VIR_CPU_TYPE_AUTO</code> : detect the input xml to tell is guest or host cpu model definition</li>
<li><code>VIR_CPU_TYPE_GUEST</code> : guest cpu model means the cpu conf define from domain xml</li>
<li><code>VIR_CPU_TYPE_HOST</code> : host cpu model means the cpu conf load from host capabilities xml</li>
</ul>
<p>So the could focus on <code>formatFallback</code>. </p>
<p>Verification is required, if you use a custom mode without a cpu model is not allowed, because custom means you need specify a collections of cpu features and custom features of the subset.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!def-&gt;model &amp;&amp; def-&gt;mode == VIR_CPU_MODE_CUSTOM &amp;&amp; def-&gt;nfeatures) &#123;</span><br><span class="line">    virReportError(VIR_ERR_INTERNAL_ERROR, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                   _(<span class="string">&quot;Non-empty feature list specified without CPU model&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while define model, need to get a fallback value for guest cpu</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((formatModel &amp;&amp; def-&gt;model) || formatFallback) &#123;</span><br><span class="line">    virBufferAddLit(buf, <span class="string">&quot;&lt;model&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (formatFallback) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *fallback;</span><br><span class="line"></span><br><span class="line">        fallback = virCPUFallbackTypeToString(def-&gt;fallback);</span><br><span class="line">        <span class="keyword">if</span> (!fallback) &#123;</span><br><span class="line">            virReportError(VIR_ERR_INTERNAL_ERROR,</span><br><span class="line">                           _(<span class="string">&quot;Unexpected CPU fallback value: %d&quot;</span>),</span><br><span class="line">                           def-&gt;fallback);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        virBufferAsprintf(buf, <span class="string">&quot; fallback=&#x27;%s&#x27;&quot;</span>, fallback);</span><br><span class="line">        <span class="keyword">if</span> (def-&gt;vendor_id)</span><br><span class="line">            virBufferEscapeString(buf, <span class="string">&quot; vendor_id=&#x27;%s&#x27;&quot;</span>, def-&gt;vendor_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (formatModel &amp;&amp; def-&gt;model) &#123;</span><br><span class="line">        virBufferEscapeString(buf, <span class="string">&quot;&gt;%s&lt;/model&gt;\n&quot;</span>, def-&gt;model);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        virBufferAddLit(buf, <span class="string">&quot;/&gt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fallback type:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    VIR_CPU_FALLBACK_ALLOW,</span><br><span class="line">    VIR_CPU_FALLBACK_FORBID,</span><br><span class="line"></span><br><span class="line">    VIR_CPU_FALLBACK_LAST</span><br><span class="line">&#125; virCPUFallback;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VIR_CPU_FALLBACK_ALLOW</code> means just use the cpu capabilities from host capabilities xml</li>
<li><code>VIR_CPU_FALLBACK_FORBID</code>means can stop guest from start with unsupported feature</li>
</ul>
<p>Also the topology can be defined:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (def-&gt;sockets &amp;&amp; def-&gt;cores &amp;&amp; def-&gt;threads) &#123;</span><br><span class="line">    virBufferAddLit(buf, <span class="string">&quot;&lt;topology&quot;</span>);</span><br><span class="line">    virBufferAsprintf(buf, <span class="string">&quot; sockets=&#x27;%u&#x27;&quot;</span>, def-&gt;sockets);</span><br><span class="line">    virBufferAsprintf(buf, <span class="string">&quot; cores=&#x27;%u&#x27;&quot;</span>, def-&gt;cores);</span><br><span class="line">    virBufferAsprintf(buf, <span class="string">&quot; threads=&#x27;%u&#x27;&quot;</span>, def-&gt;threads);</span><br><span class="line">    virBufferAddLit(buf, <span class="string">&quot;/&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>from xml too.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; def-&gt;nfeatures; i++) &#123;</span><br><span class="line">    virCPUFeatureDefPtr feature = def-&gt;features + i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!feature-&gt;name) &#123;</span><br><span class="line">        virReportError(VIR_ERR_INTERNAL_ERROR, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                       _(<span class="string">&quot;Missing CPU feature name&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (def-&gt;type == VIR_CPU_TYPE_GUEST) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *policy;</span><br><span class="line"></span><br><span class="line">        policy = virCPUFeaturePolicyTypeToString(feature-&gt;policy);</span><br><span class="line">        <span class="keyword">if</span> (!policy) &#123;</span><br><span class="line">            virReportError(VIR_ERR_INTERNAL_ERROR,</span><br><span class="line">                           _(<span class="string">&quot;Unexpected CPU feature policy %d&quot;</span>),</span><br><span class="line">                           feature-&gt;policy);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        virBufferAsprintf(buf, <span class="string">&quot;&lt;feature policy=&#x27;%s&#x27; name=&#x27;%s&#x27;/&gt;\n&quot;</span>,</span><br><span class="line">                          policy, feature-&gt;name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        virBufferAsprintf(buf, <span class="string">&quot;&lt;feature name=&#x27;%s&#x27;/&gt;\n&quot;</span>,</span><br><span class="line">                          feature-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Features will follow policies:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VIR_ENUM_IMPL(virCPUFeaturePolicy, VIR_CPU_FEATURE_LAST,</span><br><span class="line">              <span class="string">&quot;force&quot;</span>,</span><br><span class="line">              <span class="string">&quot;require&quot;</span>,</span><br><span class="line">              <span class="string">&quot;optional&quot;</span>,</span><br><span class="line">              <span class="string">&quot;disable&quot;</span>,</span><br><span class="line">              <span class="string">&quot;forbid&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Following part explains about those policies.</p>
<p><strong>force</strong></p>
<p>The virtual CPU will claim the feature is supported regardless of it being supported by host CPU.</p>
<p><strong>require</strong></p>
<p>Guest creation will fail unless the feature is supported by the host CPU or the hypervisor is able to emulate it.</p>
<p><strong>optional</strong></p>
<p>The feature will be supported by virtual CPU if and only if it is supported by host CPU.</p>
<p><strong>disable</strong></p>
<p>The feature will not be supported by virtual CPU.</p>
<p><strong>forbid</strong></p>
<p>Guest creation will fail if the feature is supported by host CPU.</p>
<p><code>virCPUDefFormatBuf</code> is used by <code>capabilities.c</code> which collects host features from host capabilities xml. But now we need to check the code in <code>domain_capabilities.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> virCPUDef *virCPUDefPtr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">virCPUDef</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> type;           <span class="comment">/* enum virCPUType */</span></span><br><span class="line">    <span class="keyword">int</span> mode;           <span class="comment">/* enum virCPUMode */</span></span><br><span class="line">    <span class="keyword">int</span> match;          <span class="comment">/* enum virCPUMatch */</span></span><br><span class="line">    virCPUCheck check;</span><br><span class="line">    virArch arch;</span><br><span class="line">    <span class="keyword">char</span> *model;</span><br><span class="line">    <span class="keyword">char</span> *vendor_id;    <span class="comment">/* vendor id returned by CPUID in the guest */</span></span><br><span class="line">    <span class="keyword">int</span> fallback;       <span class="comment">/* enum virCPUFallback */</span></span><br><span class="line">    <span class="keyword">char</span> *vendor;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> microcodeVersion;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sockets;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cores;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> threads;</span><br><span class="line">    <span class="keyword">size_t</span> nfeatures;</span><br><span class="line">    <span class="keyword">size_t</span> nfeatures_max;</span><br><span class="line">    virCPUFeatureDefPtr features;</span><br><span class="line">    virCPUCacheDefPtr cache;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>nfeatures will be set in _virCPUDef and supported features are parsed from domain xml:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Parses CPU definition XML from a node pointed to by @xpath. If @xpath is</span></span><br><span class="line"><span class="comment"> * NULL, the current node of @ctxt is used (i.e., it is a shortcut to &quot;.&quot;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Missing &lt;cpu&gt; element in the XML document is not considered an error unless</span></span><br><span class="line"><span class="comment"> * @xpath is NULL in which case the function expects it was provided with a</span></span><br><span class="line"><span class="comment"> * valid &lt;cpu&gt; element already. In other words, the function returns success</span></span><br><span class="line"><span class="comment"> * and sets @cpu to NULL if @xpath is not NULL and the node pointed to by</span></span><br><span class="line"><span class="comment"> * @xpath is not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success, -1 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">virCPUDefParseXML(xmlXPathContextPtr ctxt,</span><br><span class="line">                  <span class="keyword">const</span> <span class="keyword">char</span> *xpath,</span><br><span class="line">                  virCPUType type,</span><br><span class="line">                  virCPUDefPtr *cpu)</span><br></pre></td></tr></table></figure>

<p>Finally, <code>qemu_command.c</code> would use those features to qemu commandline:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cpu-&gt;nfeatures; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (STREQ(<span class="string">&quot;rtm&quot;</span>, cpu-&gt;features[i].name))</span><br><span class="line">        rtm = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (STREQ(<span class="string">&quot;hle&quot;</span>, cpu-&gt;features[i].name))</span><br><span class="line">        hle = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ((virCPUFeaturePolicy) cpu-&gt;features[i].policy) &#123;</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_FORCE:</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_REQUIRE:</span><br><span class="line">        <span class="keyword">if</span> (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))</span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,%s=on&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,+%s&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_DISABLE:</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_FORBID:</span><br><span class="line">        <span class="keyword">if</span> (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))</span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,%s=off&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,-%s&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_OPTIONAL:</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_LAST:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>like <code>-cpu ... feature1=on,feature2=off</code> to make those features take effects.</p>
<h2 id="Turn-to-qemu"><a href="#Turn-to-qemu" class="headerlink" title="Turn to qemu"></a>Turn to qemu</h2><p>Firstly, qemu will parse input <code>-cpu ....</code> string:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">parse_cpu_model</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cpu_model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectClass *oc;</span><br><span class="line">    CPUClass *cc;</span><br><span class="line">    gchar **model_pieces;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cpu_type;</span><br><span class="line"></span><br><span class="line">    model_pieces = g_strsplit(cpu_model, <span class="string">&quot;,&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    oc = cpu_class_by_name(CPU_RESOLVING_TYPE, model_pieces[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (oc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;unable to find CPU model &#x27;%s&#x27;&quot;</span>, model_pieces[<span class="number">0</span>]);</span><br><span class="line">        g_strfreev(model_pieces);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpu_type = object_class_get_name(oc);</span><br><span class="line">    cc = CPU_CLASS(oc);</span><br><span class="line">    cc-&gt;parse_features(cpu_type, model_pieces[<span class="number">1</span>], &amp;error_fatal);</span><br><span class="line">    g_strfreev(model_pieces);</span><br><span class="line">    <span class="keyword">return</span> cpu_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>An object from <code>oc = cpu_class_by_name(CPU_RESOLVING_TYPE, model_pieces[0]);</code>will return a cpu object class which support parse features. See following code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_common_parse_features</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">typename</span>, <span class="keyword">char</span> *features,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *val;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> cpu_globals_initialized;</span><br><span class="line">    <span class="comment">/* Single &quot;key=value&quot; string being parsed */</span></span><br><span class="line">    <span class="keyword">char</span> *featurestr = features ? strtok(features, <span class="string">&quot;,&quot;</span>) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should be called only once, catch invalid users */</span></span><br><span class="line">    assert(!cpu_globals_initialized);</span><br><span class="line">    cpu_globals_initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (featurestr) &#123;</span><br><span class="line">        val = <span class="built_in">strchr</span>(featurestr, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">            GlobalProperty *prop = g_new0(typeof(*prop), <span class="number">1</span>);</span><br><span class="line">            *val = <span class="number">0</span>;</span><br><span class="line">            val++;</span><br><span class="line">            prop-&gt;driver = <span class="keyword">typename</span>;</span><br><span class="line">            prop-&gt;property = g_strdup(featurestr);</span><br><span class="line">            prop-&gt;value = g_strdup(val);</span><br><span class="line">            prop-&gt;errp = &amp;error_fatal;</span><br><span class="line">            qdev_prop_register_global(prop);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;Expected key=value format, found %s.&quot;</span>,</span><br><span class="line">                       featurestr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        featurestr = strtok(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>key=value</code> format will be parse and store into qemu’s global property.</p>
<p>From: <code>target/i386/cpu.c</code></p>
<p>qemu defined <code>#define CPUID_EXT_HYPERVISOR  (1U &lt;&lt; 31)</code> for CPUID EXT to expose hypervisor information.</p>
<p>Then x86 cpu will use those global properties to initialize vcpu:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Parse &quot;+feature,-feature,feature=foo&quot; CPU feature string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_parse_featurestr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">typename</span>, <span class="keyword">char</span> *features,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *featurestr; <span class="comment">/* Single &#x27;key=value&quot; string being parsed */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> cpu_globals_initialized;</span><br><span class="line">    <span class="keyword">bool</span> ambiguous = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpu_globals_initialized) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cpu_globals_initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!features) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (featurestr = strtok(features, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">         featurestr;</span><br><span class="line">         featurestr = strtok(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *val = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> *eq = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> num[<span class="number">32</span>];</span><br><span class="line">        GlobalProperty *prop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Compatibility syntax: */</span></span><br><span class="line">        <span class="keyword">if</span> (featurestr[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            plus_features = g_list_append(plus_features,</span><br><span class="line">                                          g_strdup(featurestr + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (featurestr[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            minus_features = g_list_append(minus_features,</span><br><span class="line">                                           g_strdup(featurestr + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eq = <span class="built_in">strchr</span>(featurestr, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eq) &#123;</span><br><span class="line">            *eq++ = <span class="number">0</span>;</span><br><span class="line">            val = eq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        feat2prop(featurestr);</span><br><span class="line">        name = featurestr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_list_find_custom(plus_features, name, compare_string)) &#123;</span><br><span class="line">            warn_report(<span class="string">&quot;Ambiguous CPU model string. &quot;</span></span><br><span class="line">                        <span class="string">&quot;Don&#x27;t mix both \&quot;+%s\&quot; and \&quot;%s=%s\&quot;&quot;</span>,</span><br><span class="line">                        name, name, val);</span><br><span class="line">            ambiguous = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g_list_find_custom(minus_features, name, compare_string)) &#123;</span><br><span class="line">            warn_report(<span class="string">&quot;Ambiguous CPU model string. &quot;</span></span><br><span class="line">                        <span class="string">&quot;Don&#x27;t mix both \&quot;-%s\&quot; and \&quot;%s=%s\&quot;&quot;</span>,</span><br><span class="line">                        name, name, val);</span><br><span class="line">            ambiguous = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Special case: */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;tsc-freq&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret;</span><br><span class="line">            <span class="keyword">uint64_t</span> tsc_freq;</span><br><span class="line"></span><br><span class="line">            ret = qemu_strtosz_metric(val, <span class="literal">NULL</span>, &amp;tsc_freq);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span> || tsc_freq &gt; INT64_MAX) &#123;</span><br><span class="line">                error_setg(errp, <span class="string">&quot;bad numerical value %s&quot;</span>, val);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">snprintf</span>(num, <span class="keyword">sizeof</span>(num), <span class="string">&quot;%&quot;</span> PRId64, tsc_freq);</span><br><span class="line">            val = num;</span><br><span class="line">            name = <span class="string">&quot;tsc-frequency&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prop = g_new0(typeof(*prop), <span class="number">1</span>);</span><br><span class="line">        prop-&gt;driver = <span class="keyword">typename</span>;</span><br><span class="line">        prop-&gt;property = g_strdup(name);</span><br><span class="line">        prop-&gt;value = g_strdup(val);</span><br><span class="line">        prop-&gt;errp = &amp;error_fatal;</span><br><span class="line">        qdev_prop_register_global(prop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ambiguous) &#123;</span><br><span class="line">        warn_report(<span class="string">&quot;Compatibility of ambiguous CPU model &quot;</span></span><br><span class="line">                    <span class="string">&quot;strings won&#x27;t be kept on future QEMU versions&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which is registered as <code>cc-&gt;parse_features = x86_cpu_parse_featurestr;</code>.</p>
<p>features from qemu commandline will be put as global property for x86 cpu.</p>
<p>And before start virtual machine, qemu will insure there is not unavailable or missing features:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_get_unavailable_features</span><span class="params">(Object *obj, Visitor *v,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *opaque,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X86CPU *xc = X86_CPU(obj);</span><br><span class="line">    strList *result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    x86_cpu_list_feature_names(xc-&gt;filtered_features, &amp;result);</span><br><span class="line">    visit_type_strList(v, <span class="string">&quot;unavailable-features&quot;</span>, &amp;result, errp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for missing features that may prevent the CPU class from</span></span><br><span class="line"><span class="comment"> * running using the current machine and accelerator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_class_check_missing_features</span><span class="params">(X86CPUClass *xcc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 strList **missing_feats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X86CPU *xc;</span><br><span class="line">    Error *err = <span class="literal">NULL</span>;</span><br><span class="line">    strList **next = missing_feats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xcc-&gt;host_cpuid_required &amp;&amp; !accel_uses_host_cpuid()) &#123;</span><br><span class="line">        strList *<span class="keyword">new</span> = g_new0(strList, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span>-&gt;value = g_strdup(<span class="string">&quot;kvm&quot;</span>);</span><br><span class="line">        *missing_feats = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xc = X86_CPU(object_new(object_class_get_name(OBJECT_CLASS(xcc))));</span><br><span class="line"></span><br><span class="line">    x86_cpu_expand_features(xc, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">/* Errors at x86_cpu_expand_features should never happen,</span></span><br><span class="line"><span class="comment">         * but in case it does, just report the model as not</span></span><br><span class="line"><span class="comment">         * runnable at all using the &quot;type&quot; property.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        strList *<span class="keyword">new</span> = g_new0(strList, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span>-&gt;value = g_strdup(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">        *next = <span class="keyword">new</span>;</span><br><span class="line">        next = &amp;<span class="keyword">new</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x86_cpu_filter_features(xc, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    x86_cpu_list_feature_names(xc-&gt;filtered_features, next);</span><br><span class="line"></span><br><span class="line">    object_unref(OBJECT(xc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while qemu init cpu:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_realizefn</span><span class="params">(DeviceState *dev, Error **errp)</span></span></span><br></pre></td></tr></table></figure>

<p>features will be set to a CPU object:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>we could find “hypervisor” related cpu features defined by <code>FEAT_1_ECX</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[FEAT_1_ECX] = &#123;</span><br><span class="line">    .type = CPUID_FEATURE_WORD,</span><br><span class="line">    .feat_names = &#123;</span><br><span class="line">        <span class="string">&quot;pni&quot;</span> <span class="comment">/* Intel,AMD sse3 */</span>, <span class="string">&quot;pclmulqdq&quot;</span>, <span class="string">&quot;dtes64&quot;</span>, <span class="string">&quot;monitor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ds-cpl&quot;</span>, <span class="string">&quot;vmx&quot;</span>, <span class="string">&quot;smx&quot;</span>, <span class="string">&quot;est&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tm2&quot;</span>, <span class="string">&quot;ssse3&quot;</span>, <span class="string">&quot;cid&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="string">&quot;fma&quot;</span>, <span class="string">&quot;cx16&quot;</span>, <span class="string">&quot;xtpr&quot;</span>, <span class="string">&quot;pdcm&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">&quot;pcid&quot;</span>, <span class="string">&quot;dca&quot;</span>, <span class="string">&quot;sse4.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sse4.2&quot;</span>, <span class="string">&quot;x2apic&quot;</span>, <span class="string">&quot;movbe&quot;</span>, <span class="string">&quot;popcnt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tsc-deadline&quot;</span>, <span class="string">&quot;aes&quot;</span>, <span class="string">&quot;xsave&quot;</span>, <span class="string">&quot;osxsave&quot;</span>,</span><br><span class="line">        <span class="string">&quot;avx&quot;</span>, <span class="string">&quot;f16c&quot;</span>, <span class="string">&quot;rdrand&quot;</span>, <span class="string">&quot;hypervisor&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .cpuid = &#123; .eax = <span class="number">1</span>, .reg = R_ECX, &#125;,</span><br><span class="line">    .tcg_features = TCG_EXT_FEATURES,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>then cpu will read those features with key words:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Finishes initialization of CPUID data, filters CPU feature</span></span><br><span class="line"><span class="comment"> * words based on host availability of each feature.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: 0 if all flags are supported by the host, non-zero otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_filter_features</span><span class="params">(X86CPU *cpu, <span class="keyword">bool</span> verbose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPUX86State *env = &amp;cpu-&gt;env;</span><br><span class="line">    FeatureWord w;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prefix = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        prefix = accel_uses_host_cpuid()</span><br><span class="line">                 ? <span class="string">&quot;host doesn&#x27;t support requested feature&quot;</span></span><br><span class="line">                 : <span class="string">&quot;TCG doesn&#x27;t support requested feature&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; FEATURE_WORDS; w++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> host_feat =</span><br><span class="line">            x86_cpu_get_supported_feature_word(w, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">uint64_t</span> requested_features = env-&gt;features[w];</span><br><span class="line">        <span class="keyword">uint64_t</span> unavailable_features = requested_features &amp; ~host_feat;</span><br><span class="line">        mark_unavailable_features(cpu, w, unavailable_features, prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((env-&gt;features[FEAT_7_0_EBX] &amp; CPUID_7_0_EBX_INTEL_PT) &amp;&amp;</span><br><span class="line">        kvm_enabled()) &#123;</span><br><span class="line">        KVMState *s = CPU(cpu)-&gt;kvm_state;</span><br><span class="line">        <span class="keyword">uint32_t</span> eax_0 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">0</span>, R_EAX);</span><br><span class="line">        <span class="keyword">uint32_t</span> ebx_0 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">0</span>, R_EBX);</span><br><span class="line">        <span class="keyword">uint32_t</span> ecx_0 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">0</span>, R_ECX);</span><br><span class="line">        <span class="keyword">uint32_t</span> eax_1 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">1</span>, R_EAX);</span><br><span class="line">        <span class="keyword">uint32_t</span> ebx_1 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">1</span>, R_EBX);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!eax_0 ||</span><br><span class="line">           ((ebx_0 &amp; INTEL_PT_MINIMAL_EBX) != INTEL_PT_MINIMAL_EBX) ||</span><br><span class="line">           ((ecx_0 &amp; INTEL_PT_MINIMAL_ECX) != INTEL_PT_MINIMAL_ECX) ||</span><br><span class="line">           ((eax_1 &amp; INTEL_PT_MTC_BITMAP) != INTEL_PT_MTC_BITMAP) ||</span><br><span class="line">           ((eax_1 &amp; INTEL_PT_ADDR_RANGES_NUM_MASK) &lt;</span><br><span class="line">                                           INTEL_PT_ADDR_RANGES_NUM) ||</span><br><span class="line">           ((ebx_1 &amp; (INTEL_PT_PSB_BITMAP | INTEL_PT_CYCLE_BITMAP)) !=</span><br><span class="line">                (INTEL_PT_PSB_BITMAP | INTEL_PT_CYCLE_BITMAP)) ||</span><br><span class="line">           (ecx_0 &amp; INTEL_PT_IP_LIP)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Processor Trace capabilities aren&#x27;t configurable, so if the</span></span><br><span class="line"><span class="comment">             * host can&#x27;t emulate the capabilities we report on</span></span><br><span class="line"><span class="comment">             * cpu_x86_cpuid(), intel-pt can&#x27;t be enabled on the current host.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mark_unavailable_features(cpu, FEAT_7_0_EBX, CPUID_7_0_EBX_INTEL_PT, prefix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mainly the features is set by:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; FEATURE_WORDS; w++) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> host_feat =</span><br><span class="line">        x86_cpu_get_supported_feature_word(w, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> requested_features = env-&gt;features[w];</span><br><span class="line">    <span class="keyword">uint64_t</span> unavailable_features = requested_features &amp; ~host_feat;</span><br><span class="line">    mark_unavailable_features(cpu, w, unavailable_features, prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this part and supported feature keeps 0 because </p>
<p><code>requested_features &amp; ~host_feat</code> host unavialable features would be <code>~</code> at first.</p>
<p>We can dump those configurations from qemu vcpu to check is usage. </p>
<h2 id="How-kernel-use-it"><a href="#How-kernel-use-it" class="headerlink" title="How kernel use it"></a>How kernel use it</h2><p>Then we move to linux kernel check about those features usages.</p>
<p><code>#define X86_FEATURE_HYPERVISOR  (4*32+31) /* Running on a hypervisor */</code></p>
<p>kernel use <code>X86_FEATURE_HYPERVISOR</code> means if running on hypervisor.</p>
<h2 id="Hand-on-test"><a href="#Hand-on-test" class="headerlink" title="Hand on test"></a>Hand on test</h2><p>Now try to run a guest detecting hypervisor and figure out how to bypass the detection by virtualization level configs.</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><a target="_blank" rel="noopener" href="http://www.etallen.com/cpuid.html">http://www.etallen.com/cpuid.html</a> use a cpuid tool to dump cpu id of a guest to check our configuration.</p>
<p>By run <code>cpuid</code> to dump features, we can see following output with our expected values:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">feature information (1/ecx):</span><br><span class="line">   PNI/SSE3: Prescott New Instructions     = true</span><br><span class="line">   PCLMULDQ instruction                    = true</span><br><span class="line">   DTES64: 64-bit debug store              = false</span><br><span class="line">   MONITOR/MWAIT                           = false</span><br><span class="line">   CPL-qualified debug store               = false</span><br><span class="line">   VMX: virtual machine extensions         = true</span><br><span class="line">   SMX: safer mode extensions              = false</span><br><span class="line">   Enhanced Intel SpeedStep Technology     = false</span><br><span class="line">   TM2: thermal monitor 2                  = false</span><br><span class="line">   SSSE3 extensions                        = true</span><br><span class="line">   context ID: adaptive or shared L1 data  = false</span><br><span class="line">   SDBG: IA32_DEBUG_INTERFACE              = false</span><br><span class="line">   FMA instruction                         = true</span><br><span class="line">   CMPXCHG16B instruction                  = true</span><br><span class="line">   xTPR disable                            = false</span><br><span class="line">   PDCM: perfmon and debug                 = false</span><br><span class="line">   PCID: process context identifiers       = true</span><br><span class="line">   DCA: direct cache access                = false</span><br><span class="line">   SSE4.1 extensions                       = true</span><br><span class="line">   SSE4.2 extensions                       = true</span><br><span class="line">   x2APIC: extended xAPIC support          = true</span><br><span class="line">   MOVBE instruction                       = true</span><br><span class="line">   POPCNT instruction                      = true</span><br><span class="line">   time stamp counter deadline             = true</span><br><span class="line">   AES instruction                         = true</span><br><span class="line">   XSAVE/XSTOR states                      = true</span><br><span class="line">   OS-enabled XSAVE/XSTOR                  = true</span><br><span class="line">   AVX: advanced vector extensions         = true</span><br><span class="line">   F16C half-precision convert instruction = true</span><br><span class="line">   RDRAND instruction                      = true</span><br><span class="line">   hypervisor guest status                 = true</span><br></pre></td></tr></table></figure>

<p>the <code>hypervisor guest status                 = true</code> matches with linux kernel’s definition.</p>
<p>While with hypervisor feature disabled the output changed to:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">feature <span class="title">information</span> <span class="params">(<span class="number">1</span>/edx)</span>:</span></span><br><span class="line"><span class="function">   x87 FPU on chip                        </span>= <span class="literal">true</span></span><br><span class="line">   VME: <span class="keyword">virtual</span><span class="number">-8086</span> mode enhancement     = <span class="literal">true</span></span><br><span class="line">   DE: debugging extensions               = <span class="literal">true</span></span><br><span class="line">   PSE: page size extensions              = <span class="literal">true</span></span><br><span class="line">   TSC: time stamp counter                = <span class="literal">true</span></span><br><span class="line">   RDMSR <span class="keyword">and</span> WRMSR support                = <span class="literal">true</span></span><br><span class="line">   PAE: physical address extensions       = <span class="literal">true</span></span><br><span class="line">   MCE: machine check exception           = <span class="literal">true</span></span><br><span class="line">   CMPXCHG8B inst.                        = <span class="literal">true</span></span><br><span class="line">   APIC on chip                           = <span class="literal">true</span></span><br><span class="line">   SYSENTER <span class="keyword">and</span> SYSEXIT                   = <span class="literal">true</span></span><br><span class="line">   MTRR: memory type range registers      = <span class="literal">true</span></span><br><span class="line">   PTE global bit                         = <span class="literal">true</span></span><br><span class="line">   MCA: machine check architecture        = <span class="literal">true</span></span><br><span class="line">   CMOV: conditional move/compare instr   = <span class="literal">true</span></span><br><span class="line">   PAT: page attribute table              = <span class="literal">true</span></span><br><span class="line">   PSE<span class="number">-36</span>: page size extension            = <span class="literal">true</span></span><br><span class="line">   PSN: processor serial number           = <span class="literal">false</span></span><br><span class="line">   CLFLUSH instruction                    = <span class="literal">true</span></span><br><span class="line">   DS: debug store                        = <span class="literal">false</span></span><br><span class="line">   ACPI: thermal monitor <span class="keyword">and</span> clock ctrl   = <span class="literal">false</span></span><br><span class="line">   MMX Technology                         = <span class="literal">true</span></span><br><span class="line">   FXSAVE/FXRSTOR                         = <span class="literal">true</span></span><br><span class="line">   SSE extensions                         = <span class="literal">true</span></span><br><span class="line">   SSE2 extensions                        = <span class="literal">true</span></span><br><span class="line">   SS: self snoop                         = <span class="literal">true</span></span><br><span class="line">   hyper-threading / multi-core supported = <span class="literal">true</span></span><br><span class="line">   TM: therm. monitor                     = <span class="literal">false</span></span><br><span class="line">   IA64                                   = <span class="literal">false</span></span><br><span class="line">   PBE: pending <span class="keyword">break</span> event               = <span class="literal">false</span></span><br><span class="line">feature information (<span class="number">1</span>/ecx):</span><br><span class="line">   PNI/SSE3: Prescott New Instructions     = <span class="literal">true</span></span><br><span class="line">   PCLMULDQ instruction                    = <span class="literal">true</span></span><br><span class="line">   DTES64: <span class="number">64</span>-bit debug store              = <span class="literal">false</span></span><br><span class="line">   MONITOR/MWAIT                           = <span class="literal">false</span></span><br><span class="line">   CPL-qualified debug store               = <span class="literal">false</span></span><br><span class="line">   VMX: <span class="keyword">virtual</span> machine extensions         = <span class="literal">true</span></span><br><span class="line">   SMX: safer mode extensions              = <span class="literal">false</span></span><br><span class="line">   Enhanced Intel SpeedStep Technology     = <span class="literal">false</span></span><br><span class="line">   TM2: thermal monitor <span class="number">2</span>                  = <span class="literal">false</span></span><br><span class="line">   SSSE3 extensions                        = <span class="literal">true</span></span><br><span class="line">   context ID: adaptive <span class="keyword">or</span> shared L1 data  = <span class="literal">false</span></span><br><span class="line">   SDBG: IA32_DEBUG_INTERFACE              = <span class="literal">false</span></span><br><span class="line">   FMA instruction                         = <span class="literal">true</span></span><br><span class="line">   CMPXCHG16B instruction                  = <span class="literal">true</span></span><br><span class="line">   xTPR disable                            = <span class="literal">false</span></span><br><span class="line">   PDCM: perfmon <span class="keyword">and</span> debug                 = <span class="literal">false</span></span><br><span class="line">   PCID: process context identifiers       = <span class="literal">true</span></span><br><span class="line">   DCA: direct cache access                = <span class="literal">false</span></span><br><span class="line">   SSE4<span class="number">.1</span> extensions                       = <span class="literal">true</span></span><br><span class="line">   SSE4<span class="number">.2</span> extensions                       = <span class="literal">true</span></span><br><span class="line">   x2APIC: extended xAPIC support          = <span class="literal">true</span></span><br><span class="line">   MOVBE instruction                       = <span class="literal">true</span></span><br><span class="line">   POPCNT instruction                      = <span class="literal">true</span></span><br><span class="line">   time stamp counter deadline             = <span class="literal">true</span></span><br><span class="line">   AES instruction                         = <span class="literal">true</span></span><br><span class="line">   XSAVE/XSTOR states                      = <span class="literal">true</span></span><br><span class="line">   OS-enabled XSAVE/XSTOR                  = <span class="literal">true</span></span><br><span class="line">   AVX: advanced <span class="built_in">vector</span> extensions         = <span class="literal">true</span></span><br><span class="line">   F16C half-precision convert instruction = <span class="literal">true</span></span><br><span class="line">   RDRAND instruction                      = <span class="literal">true</span></span><br><span class="line">   hypervisor guest status                 = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>the <code>hypervisor guest status                 = false</code> value changed as expected.</p>
<h4 id="Linux-drawbacks"><a href="#Linux-drawbacks" class="headerlink" title="Linux drawbacks"></a>Linux drawbacks</h4><p>Read the usage about <code>X86_FEATURE_HYPERVISOR</code> in linux kernel. Some drawbacks can be found in kernel code directly.</p>
<p>From <code>qspintlock.h</code> :    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RHEL7 specific:</span></span><br><span class="line"><span class="comment"> * To provide backward compatibility with pre-7.4 kernel modules that</span></span><br><span class="line"><span class="comment"> * inlines the ticket spinlock unlock code. The virt_spin_lock() function</span></span><br><span class="line"><span class="comment"> * will have to recognize both a lock value of 0 or _Q_UNLOCKED_VAL as</span></span><br><span class="line"><span class="comment"> * being in an unlocked state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">virt_spin_lock</span><span class="params">(struct qspinlock *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lockval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!static_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>Slow spin lock will not be detected.</p>
<p>From <code>paravirt-spinlocks.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">queued_enable_pv_ticketlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!static_cpu_has(X86_FEATURE_HYPERVISOR) ||</span><br><span class="line">	   (pv_lock_ops.queued_spin_lock_slowpath !=</span><br><span class="line">	    native_queued_spin_lock_slowpath))</span><br><span class="line">		static_key_slow_inc(&amp;paravirt_ticketlocks_enabled);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>From <code>tsc.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t enable ART in a VM, non-stop TSC required,</span></span><br><span class="line"><span class="comment"> * and the TSC counter resets must not occur asynchronously.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (boot_cpu_has(X86_FEATURE_HYPERVISOR) ||</span><br><span class="line">    !boot_cpu_has(X86_FEATURE_NONSTOP_TSC) ||</span><br><span class="line">    art_to_tsc_denominator &lt; ART_MIN_DENOMINATOR ||</span><br><span class="line">    tsc_async_resets)</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>Always run timer will be started which actually should not be enabled.</p>
<p>From <code>apic.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER) ||</span><br><span class="line">    boot_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>From <code>mshyperv.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!boot_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>Can not detect if run on hyperv.</p>
<p>From <code>radeon_device</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * radeon_device_is_virtual - check if we are running is a virtual environment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Check if the asic has been passed through to a VM (all asics).</span></span><br><span class="line"><span class="comment"> * Used at driver startup.</span></span><br><span class="line"><span class="comment"> * Returns true if virtual or false if not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">radeon_device_is_virtual</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">	<span class="keyword">return</span> boot_cpu_has(X86_FEATURE_HYPERVISOR);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Radeon gpu will not detect it is running as guest.</p>
<p>For kernel it may failed to detect that it is running over hypervisor. So related performance improvement changed won’t be applied so there will be a performance drop for those guests.</p>
<p>So does the userspace application also can not do specific things without knowing it is running in virtual machine.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/01/cpu-feature-configuration-code-diving/" data-id="clepog9dl0000fdwb444cfiz4" data-title="Cpu feature configuration code diving" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/01/cpu-feature-configuration-code-diving/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/01/cpu-feature-configuration-code-diving/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-packed-virtqueue-how-to-reduce-overhead-with-virtio" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" class="article-date">
  <time class="dt-published" datetime="2023-02-23T15:13:20.000Z" itemprop="datePublished">2023-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>►<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/">Packed virtqueue: How to reduce overhead with virtio</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>This is the final post of a three-post series, the previous posts are “<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">Virtio devices and drivers overview: The headjack and the phone</a>,” and “<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtqueues-and-virtio-ring-how-data-travels">Virtqueues and virtio ring: How the data travels</a>.”</p>
</blockquote>
<p> 这是三篇系列文章的最后一篇，之前的文章是”<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">Virtio设备和驱动概述：头戴式耳机和手机</a>“，以及”<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtqueues-and-virtio-ring-how-data-travels">Virtqueues和virtio环：数据如何传输</a>“。</p>
<h2 id="Split-virtqueue-issues-Too-much-spinning-around"><a href="#Split-virtqueue-issues-Too-much-spinning-around" class="headerlink" title="Split virtqueue issues: Too much spinning around"></a>Split virtqueue issues: Too much spinning around</h2><blockquote>
<p>While the split virtqueue shines because of the simplicity of its design, it has a fundamental problem: The avail-used buffer cycle needs to use memory in a very sparse way. This puts pressure on the CPU cache utilization, and in the case of hardware means several PCI transactions for each descriptor.</p>
</blockquote>
<p>虽然split virtqueue因其设计的简单性而大放异彩，但它有一个基本问题：可用的缓冲区环需要以一种非常稀疏的方式使用内存。这给CPU的缓存利用率带来了压力，在硬件的情况下，意味着每个描述符都要有几个PCI事务。</p>
<blockquote>
<p>Packed virtqueue amends it by merging the three rings in just one location in virtual environment guest memory. While this may seem complicated at first glance, it’s a natural step after the split version if we realize that the device can discard and overwrite the data it already has read from the driver, and the same happens the other way around.</p>
</blockquote>
<p>Packed virtqueue对其进行了修正，将三个环合并在虚拟环境guest内存的一个位置。虽然这乍看起来很复杂，但如果我们意识到设备可以丢弃和覆盖它已经从驱动中读取的数据，那么这就是分裂版本之后的一个自然步骤，反之亦然。</p>
<h3 id="Supplying-descriptors-to-the-device-How-to-fill-device-todo-list"><a href="#Supplying-descriptors-to-the-device-How-to-fill-device-todo-list" class="headerlink" title="Supplying descriptors to the device: How to fill device todo-list"></a>Supplying descriptors to the device: How to fill device todo-list</h3><blockquote>
<p>After initialization in the same process as described in Virtio device initialization: feature bits, and after the agreement on RING_PACKED feature flag, the driver and the device starts with a shared blank canvas of descriptors with an agreed length (up to 215 entries) in a agreed guest’s memory location. The layout of these descriptors is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_desc</span> &#123;</span> </span><br><span class="line">        le64 addr;</span><br><span class="line">        le32 len;</span><br><span class="line">        le16 id;</span><br><span class="line">        le16 flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Memory layout of a packed virtqueue descriptor</strong></p>
</blockquote>
<p>在Virtio设备初始化：特征位中描述的相同过程中进行初始化后，在就RING_PACKED特征标志达成一致后，驱动程序和设备开始在商定的客体内存位置上共享一个空白的描述符，其长度是商定的（最多215条）。这些描述符的布局是：。</p>
<blockquote>
<p>This time, the id field is not an index for the device to look for the buffer: it is an opaque value for it, only has meaning for the driver.</p>
<p>The driver also maintains an internal single-bit ring wrap counter initialized to 1. The driver will flip its value every time it makes available the last descriptor in the ring.</p>
<p>As with split descriptors, the first step is to write the different fields: address, length, id and flags. However, packed descriptors take into account two new flags: <code>AVAIL(0x7)</code> and <code>USED(0x15)</code>. To mark a descriptor as available, the driver makes the <code>AVAIL(0x7)</code> flag the same as its internal wrap counter, and the used flag the inverse. While just a binary flag avail/used would be easier to implement, it would prevent useful optimizations we will describe later.</p>
</blockquote>
<p>这一次，id字段不是设备寻找缓冲区的索引：它是一个不透明的值，只对驱动有意义。</p>
<p>驱动程序还维护一个内部的单比特环形缠绕计数器，初始化为1，每次提供环形的最后一个描述符时，驱动程序都会翻转其值。</p>
<p>与分割描述符一样，第一步是写入不同的字段：地址、长度、ID和标志。然而，打包描述符考虑到了两个新的标志。AVAIL(0x7)和USED(0x15)。为了将一个描述符标记为可用，驱动程序使AVAIL(0x7)标志与它的内部包装计数器相同，而使用的标志则是相反的。虽然只有一个二进制标志AVA/USED会更容易实现，但它会妨碍我们后面要描述的有用的优化。</p>
<blockquote>
<p>As an example, if the driver allocates a write buffer with <code>0x1000</code> bytes on position <code>0x80000000</code> in the step 1 in the diagram, and makes it the first available descriptor setting <code>AVAIL(0x7)</code> flag the same as internal wrap counter (set) in step 2. The descriptor table would look like this:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Descriptor table after add the first buffer</strong></p>
</blockquote>
<p>举个例子，如果驱动程序在图中的第1步中在<code>0x80000000</code>位置分配了一个<code>0x1000</code>字节的写缓冲区，并使其成为第一个可用的描述符，在第2步中设置<code>AVAIL(0x7)</code>标志与内部包络计数相同（设置）。描述符表将看起来像这样。</p>
<blockquote>
<p>Note that the avail and used idx columns are in the table just for guidance, they don’t exist in the descriptor table: Each side should have its internal counter to know which position needs to poll or write next, and also the device must track the driver’s wrap counter. Lastly, as with used virtqueue, the driver notifies the device if the latter has notifications enabled (step 3 in the diagram).</p>
</blockquote>
<p>注意，表中的avail和used idx列只是为了指导，它们在描述符表中并不存在。每一方都应该有自己的内部计数器，以知道下一步需要轮询或写入哪个位置，同时设备也必须跟踪驱动的wrap计数器。最后，和使用的virtqueue一样，如果设备启用了通知功能，驱动程序就会通知设备（图中第3步）。</p>
<blockquote>
<p>And the usual diagram of the updates. Note the lack of the avail and used ring, as only the descriptor table is needed now.</p>
</blockquote>
<p>还有通常的更新图。请注意，由于现在只需要描述符表，所以缺少可用和已用环。</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-1.png" class="">

<p><strong>Diagram: Driver makes available a descriptor using a packed queue</strong></p>
<h3 id="Returning-used-descriptors-How-the-device-fills-the-“done”-list"><a href="#Returning-used-descriptors-How-the-device-fills-the-“done”-list" class="headerlink" title="Returning used descriptors: How the device fills the “done” list"></a>Returning used descriptors: How the device fills the “done” list</h3><blockquote>
<p>As the driver, the device maintains an internal single-bit ring wrap counter initialized to 1, and knows that the driver also has its internal ring wrap counter set. When the latter first searches for the first descriptor the driver has made available, it polls the first entry of the ring, looking for the avail flag equal to the driver internal wrap flag (set in this case).</p>
</blockquote>
<p>作为驱动程序，设备维护着一个初始化为1的内部单比特环形缠绕计数器，并且知道驱动程序也设置了其内部环形缠绕计数器。当后者第一次搜索驱动器提供的第一个描述符时，它就会轮询环的第一个条目，寻找等于驱动器内部包络标志的可用标志（在这种情况下是设置的）。</p>
<blockquote>
<p>As with a used ring, the length of the written data is returned in the “length” entry (if any), and the id of the used descriptor. At last, the device will make the avail (A) and used (U) flag the same as the device’s internal wrap counter.</p>
<p>Following the example, the device will let the descriptor table as figure 6. The device will know that the buffer has been returned because the used flag matches the available flag, and with the device internal wrap counter at the moment it wrote the descriptor. The returned address is not important: only the ID.</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Descriptor table after add the first buffer</strong></p>
</blockquote>
<p>与已用环一样，写入数据的长度会在 “length “条目中返回（如果有的话），以及已用描述符的id。最后，设备将使可用(A)和已用(U)标志与设备的内部缠绕计数器相同。</p>
<p>按照这个例子，设备将让描述符表如图6所示。设备将知道缓冲区已经被返回，因为使用的标志与可用的标志相匹配，并且在写描述符的时候与设备内部的wrap计数器相匹配。返回的地址并不重要：只有ID。</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-2.png" class="">

<p><strong>Diagram: Device marks a descriptor as used using a packed queue</strong></p>
<h3 id="Wrapping-the-descriptor-ring-How-the-lanes-keep-separated"><a href="#Wrapping-the-descriptor-ring-How-the-lanes-keep-separated" class="headerlink" title="Wrapping the descriptor ring: How the lanes keep separated?"></a>Wrapping the descriptor ring: How the lanes keep separated?</h3><blockquote>
<p>When the driver fills the complete descriptor table, it wraps and changes its internal Driver Ring Wrap. So, in the second round, the available descriptions will have the avail and used flags clear, so the device will have to poll looking for this condition once it wraps reading descriptors. Let’s see a full example of the different situations.</p>
</blockquote>
<p>当驱动程序填满了完整的描述符表，它就会包裹并改变其内部的驱动程序环形包裹。所以，在第二轮中，可用的描述符将有avail和used标志被清除，所以设备一旦包裹读取描述符，就必须轮询寻找这个条件。让我们来看看不同情况的完整例子。</p>
<blockquote>
<p>If we have a descriptor table with only two entries, the Driver Ring Wrap Counter is set, and it fills the descriptor table making available two buffers at the beginning of the operation, driver will reverse its internal wrap counter, so it will be clear (0). We have the next table:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>→</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Full two-entries descriptor table</strong></p>
</blockquote>
<p>如果我们有一个只有两个条目的描述符表，驱动环形缠绕计数器被设置，它填满描述符表，在操作开始时腾出两个缓冲区，驱动将扭转其内部缠绕计数器，所以它将是clear（0）。我们有下一个表。</p>
<blockquote>
<p>After that, the device realizes that has both descriptors with id #0 and #1 available: it knows that the driver had its wrap counter set when it wrote them, the avail flag is set on them, and the used one is clear on both. If device uses the descriptor with id #1, we have the Figure 8 descriptor table. The buffer #0 still belongs to the device!</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>→</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Using first buffer out of order</strong></p>
</blockquote>
<p>之后，设备意识到有两个ID为#0和#1的描述符是可用的：它知道驱动程序在写它们的时候设置了wrap计数器，它们的avail标志被设置，而且这两个描述符的used标志都是清零的。如果设备使用id为#1的描述符，我们就有了图8的描述符表。缓冲区#0仍然属于设备!</p>
<blockquote>
<p>Now the driver realize the buffer #1 has been used, since avail and used flags are the same (set) and match the device’s internal wrap counter at the moment it wrote it. If device now uses the buffer id #0, it will make the table look like this:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>→</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A|U</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Using second buffer out of order</strong></p>
</blockquote>
<p>现在驱动程序意识到1号缓冲区已经被使用了，因为avail和used标志是一样的（设置），并且与设备的内部wrap计数器在写的时候是一致的。如果设备现在使用缓冲区ID #0，它将使表看起来像这样。</p>
<blockquote>
<p>But there is a more interesting case: Starting from the “first buffer out of order” situation, the driver makes available the buffer #1 again. In that case, the descriptor table goes directly from the “first buffer” to the next figure, “Full two-entries descriptor table.”</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td>←</td>
</tr>
<tr>
<td>→</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Full two-entries descriptor table</strong></p>
</blockquote>
<p>但还有一种更有趣的情况。从 “第一个缓冲区失灵 “的情况开始，驱动程序再次提供了1号缓冲区。在这种情况下，描述符表直接从 “第一个缓冲区 “进入下一个图，”完整的两行描述符表”。</p>
<h3 id="Chained-descriptors-No-more-jumps"><a href="#Chained-descriptors-No-more-jumps" class="headerlink" title="Chained descriptors: No more jumps"></a>Chained descriptors: No more jumps</h3><blockquote>
<p>Chained descriptors work likewise: no need for the next field in the head (or subsequent) descriptor in the chain to search subsequent ones, since the latter always occupies the next position. However, while in the split used ring you only need to return as used the id of the head of the chain, in packed you only need to return the tail id.</p>
</blockquote>
<p>链式描述符的工作原理也是如此：不需要在链中的头部（或后续）描述符的下一个字段来搜索后续的描述符，因为后者总是占据着下一个位置。然而，在分割使用的环中，你只需要返回链头的id作为使用，而在打包中你只需要返回尾部的id。</p>
<blockquote>
<p>Back to the used ring, every time we use chained descriptors, we make the used idx lag regarding the avail idx. More than one descriptor mark as available to the device, but we only send one as used to the driver. While this is not a problem in the split ring, this would cause descriptor entry exhaustion in the packed version.</p>
</blockquote>
<p>回到已用环，每次我们使用链式描述符时，都会使已用idx滞后于可用idx。一个以上的描述符被标记为设备可用，但我们只把一个描述符作为已使用的描述符发送给驱动。虽然这在分割环中不是一个问题，但在打包版本中会导致描述符条目耗尽。</p>
<blockquote>
<p>The straightforward solution is to make the device mark as used every descriptor in the chain. However, this can be expensive, since we are modifying a shared area of memory, and could cause cache bounces.</p>
<p>However, the driver already knows the chain, so it can skip all the chain with only the last id. This is why we need to compare the used/avail pair with the driver/device Wrap Counter: after a jump, we wouldn’t know if the next descriptor has been made available in this driver’s round or in the next if we only have a binary available/used flag.</p>
</blockquote>
<p>直接的解决方案是让设备将链上的每个描述符都标记为已使用。然而，这可能是昂贵的，因为我们正在修改内存的共享区域，并可能导致缓存跳出。</p>
<p>然而，驱动程序已经知道了链，所以它可以跳过所有的链，只保留最后一个ID。这就是为什么我们需要将已用/可用对与驱动/设备的Wrap Counter进行比较：在跳转之后，如果我们只有一个二进制的可用/已用标志，我们就不知道下一个描述符是在这个驱动的回合中还是在下一个回合中被提供的。</p>
<blockquote>
<p>For example, in a four entries ring, the driver makes available the chain of three descriptors:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Three chained descriptors available</strong></p>
</blockquote>
<p>例如，在一个四项环中，驱动器提供了三个描述符的链。</p>
<blockquote>
<p>After that, the device discovers the chain (polling position 0) and marks it as used, overwriting only the position 0. It skips completely the positions 1 and 2. When the driver polls for used, it will skip them too, knowing that the chain was 3 descriptors long:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Using the descriptor chain</strong></p>
</blockquote>
<p>之后，设备会发现这个链（轮询位置0），并将其标记为已用，只覆盖位置0，完全跳过位置1和2。当驱动轮询已使用时，它也会跳过这些位置，因为它知道该链有3个描述符长。</p>
<blockquote>
<p>Now the driver produces another two descriptor long chain, and it has to take into account the wrapping:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Make available another descriptor chain</strong></p>
</blockquote>
<p>现在，驱动程序又产生了一个两根描述符的长链，它必须考虑到包装的问题。</p>
<blockquote>
<p>And the device marks it as used, so only the first descriptor in the chain (4th in the table) needs to be updated.</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Using another descriptor chain</strong></p>
<p>Although the next descriptor (2nd) seems like available, since the avail flag is different from the used one, the device knows that it is not because of knowing the internal Driver Wrap Counter: The right flag combination is avail clear, used set.</p>
</blockquote>
<p>而设备将其标记为已使用，所以只有链中的第一个描述符（表中的第四个）需要更新。</p>
<p>尽管下一个描述符（第2个）看起来是可用的，但由于avail标志与used标志不同，设备知道它不是，因为知道内部的Driver Wrap Counter。正确的标志组合是avail clear，used set。</p>
<h3 id="Indirect-descriptors-When-chains-are-not-enough"><a href="#Indirect-descriptors-When-chains-are-not-enough" class="headerlink" title="Indirect descriptors: When chains are not enough"></a>Indirect descriptors: When chains are not enough</h3><blockquote>
<p>Indirect descriptors work like in the split case. First, the driver allocates a table of indirect descriptors each with the same layout as the regular packed descriptors anywhere in memory. After that, it sets each descriptor in this indirect table to the buffer it wants to make available for the driver (steps 1-2), and inserts a descriptor in the virtqueue with the flag <code>VIRTQ_DESC_F_INDIRECT (0x4)</code> set (step 3). The descriptor’s address and length correspond to the indirect table’s ones.</p>
</blockquote>
<p>间接描述符的工作方式与分割情况类似。首先，驱动程序分配一个间接描述符表，每个描述符的布局与内存中任何地方的常规打包描述符相同。之后，它将这个间接表中的每个描述符设置为它想为驱动提供的缓冲区（步骤1-2），并在virtqueue中插入一个设置了标志VIRTQ_DESC_F_INDIRECT（0x4）的描述符（步骤3）。该描述符的地址和长度对应于间接表的那些。</p>
<blockquote>
<p>In packed layout buffers must come in order in the indirect table, and the ID field is completely ignored. Also, the only valid flag for them is <code>VIRTQ_DESC_F_WRITE</code>, others are reserved and ignored by the device. As usual, the driver will notify the device if the conditions for the notification are met (step 4).</p>
</blockquote>
<p>在打包布局中，缓冲区必须按顺序出现在间接表中，ID字段完全被忽略。另外，它们唯一有效的标志是VIRTQ_DESC_F_WRITE，其他的是保留的，被设备忽略。像往常一样，如果通知的条件得到满足，驱动程序将通知设备（步骤4）。</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-3.png" class="">

<p><strong>Diagram: Driver makes available a descriptor using a packed queue</strong></p>
<p>For example, the driver would need to allocate this 48 bytes table for a 3 descriptors indirect table:</p>
<table>
<thead>
<tr>
<th></th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>…</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>…</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>…</td>
<td>W</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Three descriptor long indirect packed table</strong></p>
<p>And if it introduces the indirect table the first in the descriptor table, assuming it is allocated in <code>0x83000000</code> address:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>48</td>
<td>0</td>
<td>A|I</td>
<td>←</td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Drivers makes an indirect table available</strong></p>
<p>After indirect buffer consumption, the device needs to return the indirect buffer id (0 in the example) in its used descriptor. The table looks like the return of the first buffer, except for the indirect (I) flag set:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>48</td>
<td>0</td>
<td>A|U|I</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Device makes an indirect table used</strong></p>
<p>After that, the device cannot access the memory table anymore unless the driver makes it available again, so the latter can free or reuse it.</p>
<h3 id="Notifications-how-to-manage-interruptions"><a href="#Notifications-how-to-manage-interruptions" class="headerlink" title="Notifications: how to manage interruptions?"></a>Notifications: how to manage interruptions?</h3><blockquote>
<p>Like in the used queue, each side of the communication maintains two identical structures used for controlling notifications between the device and the driver. The driver’s one is read-only by the device, and the device’s one is read-only by the driver.</p>
<p>The struct layout is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct pvirtq_event_suppress &#123; </span><br><span class="line">        le16 desc;</span><br><span class="line">        le16 flags; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Event suppression struct notification</strong></p>
</blockquote>
<p>就像在用过的队列中，通信的每一方都维护着两个相同的结构，用于控制设备和驱动之间的通知。驱动程序的那个结构是设备只读的，而设备的那个结构是驱动程序只读的。</p>
<blockquote>
<p>The member flags can take the values:</p>
<ul>
<li>0: Notifications are enabled</li>
<li>1: Notifications are disabled</li>
<li>2: Notifications are enabled for a specific descriptor, specified from the desc member.</li>
</ul>
<p>If flags value is 2, the other side will notify until the wrap counter matches the most significant bit of desc and the descriptor placed in the position desc discarding that bit is made used/available. For this mode to work, <code>VIRTIO_F_RING_EVENT_IDX</code> flag needs to be negotiated in Virtio device initialization: feature bits.</p>
<p>None of these mechanisms are 100% reliable, since the other side could have sent the notification already when we set the values, so expect it even when disable.</p>
<p>Note that, since the descriptor ring size is not being forced to be a power of two (comparing with the split version), the notification structure can fit in the same page as the descriptor table. This can be advantageous for some implementations.</p>
</blockquote>
<p>成员标志可以采取以下值。</p>
<ul>
<li>0: 通知被启用</li>
<li>1: 通知被禁用</li>
<li>2: 对一个特定的描述符启用通知，由desc成员指定。</li>
</ul>
<p>如果标志值为2，另一方将进行通知，直到wrap计数器与desc的最重要的位相匹配，并且放置在desc位置的描述符放弃该位而被使用/可用。为了使这种模式工作，VIRTIO_F_RING_EVENT_IDX标志需要在Virtio设备初始化中协商：特征位。</p>
<p>这些机制都不是100%可靠的，因为当我们设置这些值时，对方可能已经发送了通知，所以即使在禁用的情况下也要期待它。</p>
<p>请注意，由于描述符环的大小没有被强制为2的幂（与分裂版本相比），通知结构可以与描述符表放在同一页面中。这对某些实现来说是有利的。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><blockquote>
<p>In this series we have taken you through the different virtio data plane layouts and its virtqueues implementations. They are the means for virtio devices and virtio drivers to exchange information.</p>
<p>We start by covering the simpler and less optimized split virtqueue layout. This layout is relatively easy to implement and to debug thus it’s a good entry point for learning the virtio dataplane basics.</p>
<p>We then moved on to the packed virtqueue layout specified in virtio 1.1 which allows requests exchange using a more compact descriptor representation. This avoids all the overhead of scattering the data through memory, avoiding cache contention and reducing the PCI transactions in case of actual hardware.</p>
</blockquote>
<p>在这个系列中，我们已经带你了解了不同的virtio数据平面布局及其virtqueues的实现。它们是virtio设备和virtio驱动交换信息的手段。</p>
<p>我们首先介绍了更简单、更不优化的分离式virtqueue布局。这种布局相对容易实现和调试，因此它是学习virtio数据平面基础知识的一个很好的切入点。</p>
<p>然后，我们转向virtio 1.1中规定的打包式virtqueue布局，它允许使用更紧凑的描述符来交换请求。这避免了在内存中分散数据的所有开销，避免了缓存争用，并在实际硬件的情况下减少了PCI事务。</p>
<blockquote>
<p>We also covered a number of optimizations on top of both ring layouts which depends on the communication/device type or how each part is implemented. Mainly, they are oriented to reduce the communication overhead, both in notifications and in memory transactions. Virtio offers a simple protocol to communicate what features and optimizations support each side, so they can agree on how the data is going to be exchanged and is highly future-proof.</p>
</blockquote>
<p>我们还在这两个环状布局的基础上进行了一些优化，这取决于通信/设备类型或每个部分的实现方式。主要的是，它们的方向是减少通信开销，包括通知和内存事务。Virtio提供了一个简单的协议来沟通每一方支持哪些功能和优化，所以他们可以就数据的交换方式达成一致，并且是高度面向未来的。</p>
<blockquote>
<p>This series covered the essence of the virtio data plane and provided you with the tool to analyze and develop your own virtio device and drivers. It should be noted that this series summarizes the relevant sections from the virtio spec thus you should refer to the spec for additional information and see it as the source of truth.</p>
<p>In the next posts we will return to vDPA including the kernel framework, hands on blogs and vDPA in Kubernetes.</p>
</blockquote>
<p>这个系列涵盖了virtio数据平面的本质，并为你提供了分析和开发自己的virtio设备和驱动的工具。应该注意的是，这个系列总结了virtio规范中的相关部分，因此你应该参考规范以获得更多信息，并将其视为真理的来源。</p>
<p>在接下来的文章中，我们将回到vDPA，包括内核框架、实践博客和Kubernetes中的vDPA。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" data-id="cleh8xpaf0000urwb2g162srp" data-title="Packed virtqueue: How to reduce overhead with virtio" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-virtqueues-and-virtio-ring-how-the-data-travels" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/" class="article-date">
  <time class="dt-published" datetime="2023-02-22T15:48:33.000Z" itemprop="datePublished">2023-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>►<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/">Virtqueues and virtio ring: How the data travels</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>This post continues where the “<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">Virtio devices and drivers overview</a>“ leaves off. After we have explained the scenario in the previous post, we are reaching the main point: how does the data travel from the virtio-device to the driver and back?</p>
</blockquote>
<p>这篇文章继续 “Virtio设备和驱动概述 “的内容。在上一篇文章中，我们已经解释了这个场景，我们即将到达重点：数据如何从virtio设备到驱动，然后再返回？</p>
<h2 id="Buffers-and-notifications-The-work-routine"><a href="#Buffers-and-notifications-The-work-routine" class="headerlink" title="Buffers and notifications: The work routine"></a>Buffers and notifications: The work routine</h2><blockquote>
<p>As stated earlier, a virtqueue is just a queue of guest’s buffers that the host consumes, either reading them or writing to them. A buffer can be read-only or write-only from the device point of view, but never both.</p>
</blockquote>
<p>如前所述，virtqueue只是一个guest的缓冲区队列，主机消耗它们，要么读取它们，要么写入它们。从设备的角度来看，一个缓冲区可以是只读的，也可以是只写的，但绝不是两者都是。</p>
<blockquote>
<p>The descriptors can be chained, and the framing of the message can be spread whatever way is more convenient. For example, to spread a 2000 byte message in one single buffer or to use two 1000 byte buffers should be the same. </p>
</blockquote>
<p>描述符可以是链状的，消息的构架可以以任何更方便的方式传播。例如，将2000字节的信息分散在一个单一的缓冲区中，或使用两个1000字节的缓冲区，应该是一样的。</p>
<blockquote>
<p>Also, it provides driver to device notifications (doorbell) method, to signal that one or more buffers have been added to the queue, and vice-versa, devices can interrupt the driver to signal used buffers. It is up to the underlying driver to provide the right method to dispatch the actual notification, for example using PCI interruptions or memory writing: The virtqueue only standardizes the semantics of it.</p>
</blockquote>
<p>另外，它还提供了驱动程序到设备的通知（门铃）方法，以信号显示一个或多个缓冲区已被添加到队列中，反之亦然，设备可以中断驱动程序以信号显示已使用的缓冲区。这取决于底层驱动程序提供正确的方法来调度实际的通知，例如使用PCI中断或内存写入。virtqueue只是对它的语义进行了标准化。</p>
<blockquote>
<p>As stated before, the driver and the device can advise the other to not to emit notifications to reduce its dispatching overhead. Since this operation is asynchronous we will describe how to do so in further sections.</p>
</blockquote>
<p>如前所述，驱动和设备可以建议对方不要发出通知，以减少其调度开销。由于这个操作是异步的，我们将在后续章节中描述如何做到这一点。</p>
<h2 id="Split-virtqueue-the-beauty-of-simplicity"><a href="#Split-virtqueue-the-beauty-of-simplicity" class="headerlink" title="Split virtqueue: the beauty of simplicity"></a>Split virtqueue: the beauty of simplicity</h2><blockquote>
<p>The split virtqueue format separates the virtqueue into three areas, where each area is writable by either the driver or the device, but not both:</p>
<ul>
<li>Descriptor Area: used for describing buffers.</li>
<li>Driver Area: data supplied by driver to the device. Also called avail virtqueue.</li>
<li>Device Area: data supplied by device to driver. Also called used virtqueue.</li>
</ul>
</blockquote>
<p>split virtqueue格式将virtqueue分成三个区域，每个区域都可以被驱动或设备写入，但不能同时写入。</p>
<ul>
<li>描述符区：用于描述缓冲区。</li>
<li>驱动区：由驱动提供给设备的数据。也称为利用虚拟队列。</li>
<li>设备区：由设备提供给驱动的数据。也称为used virtqueue。</li>
</ul>
<blockquote>
<p>They need to be allocated in the driver’s memory for it to be able to access them in a straightforward way. Buffer addresses are stored from the driver’s point of view, and the device needs to perform an address translation. There are many ways for the device to access it depending on the latter nature:</p>
<ul>
<li>For an emulated device in the hypervisor (like qemu), the guest’s address is in its own process memory.</li>
<li>For other emulated devices like vhost-net or vhost-user, a memory mapping needs to be done, like POSIX shared memory. A file descriptor to that memory is shared through vhost protocol.</li>
<li>For a real device a hardware-level translation needs to be done, usually via IOMMU.</li>
</ul>
</blockquote>
<p>它们需要被分配到驱动程序的内存中，以便它能够直接访问它们。缓冲区地址从驱动程序的角度存储，设备需要进行地址转换。根据后者的性质，设备有很多方法可以访问它。</p>
<ul>
<li>对于管理程序中的仿真设备（如qemu），客户的地址在它自己的进程内存中。</li>
<li>对于其他仿真设备，如vhost-net或vhost-user，需要做一个内存映射，像POSIX共享内存一样。该内存的文件描述符是通过vhost协议共享的。</li>
<li>对于一个真实的设备，需要做一个硬件级的转换，通常是通过IOMMU。</li>
</ul>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig1.png" class="">

<p><strong>Shared memory with split ring elements</strong></p>
<h3 id="Descriptor-ring-Where-is-my-data"><a href="#Descriptor-ring-Where-is-my-data" class="headerlink" title="Descriptor ring: Where is my data?"></a>Descriptor ring: Where is my data?</h3><blockquote>
<p>The descriptor area (or descriptor ring) is the first one that needs to be understood. It contains an array of a number of guest addressed buffers and its length. Each descriptor also contains a set of flags indicating more information about it. For example, the buffer continues in another descriptor buffer if the 0x1 bit is set, and the buffer is write-only for the device if the bit 0x2 is set, and is read-only if it is clear.</p>
</blockquote>
<p>描述符区（或描述符环）是第一个需要被理解的。它包含一个由若干客体寻址的缓冲区和其长度组成的数组。每个描述符还包含一组标志，表示关于它的更多信息。例如，如果0x1位被设置，缓冲区在另一个描述符缓冲区中继续，如果0x2位被设置，缓冲区对设备来说是只写的，如果它被清除，则是只读的。</p>
<blockquote>
<p>This is the layout of a single descriptor. We will call leN for N bits in little endian format.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_desc</span> &#123;</span> </span><br><span class="line">        le64 addr;</span><br><span class="line">        le32 len;</span><br><span class="line">        le16 flags;</span><br><span class="line">        le16 next; <span class="comment">// Will explain this one later in the section &quot;Chained descriptors&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Split Virtqueue descriptor layout</strong></p>
</blockquote>
<p>这是一个单一描述符的布局。我们将调用leN来表示little endian格式的N位。</p>
<h3 id="Avail-ring-Supplying-data-to-the-device"><a href="#Avail-ring-Supplying-data-to-the-device" class="headerlink" title="Avail ring: Supplying data to the device"></a>Avail ring: Supplying data to the device</h3><blockquote>
<p>The next interesting structure is the driver area, or avail ring. Is the room where the driver places the descriptor (indexes) the device is going to consume. Note that placing a buffer here doesn’t mean that the device needs to consume immediately: virtio-net, for example, provides a bunch of descriptors for packet receiving that are only used by the device when a packet arrives, and are “ready to consume” until that moment.</p>
</blockquote>
<p>下一个有趣的结构是驱动区，或者说Avail环。是驱动程序放置设备要消耗的描述符（索引）的空间。注意，在这里放置缓冲区并不意味着设备需要立即消费：例如，virtio-net为数据包接收提供了一堆描述符，这些描述符只有在数据包到达时才会被设备使用，直到那一刻才会 “准备消费”。</p>
<blockquote>
<p>The avail ring has two important fields that only the driver can write and the device only can read them: idx and flags. The idx field indicates where the driver would put the next descriptor entry in the avail ring (modulo the queue size). On the other hand, the least significant bit of flags indicates if the driver wants to be notified or not (called <code>VIRTQ_AVAIL_F_NO_INTERRUPT</code>).</p>
</blockquote>
<p>avail环有两个重要的字段，只有驱动程序可以写入，设备只能读取它们：idx和flags。idx字段指出了驱动程序将把下一个描述符条目放在avail ring中的位置（modulo the queue size）。另一方面，flags的最小有效位表示驱动是否要被通知（称为<code>VIRTQ_AVAIL_F_NO_INTERRUPT</code>）。</p>
<blockquote>
<p>After these two fields, an array of integers of the same length as the descriptors ring. So the avail virtqueue layout is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_avail</span> &#123;</span></span><br><span class="line">        le16 flags;</span><br><span class="line">        le16 idx;</span><br><span class="line">        le16 ring[ <span class="comment">/* Queue Size */</span> ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Avail virtqueue layout</strong></p>
</blockquote>
<p>在这两个字段之后，是一个与描述符环相同长度的整数阵列。因此，avail virtqueue layout:</p>
<blockquote>
<p><strong>Figure 1</strong> shows a descriptor table with a 2000 bytes long buffer that starts in position 0x8000, and an avail ring that still does not have any entry. After all the steps, a components diagram highlighting the descriptor area update. The first step for the driver is to allocate the buffer with the memory and fill it (this is the step 1 in the “Process to make a buffer available” diagram), and to make available on the descriptor area after that (step 2).</p>
</blockquote>
<p>图1显示了一个具有2000字节长的缓冲区的描述符表，它从位置0x8000开始，而一个利用环仍然没有任何条目。在所有的步骤之后，一个组件图突出了描述符被更新的部分。驱动程序的第一步是分配缓冲区的内存并将其填满（这是 “使缓冲区可用的过程 “图中的第1步），然后在描述符区上使其可用（第2步）。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig2.png" class="">

<p><strong>Figure 1: Driver writes a buffer in descriptor ring</strong></p>
<blockquote>
<p>After populating descriptor entry, driver advises of it using the avail ring: It writes the descriptor index #0 in the first entry of the avail ring, and updates idx entry accordly. The result of this is shown in Figure 2. In the case that supply chained buffers, only the descriptor head index should be added this way, and avail idx would increase only by 1. This is the step 3 in the diagram.</p>
</blockquote>
<p>在填充完描述符条目后，驱动通知它使用空闲环。它将描述符的索引#0写在avail ring的第一个条目中，并相应地更新idx条目。其结果如图2所示。在提供链式缓冲区的情况下，只有描述符头部的索引应该这样添加，而avail idx只增加1。这就是图中的第三步。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig3.png" class="">

<p><strong>Figure 2: Driver offers the buffer with avail ring</strong></p>
<blockquote>
<p>From now on, the driver should not modify the available descriptor or the exposed buffer at any moment: It is under the device’s control. Now the driver needs to notify the device if the latter has enabled notifications at that moment (more on how the device manages this later). This is the last step 4 in the diagram.</p>
</blockquote>
<p>从现在开始，驱动程序不应该在任何时候修改可用的描述符或暴露的缓冲区。这是由设备控制的。现在，驱动程序需要通知设备，如果后者在当时启用了通知功能（后面会有更多关于设备如何管理的内容）。这就是图中的最后一步4。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig4.png" class="">

<p><strong>Diagram: Process to make a buffer available</strong></p>
<blockquote>
<p>The avail ring must be able to hold the same number of descriptors as the descriptor area, and the descriptor area must have a size power of two, so idx wraps naturally at some point. For example, if the ring size is 256 entries, idx 1 references the same descriptor as idx 257, 513… And it will wrap at a 16 bit boundary. This way, neither side needs to worry about processing an invalid idx: They are all valid.</p>
</blockquote>
<p>Avail环必须能够容纳与描述符区相同数量的描述符，描述符区的大小必须是2的幂，所以idx在某一点上自然会被包裹起来。例如，如果环的大小是256个条目，idx 1引用的描述符与idx 257、513…相同。而它将在16位边界处被包裹起来。这样一来，双方都不需要担心处理无效的idx。它们都是有效的。</p>
<blockquote>
<p>Note that descriptors can be added in any order to the avail ring, one does not need to start from descriptor table entry 0 nor continue by the next descriptor.</p>
</blockquote>
<p>请注意，描述符可以以任何顺序添加到利用环中，不需要从描述符表的第0条开始，也不需要从下一个描述符继续。</p>
<h3 id="Chained-descriptors-Supplying-large-data-to-the-device"><a href="#Chained-descriptors-Supplying-large-data-to-the-device" class="headerlink" title="Chained descriptors: Supplying large data to the device"></a>Chained descriptors: Supplying large data to the device</h3><blockquote>
<p>The driver can also chain more than one descriptor using its next member. If the NEXT (0x1) flag of a descriptor is set, the data continue in another buffer, making a chain of descriptors. Note that the descriptors in a chain do not share flags: Some descriptors can be read-only, and the others can be write-only. In this case, write-only descriptors must come after all write-only ones.</p>
</blockquote>
<p>驱动程序也可以使用其下一个成员来连锁一个以上的描述符。如果一个描述符的NEXT(0x1)标志被设置，数据在另一个缓冲区中继续，形成一个描述符链。注意，一个链中的描述符不共享标志。有些描述符可以是只读的，而其他描述符可以是只写的。在这种情况下，只写的描述符必须排在所有只写的描述符之后。</p>
<blockquote>
<p>For example, if the driver has sent us two buffers in a chain with descriptor table indexes 0 and 1 as first operation, the device would see the scenario in Figure 3, and it would be the step 2 again.</p>
</blockquote>
<p>例如，如果驱动程序在描述符表索引为0和1的链中向我们发送了两个缓冲区，作为第一次操作，设备会看到图3中的情景，它将再次成为步骤2。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig5.png" class="">

<p><strong>Figure 3: Device sees chained buffers</strong></p>
<h3 id="Used-ring-When-the-device-is-done-with-the-data"><a href="#Used-ring-When-the-device-is-done-with-the-data" class="headerlink" title="Used ring: When the device is done with the data"></a>Used ring: When the device is done with the data</h3><blockquote>
<p>The device employs the used ring to return the used (read or written) buffers to the driver. As the avail ring, it has the flags and idx members. They have the same layout and serve the same purpose, although the notification flag is now called <code>VIRTQ_USED_F_NO_NOTIFY</code>.</p>
</blockquote>
<p>设备使用使用过的环将使用过的（读或写）缓冲区返回给驱动。与avail环一样，它也有flags和idx成员。它们具有相同的布局和相同的目的，尽管通知标志现在被称为<code>VIRTQ_USED_F_NO_NOTIFY</code>。</p>
<blockquote>
<p>After them, it maintains an array of used descriptors. In this array, the device returns not only the descriptor index but also the used length in case of writing.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_used</span> &#123;</span></span><br><span class="line">        le16 flags;</span><br><span class="line">        le16 idx;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtq_used_elem</span> <span class="title">ring</span>[ /* <span class="title">Queue</span> <span class="title">Size</span> */];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_used_elem</span> &#123;</span></span><br><span class="line">        <span class="comment">/* Index of start of used descriptor chain. */</span></span><br><span class="line">        le32 id;</span><br><span class="line">        <span class="comment">/* Total length of the descriptor chain which was used (written to) */</span></span><br><span class="line">        le32 len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Used virtqueue layout</strong></p>
</blockquote>
<p>在它们之后，它维护一个已使用的描述符数组。在这个数组中，设备不仅返回描述符的索引，而且在写入的情况下返回已使用的长度。</p>
<blockquote>
<p>In case of returning a chain of descriptors, only the id of the head of the chain is returned, and the total written length through all descriptors, not increasing it when data is read. The descriptor table is not touched at all, it is read-only for the device. This is step 5 in the “Process to make a buffer as used” diagram.</p>
</blockquote>
<p>在返回描述符链的情况下，只返回链头的id，以及通过所有描述符的总写入长度，在读取数据时不增加它。描述符表完全不被触及，它对设备来说是只读的。这是 “制作使用的缓冲区的过程 “图中的第5步。</p>
<blockquote>
<p>For example, if the device uses the chain of descriptors exposed in the Chained descriptors version:</p>
</blockquote>
<p>例如，如果设备使用链式描述符版本中暴露的链式描述符:</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig6.png" class="">

<p><strong>Figure 4: Device returns buffer chain</strong></p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig7.png" class="">

<p><strong>Diagram: Process to mark a buffer as used</strong></p>
<blockquote>
<p>Lastly, the device will notify the driver if it sees that the driver wants to be notified, using the used queue flags to know it (step 6).</p>
</blockquote>
<p>最后，如果设备看到驱动想被通知，它将通知驱动，使用使用的队列标志来知道它（步骤6）。</p>
<h3 id="Indirect-descriptors-supplying-a-lot-of-data-to-the-device"><a href="#Indirect-descriptors-supplying-a-lot-of-data-to-the-device" class="headerlink" title="Indirect descriptors: supplying a lot of data to the device"></a>Indirect descriptors: supplying a lot of data to the device</h3><blockquote>
<p>Indirect descriptors are a way to dispatch a larger number of descriptors in a batch, increasing the ring capacity. The driver stores a table of indirect descriptors (the same layout as the regular descriptors) anywhere in memory, and inserts a descriptor in the virtqueue with the flag <code>VIRTQ_DESC_F_INDIRECT (0x4)</code> set. The descriptor’s address and length correspond to the indirect table’s ones.</p>
</blockquote>
<p>间接描述符是一种在一个批次中调度更多描述符的方法，增加了环的容量。驱动程序在内存的任何地方存储一个间接描述符表（与普通描述符的布局相同），并在virtqueue中插入一个描述符，并设置标志<code>VIRTQ_DESC_F_INDIRECT（0x4）</code>。该描述符的地址和长度对应于间接表的长度。</p>
<blockquote>
<p>If we want to add the chain described in section Chained descriptors to an indirect table, the driver first allocates the memory region of 2 entries (32 bytes) to hold the latter (step 2 in the diagram after allocate the buffers in the step 1):</p>
<table>
<thead>
<tr>
<th>Buffer</th>
<th>Len</th>
<th>Flags</th>
<th>Next</th>
</tr>
</thead>
<tbody><tr>
<td>0x8000</td>
<td>0x2000</td>
<td>W|N</td>
<td>1</td>
</tr>
<tr>
<td>0xD000</td>
<td>0x2000</td>
<td>W</td>
<td>…</td>
</tr>
</tbody></table>
<p><strong>Figure 4: Indirect table for indirect descriptors</strong></p>
</blockquote>
<p>如果我们想在一个间接表上添加链式描述符，驱动程序首先分配2个条目（32字节）的内存区域来容纳后者（图中的第2步，在第1步中分配了缓冲区之后）。</p>
<blockquote>
<p>Let’s suppose it has been allocated on memory position <code>0x2000</code>, and it is the first descriptor made available. As usual, the first step is to include it in the Descriptor area (step 3 in the diagram), so it would look like:</p>
<table>
<thead>
<tr>
<th>Descriptor Area</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Buffer</td>
<td>Len</td>
<td>Flags</td>
<td>Next</td>
</tr>
<tr>
<td>0x2000</td>
<td>32</td>
<td>I</td>
<td>…</td>
</tr>
</tbody></table>
<p><strong>Figure 5: Add indirect table to Descriptor area</strong></p>
</blockquote>
<p>让我们假设它被分配在内存位置<code>0x2000</code>，并且是第一个可用的描述符。像往常一样，第一步是把它纳入描述符区域（图中的第3步），所以它看起来像。</p>
<blockquote>
<p>After that, the steps are the same as with regular descriptors: The driver adds the index of the descriptor marked with the flag in the descriptor area to the avail ring (#0 in this case, step 4 in the diagram), and notify the device as usual (step 5).</p>
</blockquote>
<p>之后，步骤与普通描述符相同。驱动程序将描述符区域中标有标志的描述符的索引添加到利用环中（本例中为#0，图中第4步），并像往常一样通知设备（第5步）。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig8.png" class="">

<p><strong>Diagram: Driver make available indirect descriptors</strong></p>
<blockquote>
<p>For the device to use its data, and would use the same memory addresses to return its <code>0x3000</code> bytes (all <code>0x8000-0x9FFF</code> and <code>0xD000-0xDFFF</code>) (Step 6 and 7, same as with regular descriptors). Once used by the device, the driver can release the indirect memory or do whatever it wants with it, as it could do with any regular buffer.</p>
</blockquote>
<p>对于设备使用其数据，并将使用相同的内存地址来返回其0x3000字节（所有0x8000-0x9FFF和0xD000-0xDFFF）（步骤6和7，与常规描述符相同）。一旦被设备使用，驱动程序可以释放间接内存或对其做任何事情，就像它可以对任何常规缓冲区做的那样。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig9.png" class="">

<p><strong>Diagram: Device mark the indirect descriptor as used</strong></p>
<blockquote>
<p>Descriptors with <code>INDIRECT</code> flag cannot have <code>NEXT</code> or <code>WRITE</code> flags set, so you cannot chain indirect descriptors in the descriptor table, and the indirect table can contain at maximum the same number of descriptors as the descriptor table.</p>
</blockquote>
<p>带有INDIRECT标志的描述符不能设置NEXT或WRITE标志，所以不能在描述符表中连锁间接描述符，间接表最多可以包含与描述符表相同数量的描述符。</p>
<h3 id="Notifications-Learning-the-“do-not-disturb”-mode"><a href="#Notifications-Learning-the-“do-not-disturb”-mode" class="headerlink" title="Notifications. Learning the “do not disturb” mode"></a>Notifications. Learning the “do not disturb” mode</h3><blockquote>
<p>In many systems used and available buffer notifications involve significant overhead. To mitigate it, each virtring maintains a flag to indicate when it wants to be notified. Remember that the driver’s one is read-only by the device, and the device’s one is read-only by the driver.</p>
</blockquote>
<p>在许多系统中，使用的和可用的缓冲区通知涉及大量的开销。为了减轻它，每个virtring都维护着一个标志，以表明它什么时候想被通知。记住，驱动的那个是设备只读的，而设备的那个是驱动只读的。</p>
<blockquote>
<p>We already know all of this, and its use is pretty straightforward. The only thing you need to take care of is the asynchronous nature of this method: The side of the communication that disables or enables it can’t be sure that the other end is going to know the change, so you can miss notifications or to have more than expected.</p>
</blockquote>
<p>我们已经知道了这些，它的使用是非常直接的。你唯一需要注意的是这个方法的异步性。通信中禁用或启用它的一方不能确定另一端是否会知道这个变化，所以你可能会错过通知或要比预期的多。</p>
<blockquote>
<p>A more effective way of notifications toggle is enabled if the <code>VIRTIO_F_EVENT_IDX</code> feature bit is negotiated by device and driver: Instead of disable them in a binary fashion, driver and device can specify how far the other can progress before a notification is required using an specific descriptor id. This id is advertised using a extra le16 member at the end of the structure, so they grow like this:</p>
</blockquote>
<p>如果设备和驱动协商<code>VIRTIO_F_EVENT_IDX</code>特性位，就可以启用一种更有效的通知切换方式。而不是以二进制的方式禁用它们，驱动和设备可以使用一个特定的描述符id来指定对方在需要通知之前可以进展到什么程度。这个id在结构的末尾使用一个额外的le16成员进行宣传，所以它们的增长方式是这样的。</p>
<blockquote>
<p>The struct layout is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct virtq_avail &#123;              struct virtq_used &#123;</span><br><span class="line">  le16 flags;                       le16 flags;</span><br><span class="line">  le16 idx;                         le16 idx;</span><br><span class="line">  le16 ring[ &#x2F;* Queue Size *&#x2F; ];    struct virtq_used_elem ring[Q. size];</span><br><span class="line">  le16 used_event;                  le16 avail_event;</span><br><span class="line">&#125;;                                &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing 3: Event suppression struct notification</strong></p>
</blockquote>
<blockquote>
<p>This way, every time the driver wants to make available a buffer it needs to check the avail_event on the used ring: If driver’s idx field was equal to avail_event, it’s time to send a notification, ignoring the lower bit of used ring flags member (<code>VIRTQ_USED_F_NO_NOTIFY</code>).</p>
</blockquote>
<p>这样一来，每次驱动程序想要提供一个缓冲区时，它需要检查已用环上的avail_event。如果驱动的idx字段等于avail_event，那么就是发送通知的时候了，忽略已用环标志成员的低位（<code>VIRTQ_USED_F_NO_NOTIFY</code>）。</p>
<blockquote>
<p>Similarly, if <code>VIRTIO_F_EVENT_IDX</code> has been negotiated, the device will check used_event to know if it needs to send a notification or not. This can be very effective for maintaining a virtqueue of buffers for the device to write, like in the virtio-net device receive queue.</p>
</blockquote>
<p>同样，如果<code>VIRTIO_F_EVENT_IDX</code>已经协商好了，设备将检查used_event以知道它是否需要发送通知。这对于维护一个供设备写入的缓冲区的虚拟队列非常有效，就像在virtio-net设备接收队列中一样。</p>
<blockquote>
<p>In our next post, we’re going to wrap up and take a look at a number of optimizations on top of both ring layouts which depend on the communication/device type or how each part is implemented.</p>
</blockquote>
<p>在我们的下一篇文章中，我们将总结并看看在这两个环形布局之上的一些优化，这些优化取决于通信/设备类型或每个部分的实现方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/" data-id="clefunqbh0000l2wb9oyqhw88" data-title="Virtqueues and virtio ring: How the data travels" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arch-notes/">arch-notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/devops/">devops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/languages/">languages</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/languages/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/languages/python/">python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/memory-management/">memory management</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/management/">management</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-related-works/">project-related-works</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/">virtualization</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/cpu/">cpu</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/edk2-ovmf/">edk2-ovmf</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/kvm/">kvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/">translation</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/virtio/">virtio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/virtio-networking/">virtio-networking</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/v2v/">v2v</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/virtio-balloon/">virtio-balloon</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BSOD/" rel="tag">BSOD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPDK/" rel="tag">DPDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElementTree/" rel="tag">ElementTree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDP/" rel="tag">TDP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TLB/" rel="tag">TLB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code-reading/" rel="tag">code-reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/colo/" rel="tag">colo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/edk2-ovmf/" rel="tag">edk2-ovmf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ft/" rel="tag">ft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kvm/" rel="tag">kvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/live-migration/" rel="tag">live-migration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-balloon/" rel="tag">memory balloon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nessus/" rel="tag">nessus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nexus/" rel="tag">nexus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/others/" rel="tag">others</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/paper-reading/" rel="tag">paper-reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perf/" rel="tag">perf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/performance/" rel="tag">performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes/" rel="tag">reading notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software-arch/" rel="tag">software-arch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sysstat/" rel="tag">sysstat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/system-design/" rel="tag">system-design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/v2v/" rel="tag">v2v</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vDPA/" rel="tag">vDPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vhost-net/" rel="tag">vhost-net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virt/" rel="tag">virt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virt-top/" rel="tag">virt-top</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-balloon/" rel="tag">virtio-balloon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-net/" rel="tag">virtio-net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-networking/" rel="tag">virtio-networking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtualization/" rel="tag">virtualization</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BSOD/" style="font-size: 10px;">BSOD</a> <a href="/tags/DPDK/" style="font-size: 12.86px;">DPDK</a> <a href="/tags/ElementTree/" style="font-size: 10px;">ElementTree</a> <a href="/tags/TDP/" style="font-size: 11.43px;">TDP</a> <a href="/tags/TLB/" style="font-size: 10px;">TLB</a> <a href="/tags/architecture/" style="font-size: 18.57px;">architecture</a> <a href="/tags/code-reading/" style="font-size: 10px;">code-reading</a> <a href="/tags/colo/" style="font-size: 10px;">colo</a> <a href="/tags/cpu/" style="font-size: 12.86px;">cpu</a> <a href="/tags/edk2-ovmf/" style="font-size: 10px;">edk2-ovmf</a> <a href="/tags/ft/" style="font-size: 11.43px;">ft</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 12.86px;">java</a> <a href="/tags/kernel/" style="font-size: 14.29px;">kernel</a> <a href="/tags/kvm/" style="font-size: 15.71px;">kvm</a> <a href="/tags/libvirt/" style="font-size: 12.86px;">libvirt</a> <a href="/tags/linux/" style="font-size: 17.14px;">linux</a> <a href="/tags/live-migration/" style="font-size: 10px;">live-migration</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/memory-balloon/" style="font-size: 10px;">memory balloon</a> <a href="/tags/nessus/" style="font-size: 10px;">nessus</a> <a href="/tags/nexus/" style="font-size: 10px;">nexus</a> <a href="/tags/others/" style="font-size: 10px;">others</a> <a href="/tags/paper-reading/" style="font-size: 10px;">paper-reading</a> <a href="/tags/perf/" style="font-size: 10px;">perf</a> <a href="/tags/performance/" style="font-size: 11.43px;">performance</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/qemu/" style="font-size: 20px;">qemu</a> <a href="/tags/reading-notes/" style="font-size: 10px;">reading notes</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/software-arch/" style="font-size: 12.86px;">software-arch</a> <a href="/tags/sysstat/" style="font-size: 10px;">sysstat</a> <a href="/tags/system-design/" style="font-size: 12.86px;">system-design</a> <a href="/tags/v2v/" style="font-size: 10px;">v2v</a> <a href="/tags/vDPA/" style="font-size: 10px;">vDPA</a> <a href="/tags/vhost-net/" style="font-size: 17.14px;">vhost-net</a> <a href="/tags/virt/" style="font-size: 14.29px;">virt</a> <a href="/tags/virt-top/" style="font-size: 10px;">virt-top</a> <a href="/tags/virtio/" style="font-size: 17.14px;">virtio</a> <a href="/tags/virtio-balloon/" style="font-size: 10px;">virtio-balloon</a> <a href="/tags/virtio-net/" style="font-size: 17.14px;">virtio-net</a> <a href="/tags/virtio-networking/" style="font-size: 17.14px;">virtio-networking</a> <a href="/tags/virtualization/" style="font-size: 10px;">virtualization</a> <a href="/tags/windows/" style="font-size: 10px;">windows</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/12/06/2023-12-06/">The disk in the guest OS is unmounted during the kernel startup process.</a>
          </li>
        
          <li>
            <a href="/2023/05/26/understanding-cpu-topology-for-improved-performance/">Understanding CPU Topology for Improved Performance</a>
          </li>
        
          <li>
            <a href="/2023/04/27/virtio-memory-balloon/">Understand virtio memory balloon</a>
          </li>
        
          <li>
            <a href="/2023/04/13/qemu-colo-details/">Qemu Colo Details</a>
          </li>
        
          <li>
            <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">KVM虚拟化性能分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a></br>
      
      &copy; 2023 Alan Jager<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = '' == true;
    var verify = 'false' == true;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "r30r51B3r5JFqlxR88Jua6So-gzGzoHsz",
        appKey: "wnL9j38siXbLqBHGnWpzmVxv",
        placeholder: "Just go go",
        pageSize:'10',
        avatar:'mm',
        lang:'zh-cn'
    });
</script>

  </div>
</body>
</html>