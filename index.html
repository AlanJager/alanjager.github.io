<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Ëä±„ÅÆÊßò„Å´</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ëä±„ÅÆÊßò„Å´">
<meta property="og:url" content="http://hanayo.cn/index.html">
<meta property="og:site_name" content="Ëä±„ÅÆÊßò„Å´">
<meta property="og:locale">
<meta property="article:author" content="Alan Jager">
<meta property="article:tag" content="„Éñ„É≠„Ç∞">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Ëä±„ÅÆÊßò„Å´" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ëä±„ÅÆÊßò„Å´</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanayo.cn"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-virtio-memory-balloon" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/27/virtio-memory-balloon/" class="article-date">
  <time class="dt-published" datetime="2023-04-27T06:20:37.000Z" itemprop="datePublished">2023-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/virtio-balloon/">virtio-balloon</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/27/virtio-memory-balloon/">Understand virtio memory balloon</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Virtio memory ballooning is a technique that adjusts memory allocation in virtualized environments. The hypervisor can add or remove memory from a virtual machine based on demand, using a balloon driver in the guest operating system. When demand is high, the balloon driver inflates and the guest operating system releases memory. When demand is low, the balloon driver deflates and the guest operating system can use more memory.</p>
<p>This technique optimizes memory usage and reduces the risk of memory exhaustion, making it useful in cloud computing environments. However, it also has trade-offs to consider. Inflating the balloon driver can cause performance issues if the guest operating system can‚Äôt release memory quickly enough. It may also struggle with high memory pressure. Understanding these limitations is key to making informed decisions about using virtio memory ballooning.</p>
<h2 id="Overview-of-Virtio-Memory-Ballooning"><a href="#Overview-of-Virtio-Memory-Ballooning" class="headerlink" title="Overview of Virtio Memory Ballooning"></a>Overview of Virtio Memory Ballooning</h2><p>Based on wiki <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_ballooning">memory ballooning</a> is a technique used to eliminate the need to overprovision host memory used by a virtual machine. To implement it, the virtual machine‚Äôs kernel implements a ‚Äúballoon driver‚Äù which allocates unused memory within the VM‚Äôs address space into a reserved memory pool (the ‚Äúballoon‚Äù) so that it is unavailable to other processes on the VM. However, rather than being reserved for other uses within the VM, the physical memory mapped to those pages within the VM is actually unmapped from the VM by the host operating system‚Äôs hypervisor, making it available for other uses by the host machine. Depending on the amount of memory required by the VM, the size of the ‚Äúballoon‚Äù may be increased or decreased dynamically, mapping and unmapping physical memory as required by the VM.</p>
<p>According to the Virtio v1.2 specification, Virtio Memory Ballooning follows the Virtio protocol. Including:</p>
<h3 id="Feature-bits"><a href="#Feature-bits" class="headerlink" title="Feature bits"></a>Feature bits</h3><ul>
<li><strong>VIRTIO_BALLOON_F_MUST_TELL_HOST (0):</strong> Host must be notified before balloon pages are used.</li>
<li><strong>VIRTIO_BALLOON_F_STATS_VQ (1):</strong> A virtqueue is present for reporting guest memory statistics.</li>
<li><strong>VIRTIO_BALLOON_F_DEFLATE_ON_OOM (2):</strong> Balloon deflates when guest is out of memory.</li>
<li><strong>VIRTIO_BALLOON_F_FREE_PAGE_HINT (3):</strong> The device supports free page hinting. The configuration field <em>free_page_hint_cmd_id</em> is valid.</li>
<li><strong>VIRTIO_BALLOON_F_PAGE_POISON (4):</strong> The driver will immediately write <em>poison_val</em> to pages after deflating them. The configuration field <em>poison_val</em> is valid.</li>
<li><strong>VIRTIO_BALLOON_F_PAGE_REPORTING (5):</strong> The device supports free page reporting. A virtqueue is present for reporting free guest memory.</li>
</ul>
<h3 id="Memory-Statistics-Tags"><a href="#Memory-Statistics-Tags" class="headerlink" title="Memory Statistics Tags"></a>Memory Statistics Tags</h3><ul>
<li><strong>VIRTIO_BALLOON_S_SWAP_IN (0)</strong>: Amount of memory swapped in (in bytes).</li>
<li><strong>VIRTIO_BALLOON_S_SWAP_OUT (1)</strong>: Amount of memory swapped out to disk (in bytes).</li>
<li><strong>VIRTIO_BALLOON_S_MAJFLT (2)</strong>: Number of major page faults that have occurred.</li>
<li><strong>VIRTIO_BALLOON_S_MINFLT (3)</strong>: Number of minor page faults that have occurred.</li>
<li><strong>VIRTIO_BALLOON_S_MEMFREE (4)</strong>: Amount of memory not being used (in bytes).</li>
<li><strong>VIRTIO_BALLOON_S_MEMTOT (5)</strong>: Total amount of memory available (in bytes).</li>
<li><strong>VIRTIO_BALLOON_S_AVAIL (6)</strong>: Estimate of available memory (in bytes) for starting new applications.</li>
<li><strong>VIRTIO_BALLOON_S_CACHES (7)</strong>: Amount of memory (in bytes) that can be quickly reclaimed without I/O.</li>
<li><strong>VIRTIO_BALLOON_S_HTLB_PGALLOC (8)</strong>: Number of successful hugetlb page allocations in the guest.</li>
<li><strong>VIRTIO_BALLOON_S_HTLB_PGFAIL (9)</strong>: Number of failed hugetlb page allocations in the guest.</li>
</ul>
<h3 id="Free-page-hinting"><a href="#Free-page-hinting" class="headerlink" title="Free page hinting"></a>Free page hinting</h3><p>Free page hinting is used during migration to determine which pages within the guest are not being used. These pages are then skipped over while migrating the guest. The device will indicate it is ready to start hinting by setting the <em>free_page_hint_cmd_id</em> to one of the non-reserved values that can be used as a command ID. The driver is notified of the following reserved values:</p>
<ul>
<li>VIRTIO_BALLOON_CMD_ID_STOP (0): any previously supplied command ID is invalid. The driver should stop hinting free pages until a new command ID is supplied, but should not release any hinted pages for use by the guest.</li>
<li>VIRTIO_BALLOON_CMD_ID_DONE (1): any previously supplied command ID is invalid. The driver should stop hinting free pages and release all hinted pages for use by the guest.</li>
</ul>
<p>When a hint is provided, it indicates that the data contained in the given page is no longer needed and can be discarded. If the driver writes to the page, this overrides the hint and the data will be retained. Any stale pages that have not been written to since the page was hinted may lose their content. If read, the contents of such pages will be uninitialized memory.</p>
<h3 id="Page-Poison"><a href="#Page-Poison" class="headerlink" title="Page Poison"></a>Page Poison</h3><p>Page Poison is a feature that lets the host know when the guest is initializing free pages with <em>poison_val</em>. When enabled, the driver immediately writes to pages after deflating and pages reported as free will retain <em>poison_val</em>. If the guest is not initializing freed pages, the driver should reject the VIRTIO_BALLOON_F_PAGE_POISON feature. If the feature has been negotiated, the driver will place the initialization value into the <em>poison_val</em> configuration field data.</p>
<h3 id="Free-Page-Reporting"><a href="#Free-Page-Reporting" class="headerlink" title="Free Page Reporting"></a>Free Page Reporting</h3><p>Free Page Reporting is a method similar to balloon inflation, but without a deflation queue. Reported free pages can be reused by the driver after the request is acknowledged, without notifying the device.</p>
<p>The driver initiates reporting by gathering free pages into a scatter-gather list, which is then added to the reporting_vq. The exact timing and selection of free pages is determined by the driver.</p>
<p>Once the driver has enough pages available, it sends a reporting request to the device, which acknowledges the request using the reporting_vq descriptor. After acknowledgement, the driver can reuse the reported free pages by returning them to the free page lists in the guest operating system.</p>
<p>The driver can continue to gather and report free pages until it has reached the desired number of pages.</p>
<h2 id="Comparison-to-Other-Memory-Management-Techniques"><a href="#Comparison-to-Other-Memory-Management-Techniques" class="headerlink" title="Comparison to Other Memory Management Techniques"></a>Comparison to Other Memory Management Techniques</h2><p>Virtio memory ballooning is just one of several memory management techniques available in virtualized environments. Here are some other techniques that are commonly used:</p>
<h3 id="Overcommitment"><a href="#Overcommitment" class="headerlink" title="Overcommitment"></a>Overcommitment</h3><p>Overcommitment is a technique that allows virtual machines to use more memory than physically available. This is useful when memory demand is highly variable. However, overcommitment can cause performance issues if the host system runs out of memory and needs to swap memory pages to disk.</p>
<p>KVM hypervisor automatically overcommits CPUs and memory. This means that more virtualized CPUs and memory can be allocated to virtual machines than there are physical resources. This saves system resources, resulting in less power, cooling, and investment in server hardware while still allowing under-utilized virtualized servers or desktops to run on fewer hosts.</p>
<h3 id="Memory-Compression"><a href="#Memory-Compression" class="headerlink" title="Memory Compression"></a>Memory Compression</h3><p>Memory compression compresses memory pages to free up memory in high demand situations. However, this technique can lead to performance problems if the compression algorithm is slow or if memory demand is high.</p>
<p>Zram, zcache, and zswap advance in-kernel compression in different ways. Zram and zcache, both found in the staging tree, have improved in design and implementation, but they are not stable enough for promotion into the core kernel. Zswap proposes a simplified frontswap-only fork of zcache for direct merging into the MM subsystem. While simpler than zcache, zswap is entirely dependent on still-in-staging zsmalloc and has limitations. If zswap is merged, it remains to be seen if it will ever be extended adequately.</p>
<h3 id="Hypervisor-Swapping"><a href="#Hypervisor-Swapping" class="headerlink" title="Hypervisor Swapping"></a>Hypervisor Swapping</h3><p>Hypervisor swapping is a technique in which the hypervisor swaps memory pages between the host and guest operating systems in order to optimize memory usage. This can be useful in situations where there is a high demand for memory or when the host system is running low on memory. However, hypervisor swapping can also lead to performance issues if the guest operating system can‚Äôt release memory quickly enough.</p>
<p>Compared to these techniques, virtio memory ballooning has some unique advantages. It optimizes memory usage within the guest operating system itself, reducing the risk of memory exhaustion and improving performance. However, it also has some trade-offs to consider, such as the potential for performance issues if the guest operating system can‚Äôt release memory quickly enough.</p>
<h2 id="How-to-use-Virtio-Memory-Ballooning-on-linux"><a href="#How-to-use-Virtio-Memory-Ballooning-on-linux" class="headerlink" title="How to use Virtio Memory Ballooning on linux"></a>How to use Virtio Memory Ballooning on linux</h2><h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p>On host side we use libvirt to setup a vm.</p>
<p>The memory tag means: The maximum allocation of memory for the guest at boot time.</p>
<p>The currentMemory tag means: The actual allocation of memory for the guest.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">maxMemory</span> <span class="attr">slots</span>=<span class="string">&#x27;16&#x27;</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>1524288<span class="tag">&lt;/<span class="name">maxMemory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>8388608<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">currentMemory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>8388608<span class="tag">&lt;/<span class="name">currentMemory</span>&gt;</span></span><br></pre></td></tr></table></figure>

<aside>
üí° The maxMemory tag means: the run time maximum memory allocation of the guest. The initial memory specified by either the <memory> element or the NUMA cell size configuration can be increased by hot-plugging of memory to the limit specified by this element.

</aside>

<p>And add memballoon virtio device in vm xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">memballoon</span> <span class="attr">model</span>=<span class="string">&#x27;virtio&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>To use Virtio Memory Ballooning on Linux guest, you‚Äôll need to ensure that your kernel has support for the virtio_balloon driver. You can check for this by running the following command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep virtio_balloon</span><br></pre></td></tr></table></figure>

<aside>
üí° If you want to test pm_sleep make sure CONFIG_PM_SLEEP is enabled

</aside>

<p>If the virtio_balloon driver is not listed, you may need to load it manually by running the following command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe virtio_balloon</span><br></pre></td></tr></table></figure>

<p>We can do some test to confirm balloon driver is working:</p>
<h3 id="Basic-usage"><a href="#Basic-usage" class="headerlink" title="Basic usage"></a>Basic usage</h3><p>Explaination from </p>
<p><a target="_blank" rel="noopener" href="https://github.com/libvirt/libvirt/blob/master/docs/manpages/virsh.rst">libvirt/virsh.rst at master ¬∑ libvirt/libvirt</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh dommemstat YOUR_VM_NAME          </span></span><br><span class="line">actual 8388608          <span class="comment"># Current balloon value (in KB)</span></span><br><span class="line">swap_in 7011156         <span class="comment"># The amount of data read from swap space (in kB)</span></span><br><span class="line">swap_out 664776         <span class="comment"># The amount of memory written out to swap space (in kB)</span></span><br><span class="line">major_fault 234565      <span class="comment"># The number of page faults where disk IO was required</span></span><br><span class="line">minor_fault 84722778    <span class="comment"># The number of other page faults</span></span><br><span class="line">unused 6291308          <span class="comment"># The amount of memory left unused by the system (in kB)</span></span><br><span class="line">available 8388044       <span class="comment"># The amount of usable memory as seen by the domain (in kB)</span></span><br><span class="line">usable 6349618          <span class="comment"># The amount of memory which can be reclaimed by balloon without causing host swapping (in KB) *</span></span><br><span class="line">last_update 1682566755  <span class="comment"># Timestamp of the last update of statistics (in seconds)</span></span><br><span class="line">disk_caches 116620      <span class="comment"># The amount of memory that can be reclaimed without additional I/O, typically disk caches (in KiB)</span></span><br><span class="line">rss 8529188             <span class="comment"># Resident Set Size of the running domain&#x27;s process (in kB)</span></span><br></pre></td></tr></table></figure>

<p>with memory balloon we can get details about guest usage which matches the Memory Statistics Tags we metioned above.</p>
<p>And from dominfo we can see the memory usage directly</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh dominfo YOUR_VM_NAME</span></span><br><span class="line">Id:             7</span><br><span class="line">Name:           1970b0ef25e44adc834767fe81f155d5</span><br><span class="line">UUID:           1970b0ef-25e4-4adc-8347-67fe81f155d5</span><br><span class="line">OS Type:        hvm</span><br><span class="line">State:          running</span><br><span class="line">CPU(s):         4</span><br><span class="line">CPU time:       214084.1s</span><br><span class="line">Max memory:     8388608 KiB</span><br><span class="line">Used memory:    8388608 KiB</span><br><span class="line">Persistent:     yes</span><br><span class="line">Autostart:      <span class="built_in">disable</span></span><br><span class="line">Managed save:   no</span><br><span class="line">Security model: none</span><br><span class="line">Security DOI:   0</span><br></pre></td></tr></table></figure>

<h3 id="Shrinking-memory"><a href="#Shrinking-memory" class="headerlink" title="Shrinking memory"></a>Shrinking memory</h3><p>At first, check the unused memory of your guest</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh dommemstat YOUR_VM_NAME | grep unused</span></span><br><span class="line">unused 2868704</span><br></pre></td></tr></table></figure>

<p>then we try to set memory to a size we want</p>
<p>Simply, </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use actual - unused = 8388608 - 2868704 = 5519904</span><br></pre></td></tr></table></figure>

<p>Then we use setmem</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh setmem YOUR_VM_NAME --size 5519904KiB --current</span></span><br></pre></td></tr></table></figure>

<p>Check the shrink take effects:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh dommemstat YOUR_VM_NAME</span></span><br><span class="line">actual 5519904</span><br><span class="line">swap_in 0</span><br><span class="line">swap_out 2592</span><br><span class="line">major_fault 6236</span><br><span class="line">minor_fault 181380396</span><br><span class="line">unused 140212</span><br><span class="line">available 5139400</span><br><span class="line">usable 3424496</span><br><span class="line">last_update 1682567978</span><br><span class="line">rss 5583008</span><br></pre></td></tr></table></figure>

<p>actual changed to 5519904 and we check the guest on the other side</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># free -hm</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           4.9G        862M        134M        299M        3.9G        3.3G</span><br><span class="line">Swap:          7.9G        3.5M        7.9G</span><br></pre></td></tr></table></figure>

<p>Total memory changed even smaller than 5519904 ~= 5.26G about 7% memory missing and almost same with available 5139400</p>
<aside>
üí° Qemu level vm statistics may different from the statistics inside guest.

</aside>

<h3 id="Expanding-memory"><a href="#Expanding-memory" class="headerlink" title="Expanding memory"></a><strong><strong>Expanding</strong></strong> memory</h3><p>To increase the memory allocation of a virtual machine using virtio memory ballooning, you can use the <code>virsh setmem</code> command. For example, to increase the memory allocation to 8GB, you would run:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh setmem YOUR_VM_NAME --size 8G --current</span><br></pre></td></tr></table></figure>

<p>This will increase the memory allocation of the virtual machine to 8GB. However, it‚Äôs important to note that the guest operating system must have support for virtio memory ballooning in order to take advantage of this feature.</p>
<p>In addition, it‚Äôs important to monitor the memory usage of virtual machines to ensure that they have enough memory to operate effectively. This can be done using tools like <code>virsh dommemstat</code> to monitor memory usage statistics.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh dommemstat YOUR_VM_NAME</span></span><br><span class="line">actual 8388608</span><br><span class="line">swap_in 0</span><br><span class="line">swap_out 2592</span><br><span class="line">major_fault 6236</span><br><span class="line">minor_fault 181827159</span><br><span class="line">unused 3008116</span><br><span class="line">available 8008104</span><br><span class="line">usable 6293140</span><br><span class="line">last_update 1682571788</span><br><span class="line">rss 7545844</span><br></pre></td></tr></table></figure>

<aside>
üí° Unused memory after increase may not changed right now, wait for a minute to see its changes.

</aside>

<p>Inside guest</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># free -hm</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.6G        862M        2.9G        299M        3.9G        6.0G</span><br><span class="line">Swap:          7.9G        3.5M        7.9G</span><br></pre></td></tr></table></figure>

<p>With 8GB memory from qemu side, guest have total 7.6G memory. There is still a 5% missing.</p>
<h2 id="Industry-Practices"><a href="#Industry-Practices" class="headerlink" title="Industry Practices"></a>Industry Practices</h2><h3 id="Proxmox"><a href="#Proxmox" class="headerlink" title="Proxmox"></a>Proxmox</h3><p><a target="_blank" rel="noopener" href="https://pve.proxmox.com/wiki/Dynamic_Memory_Management">Dynamic memory management</a> shows that KSM and memory balloon works on windows and linux guest, a memory range from min and max will be required and guest‚Äôs memory will dynamicly changed between the range to impelement memory ballooning.</p>
<h3 id="Google-cloud"><a href="#Google-cloud" class="headerlink" title="Google cloud"></a>Google cloud</h3><p><a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/dynamic-resource-management">Dynamic resource management</a> Memory ballooning is an interface mechanism between host and guest to dynamically adjust the size of the reserved memory for the guest. A¬†<a target="_blank" rel="noopener" href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html#x1-2790005">virtio memory balloon device</a>¬†<br>¬†is used to implement memory ballooning. Through the virtio memory balloon device, a host can explicitly ask a guest to yield a certain amount of free memory pages (also called memory balloon inflation), and reclaim the memory so that the host can use the free memory for other VMs. Likewise, the virtio memory balloon device can return memory pages back to the guest by deflating the memory balloon.</p>
<p>Compute Engine E2 VM instances that are based on a¬†<a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/images#os-compute-support">public image</a><br>¬†have a¬†<a target="_blank" rel="noopener" href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html#x1-2790005">virtio memory balloon device</a>¬†, which monitors the guest operating system‚Äôs memory use. The guest operating system communicates its available memory to the host system. The host reallocates any unused memory to other processes on demand, thereby using memory more effectively. Compute Engine collects and uses this data to make more accurate¬†<a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/instances/apply-machine-type-recommendations-for-instances">rightsizing recommendations</a>.</p>
<p>In¬†<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_kernel_version_history">Linux kernels</a>¬†before 5.2, the Linux memory system sometimes mistakenly prevents large allocations when the balloon device is present. This is rarely an issue in practice, but we recommend changing the virtual memory¬†<code>overcommit_memory</code>¬†setting to¬†<code>1</code>¬†to prevent the issue from occurring. This change is already made by default in all Google-provided images published since February 9, 2021.</p>
<p>To fix the setting, use the following command to change the value from¬†<code>0</code>¬†to¬†<code>1</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;sbin&#x2F;sysctl -w vm.overcommit_memory&#x3D;1</span><br></pre></td></tr></table></figure>

<p>To persist this change across reboots, add the following to your¬†<code>/etc/sysctl.conf</code>¬†file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.overcommit_memory&#x3D;1</span><br></pre></td></tr></table></figure>

<h3 id="Nutanix"><a href="#Nutanix" class="headerlink" title="Nutanix"></a>Nutanix</h3><p><a target="_blank" rel="noopener" href="https://www.nutanix.dev/2022/05/05/squeeze-even-more-out-of-your-hci/">Squeeze even more memory of your HCI</a> </p>
<p>Memory overcommit allows more memory to be assigned to VMs than is physically present in the server hardware. Unused memory allocated to a VM can be reclaimed by the hypervisor and made available to other VMs on the host. AHV adjusts memory usage for each VM according to its usage, allowing the host to use excess memory to satisfy the requirements of other VMs. This reduces hardware costs for large deployments or increases the utilization of an existing environment that can‚Äôt be immediately expanded with new nodes. VMs without memory overcommit will operate with their pre-assigned memory, and can coexist with overcommit enabled VMs. Nutanix uses a multi-tier approach combining ballooning and hypervisor-level swap to optimize performance. Metrics are presented to the administrator in Prism Central to indicate the gains achieved through overcommit and its impact on VM performance. Memory overcommit may not be appropriate for performance-sensitive workloads due to its dynamic nature.</p>
<p><a target="_blank" rel="noopener" href="https://portal.nutanix.com/page/documents/details?targetId=AHV-Admin-Guide-v6_1:ahv-vm-limitations-memory-overcommit-c.html">Limits of Memory Overcommit</a></p>
<p>Memory overcommit has the following limitations:</p>
<ul>
<li>You can enable or disable Memory Overcommit only while the VM is powered off.</li>
<li>Power off the VM enabled with memory overcommit before you change the memory allocation for the VM.<br>For example, you cannot update the memory of a VM that is enabled with memory overcommit when it is still running. The system displays the following alert:¬†InvalidVmState: Cannot complete request in state on.</li>
<li>Memory overcommit is not supported with VMs that use GPU passthrough and vNUMA.<br>For example, you cannot update a VM to a vNUMA VM when it is enabled with memory overcommit. The system displays the following alert:¬†InvalidArgument: Cannot use memory overcommit feature for a vNUMA VM error.</li>
<li>Memory overcommit feature can slow down the performance and the predictable performance of the VM<br>For example, migrating a VM enabled with Memory Overcommit takes longer than migrating a VM not enabled with Memory Overcommit.</li>
<li>There may be a temporary spike in the aggregate memory usage in the cluster during the migration of a VM enabled with Memory Overcommit from one node to another.<br>For example, when you migrate a VM from Node A to Node B, the total memory used in the cluster during migration is greater than the memory usage before the migration.<br>The memory usage of the cluster eventually drops back to pre-migration levels when the cluster reclaims the memory for other VM operations.</li>
<li>Using Memory Overcommit heavily can cause a spike in the disk space utilization in the cluster. This spike is caused because the Host Swap uses some of the disk space in the cluster.<br>If the VMs do not have a swap disk, then in case of memory pressure, AHV uses space from the swap disk created on ADSF to provide memory to the VM. This can lead to an increase in disk space consumption on the cluster.</li>
<li>All DR operations except Cross Cluster Live Migration (CCLM) are supported<br>On the destination side, if a VM fails when you enable Memory Overcommit, the failed VM fails over (creating the VM on the remote site) as a fixed size VM. You can enable Memory Overcommit on this VM after the failover is complete.</li>
</ul>
<h2 id="Limitations-and-Challenges"><a href="#Limitations-and-Challenges" class="headerlink" title="Limitations and Challenges"></a>Limitations and Challenges</h2><p>Guest should support virtio memory ballooning, if the balloon driver not available there is no effective way to do it.</p>
<table>
<thead>
<tr>
<th>Distribution</th>
<th>No Balloon Driver</th>
<th>Partially Supported</th>
<th>Fully Supported</th>
</tr>
</thead>
<tbody><tr>
<td>CentOS</td>
<td>6.1, 6.2</td>
<td>6.3‚Äì6.9, 7.1, 7.2</td>
<td>7.3‚Äì7.7, 8.0‚Äì8.2</td>
</tr>
<tr>
<td>Oracle</td>
<td>7.3</td>
<td>7.4, 7.5</td>
<td>7.6, 7.7</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>See note.</td>
<td>12.04</td>
<td>14.04 and newer</td>
</tr>
</tbody></table>
<aside>
üí° Some Ubuntu versions have a working balloon driver but it may be disabled by default.

</aside>

<p>Not all situations are suitable for memory ballooning. Frequent expansion and contraction of memory can be harmful if the memory usage changes dynamically.</p>
<h2 id="Future-Development"><a href="#Future-Development" class="headerlink" title="Future Development"></a>Future Development</h2><p><a target="_blank" rel="noopener" href="https://www.linux-kvm.org/page/Projects/auto-ballooning">https://www.linux-kvm.org/page/Projects/auto-ballooning</a> The auto ballooning project was initiated in 2013. The hypervisor and Linux kernel need to be updated to support the project, which has not been upstreamed yet.</p>
<h2 id="Real-World-Implementation-Case-Study"><a href="#Real-World-Implementation-Case-Study" class="headerlink" title="Real-World Implementation Case Study"></a>Real-World Implementation Case Study</h2><ul>
<li><strong><strong><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=r1wxgLTG40g">Lessons Learned Building a Production Memory-Overcommit Solution</a></strong></strong></li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Virtualization is important in modern computing for flexible and efficient resource allocation. Memory management is challenging in virtualized environments when multiple virtual machines run on a single physical server. Virtio memory ballooning optimizes memory usage by dynamically adjusting guest memory reservation. It improves performance and reduces the risk of memory exhaustion. This article explains how to use virtio memory ballooning on Linux, compares it to other memory management techniques, and discusses industry practices, limitations, and future developments.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/libvirt/libvirt/blob/master/docs/manpages/virsh.rst">libvirt/virsh.rst at master ¬∑ libvirt/libvirt</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html#x1-2790005">virtio-v1.1-csprd01/virtio-v1.1-csprd01.html#x1-2790005</a></li>
<li><a target="_blank" rel="noopener" href="https://pve.proxmox.com/wiki/Dynamic_Memory_Management">Dynamic memory management</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/dynamic-resource-management">Dynamic resource management</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nutanix.dev/2022/05/05/squeeze-even-more-out-of-your-hci/">Squeeze even more memory of your HCI</a></li>
<li><a target="_blank" rel="noopener" href="https://portal.nutanix.com/page/documents/details?targetId=AHV-Admin-Guide-v6_1:ahv-vm-limitations-memory-overcommit-c.html">Limits of Memory Overcommit</a></li>
<li><a target="_blank" rel="noopener" href="https://www.linux-kvm.org/page/Projects/auto-ballooning">https://www.linux-kvm.org/page/Projects/auto-ballooning</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=r1wxgLTG40g">Lessons Learned Building a Production Memory-Overcommit Solution</a></li>
</ul>
<p>Powered by Notion AI</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/04/27/virtio-memory-balloon/" data-id="clgyqlnf10000ayca8dho589n" data-title="Understand virtio memory balloon" class="article-share-link">Share</a>
      
      
        <a href="/2023/04/27/virtio-memory-balloon/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/04/27/virtio-memory-balloon/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memory-balloon/" rel="tag">memory balloon</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-qemu-colo-details" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/13/qemu-colo-details/" class="article-date">
  <time class="dt-published" datetime="2023-04-13T15:49:38.000Z" itemprop="datePublished">2023-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/13/qemu-colo-details/">Qemu Colo Details</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="qemu-quorum-block-filter"><a href="#qemu-quorum-block-filter" class="headerlink" title="qemu quorum block filter"></a>qemu quorum block filter</h2><p>Based on the code design of blkverify.c and blkmirror.c, the main purpose is to mirror write requests to all the qcow images hanging in the quorum, and the read operation is to check whether the number of occurrences of the qiov version meets the value set by the threshold through the parameters set by the threshold. Then it returns the &gt; value of the result with the highest number of occurrences, if the number of occurrences i is less than the threshold then it returns the quourm exception and the read operation returns -EIO.</p>
<p>The main use of this feature is for people who use NFS devices affected by bitflip errors.</p>
<p>If you set the read-pattern to FIFO and set the threshold to 1, you can construct a read-only first disk scenario.</p>
<h2 id="block-replication"><a href="#block-replication" class="headerlink" title="block-replication"></a>block-replication</h2><p>The micro checkpoint and COLO mentioned in the introduction to the QEMU FT solution will continuously create checkpoints, and the state of the pvm and svm will be the same at the moment the checkpoint is completed. But it will not be consistent until the next checkpoint.</p>
<p>To ensure consistency, the SVM changes need to be cached and discarded at the next checkpoint. To reduce the stress of network transfers between checkpoints, changes on the PVM disk are synchronized asynchronously to the SVM node.</p>
<p>For example, the first time VM1 does a checkpoint, it is recorded as state C1, then VM2‚Äôs state is also C1, at this time VM2‚Äôs disk changes start to cache, VM1‚Äôs changes are written to VM2‚Äôs node through this mechanism, if an error occurs at this time how should it be handled?</p>
<p>Suppose we discuss the simplest case of VM1 hanging, then because the next checkpoint has not yet been executed, VM2 continues to run the state of C1 for a period of time and the disk changes are cached, at this time it is only necessary to flush the cached data to VM2‚Äôs disk single point to continue to run or wait for FT reconstruction, which is the reason for the need to do SVM disk changes caching (here the data (including two copies, one is to restore to VM2 last checkpoint cache, the other is to VM2 in C1 after the cache of changes)</p>
<p>The following is the structure of block-replication:</p>
<img src="/2023/04/13/qemu-colo-details/fig1.png" class="">

<ol>
<li>The block device on the primary node mounts two sub-devices via quorum, providing backup from the primary node to the secondary host. The read pattern (FIFO) is extended to meet the situation where the primary node will only read the local disk (the threshold needs to be set to 1 so that read operations will only be performed locally)</li>
<li>A newly implemented filter called replication is responsible for controlling block replication</li>
<li>The secondary node receives disk write requests from the primary node through the embedded nbd server</li>
<li>The device on the secondary node is a custom block device, we call it an active disk. it should be an empty device at the beginning, but the block device needs to support bdrv_make_empty() and backing_file</li>
<li>The hidden-disk is created automatically, and this file caches the contents modified by what is written from the primary node. It should also be an empty device at the beginning and support bdrv_make_empty() and backing_file</li>
<li>The blockdev-backup job (sync=none) will synchronize all the contents of the hidden-disk cache that should have been overwritten by nbd-induced writes, so the primary and secondary nodes should have the same disk contents before the replication starts</li>
<li>The secondary node also has a quorum node, so that the secondary can become the new primary after the failover and continue to perform the replication</li>
</ol>
<p>There are seven types of internal errors that can exist when block replication runs:</p>
<ol>
<li>Primary disk I/O errors</li>
<li>Primary disk forwarding errors</li>
<li>blockdev-backup error</li>
<li>secondary disk I/O errors</li>
<li>active disk I/O error</li>
<li>Error clearing hidden disk and active disk</li>
<li>failover failure</li>
</ol>
<p>For error 1 and error 5, just report block level errors directly upwards.</p>
<p>For 2, 3, 4, and 6 need to be reported to the control plane of FT for failover process control.</p>
<p>In the case of 7, if the active commit fails, it will prompt a secondary node write operation error and let the person performing the failover decide how to handle it.</p>
<h2 id="colo-checkpoint"><a href="#colo-checkpoint" class="headerlink" title="colo checkpoint¬†"></a>colo checkpoint¬†</h2><p>colo uses vm‚Äôs live migration to achieve the checkpoint function</p>
<p>Based on the above block-replication to achieve disk synchronization, the other part is how to synchronize the running state data of virtual machines, here directly using the existing live migration, that is, cloud host hot migration, so that after each checkpoint can be considered pvm and svm disk/memory are consistent, so need to be in This event depends on the time of live migration.</p>
<p>First, let‚Äôs organize the checkpoint process, which is divided into two major parts</p>
<h3 id="Configuration-phase"><a href="#Configuration-phase" class="headerlink" title="Configuration phase"></a>Configuration phase</h3><p>This part will be executed mainly when the colo is first set up, we know that by default at the beginning we will configure the disk synchronization of pvm and svm, but the memory is not actually synchronized yet, so at the beginning we will ask the svm to be pused at first after the startup, and then submit two synchronization operations from the pvm side</p>
<ol>
<li>Submit the drive-mirror task to mirror the contents of the disk from the pvm to the remote svm‚Äôs disk (embedded nbd is used here, which is also the target disk of the block replicaton later) to ensure that the pvm‚Äôs contents are consistent with the svm‚Äôs</li>
<li>Submit a migration task to synchronize memory from pvm to svm, and since both pvm and svm are required to be paired at this point, you actually wait until both pvm and svm are synchronized, then you need to cancel the drive-mirror task, start block replication, and continue running vm<br>Of course, the paused state mentioned in 2 has been changed to be similar to hot migration after the improvements made by intel. After the drive-mirror task is submitted, the id of the task and the information of the block replication disks are used as parameters for the colo migration, which will actually be automatically changed when migrating in the line of online migration. After the migration is completed, the drive-mirror task is automatically cancelled and block-replication is automatically started before running vm, which simplifies the steps a lot.</li>
</ol>
<p>After the configuration, you need to manually issue a migrate command to the colo pvm, and the checkpoint will enter the cycle of monitoring after the first migrate.</p>
<img src="/2023/04/13/qemu-colo-details/fig2.png" class="">

<h3 id="Start-the-checkpoint"><a href="#Start-the-checkpoint" class="headerlink" title="Start the checkpoint"></a>Start the checkpoint</h3><p>The checkpoint mechanism consists mainly of a loop, and the code flow of qemu is as follows:</p>
<img src="/2023/04/13/qemu-colo-details/fig3.png" class="">

<p>Combined with this picture we explain the more important parts inside</p>
<h4 id="Process-phase"><a href="#Process-phase" class="headerlink" title="Process phase"></a>Process phase</h4><p>COLO-FT initializes some key variables such as migration status, FAILOVER status and listens to the internal checkpoint notify (triggered from COLO compare)</p>
<p>After the first successful migrate, the discount state is initialized and the migration state is changed to COLO</p>
<p>After receiving a request for a checkpoint, a series of checkpoint creation processes are performed</p>
<h4 id="Colo-Status"><a href="#Colo-Status" class="headerlink" title="Colo Status"></a>Colo Status</h4><p>For the COLO-FT virtual machine, there are two important states</p>
<p>One is the MigrationState, which on the COLO-FT virtual machine is MIGRATION_STATUS_COLO corresponding to the string ‚ÄúCOLO‚Äù, which is a prerequisite state to allow checkpointing, and the cloud host must have established the COLO-FT mechanism. FT mechanism, that is, through the above configuration phase to complete the configuration and the first checkpoint, will enter this state and the main loop</p>
<p>Another state is failover_state, which is a global variable defined in colo_failover.c, which is accessed by colo.c through failover_get_state(), and this parameter is set to FAILOVER_STATUS at the start of the checkpoint loop _NONE, which means that failover is not needed. The bottom half of qemu mounts the mechanism for modifying this state, so it can be triggered by user state commands, so you need to pay attention to whether failover is triggered or not when actually doing checkpoint</p>
<h4 id="Communitaion"><a href="#Communitaion" class="headerlink" title="Communitaion"></a>Communitaion</h4><p>COLO communicates through messages to get the status of the SVM, as well as to send and confirm the start and completion of the checkpoint, and the message process inside has the following main steps</p>
<ol>
<li>Sending COLO_MESSAGE_CHECKPOINT_REQUEST</li>
<li>After the SVM receives the message, pause the SVM and send COLO_MESSAGE_CHECKPOINT_READY</li>
<li>PVM starts saving and live migration of VMSTATE</li>
<li>SVM gets the migrated information and does the CPU synchronization and VM state LOAD locally.</li>
<li>SVM will wait for a check message from PVM after the migration is completed, and PVM will send a message after the live migration is completed.</li>
<li>PVM sends COLO_MESSAGE_VMSTATE_SIZE with the size of VMSTATE sent via QIOChannelBuffer</li>
<li>SVM receives the message and checks if the size received locally is the same as the size sent, if it is, it replies COLO_MESSAGE_VMSTATE_RECEIVED</li>
<li>After confirming the VMSTATE transfer, the SVM will do some migration and subsequent synchronization and cleanup.</li>
<li>After completion, the SVM executes vm_start() and sends COLO_MESSAGE_VMSTATE_LOADED.</li>
<li>After the PVM receives the message that the SVM has successfully loaded, the PVM will also execute vm_start().</li>
</ol>
<p>The logic of suspend, migrate and resume the operation of PVM SVM is realized through the message collaboration between PVM and SVM</p>
<img src="/2023/04/13/qemu-colo-details/fig4.png" class="">

<p>Existing problems, because the current checkpoint are notified to each other through the message, once the corresponding packet is sent and not returned, the next wait may always exist, can not be closed, assuming that at this time from the bottom half (bottom half) to send a request also did not do to clean up the wait state.</p>
<p>It should be noted that: the default checkpoint once the failure occurs, the vm will be a direct exit, requiring the rebuilding of COLO-FT, so the establishment of COLO-FT failure needs to be analyzed from two parts</p>
<p>Whether the configuration phase migration has failed<br>Whether the configuration is complete (migration has become colo state) but the checkpoint failed (the above process failed) resulting in COLO-FT exit</p>
<h3 id="colo-proxy"><a href="#colo-proxy" class="headerlink" title="colo proxy"></a>colo proxy</h3><p>colo proxy as the core component of COLO-FT, this article mainly focuses on the functionality of colo proxy in QEMU</p>
<p>When QEMU implements the net module, it actually treats the actual device in the guest as a receiver, so the corresponding relationship is as follows</p>
<p>TX RX</p>
<p>qemu side network device (sender) ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-‚Üí guest inside driver (receiver)</p>
<p>Combined with the code, the filter will be executed before actually doing transimission, and then go to sender processing.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NetQueue *queue;</span><br><span class="line">size_t size &#x3D; iov_size(iov, iovcnt);</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">if (size &gt; NET_BUFSIZE) &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (sender-&gt;link_down || !sender-&gt;peer) &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Let filters handle the packet first *&#x2F;</span><br><span class="line">ret &#x3D; filter_receive_iov(sender, NET_FILTER_DIRECTION_TX, sender,</span><br><span class="line">                         QEMU_NET_PACKET_FLAG_NONE, iov, iovcnt, sent_cb);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret &#x3D; filter_receive_iov(sender-&gt;peer, NET_FILTER_DIRECTION_RX, sender,</span><br><span class="line">                         QEMU_NET_PACKET_FLAG_NONE, iov, iovcnt, sent_cb);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &#x3D; sender-&gt;peer-&gt;incoming_queue;</span><br><span class="line"></span><br><span class="line">return qemu_net_queue_send_iov(queue, sender,</span><br><span class="line">                               QEMU_NET_PACKET_FLAG_NONE,</span><br><span class="line">                               iov, iovcnt, sent_cb);</span><br></pre></td></tr></table></figure>

<p>The filter-mirror and filter-redirect in the network-filter implemented by colo act as the forwarding function of the proxy</p>
<p>The classic process for a network card is as follows:</p>
<img src="/2023/04/13/qemu-colo-details/fig5.png" class="">

<p>The host device receives the network packet and sends it to the guest</p>
<ol>
<li>First execute the first filter-mirror, for qemu is transimission, so execute mirror action, the network packet mirror a copy sent off through outdev (chardev), and then call the next filter (because it is TX, so other filters will not be executed, so pvm on (the packet is sent directly to the guest)</li>
<li>SVM‚Äôs indev connects to PVM‚Äôs mirror‚Äôs outdev (via socket), so it receives the packet sent by 1. The filter does not specify an outdev after receiving the packet, so it calls the next filter directly</li>
<li>SVM calls filter-rewrite, the direction of this filter is ALL, so the packets to and from SVM will be processed by this filter, if the target is sent, because it is sent to VM so the first direction is TX, COLO will record the various states of this TCP packet</li>
<li>Because there is no next filter so it is sent to the qemu network device, and then take the process of sending to the guest</li>
<li>From the guest to the qemu network packet, the direction is RX so the filter processing order will be reversed and sent to the rewrite first</li>
<li>SVM calls filter-rewrite this time in the direction of RX, so when processing, it will process the tcp packets returned by SVM, compare the input and output of tcp packets through the tcp packets table, and if the processing fails, it will put the packet in the queue and resend it again (note: need to continue deeper analysis), and then the filter- redirector</li>
<li>Also in the PVM mirror filter, because there is no subsequent TX filter, the packet is sent directly to the qemu net device and then to the PVM guest.</li>
<li>The packets coming out of the PVM guest will be sent to the primary in interface of the colo-compare thing by filter-redirector because it is in the RX direction, so some filters will be performed in the reverse direction</li>
<li>SVM will send the return of SVM to the secondary in interface of colo-compare of PVM via redirector‚Äôs outdev<br>colo-compare receives the packet and starts to do the relevant analysis to decide whether checkpoint is needed</li>
<li>The filter-redirector‚Äôs indev receives the return from colo-compare after comparison and forwards it to the host net device via outdev</li>
</ol>
<p>This is the end of a complete packet processing process.</p>
<p>Since colo-compare is responsible for comparing pvm and svm packets, there are some metrics that need to be understood</p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>payload_size = total size - header_size i.e. the size of the whole packet minus the length of the header</p>
<p>packet data offset packet header size after the distance and payload_size comparison is consistent</p>
<p>The following is a summary of what needs to be done here</p>
<p>The logic of colo-compare comparison is organized:</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>Compare whether the payloads are the same. If it is the same and the ack is the same then it is over. If it is the same but the ack of pvm is larger than the ack of svm, the packet sent to svm is dropped and the packet of pvm will not be sent (meaning sent back to the host NIC). So we will record the maximum ack in the current queue (both pvm and svm queues) until the ack exceeds the smaller of the two maximum ack values, and we can ensure that the packet payload is confirmed by both sides</td>
</tr>
<tr>
<td>UDP</td>
<td>only palyload checked</td>
</tr>
<tr>
<td>ICMP</td>
<td>only palyload checked</td>
</tr>
<tr>
<td>Other</td>
<td>only packet size checked</td>
</tr>
</tbody></table>
<p>Possible reasons for network packet loss are therefore:</p>
<ol>
<li>colo-compare did not receive the packet correctly</li>
<li>svm‚Äôs redirector did not successfully forward packets to rewrite</li>
<li>mirror did not replicate the packet successfully</li>
<li>pvm‚Äôs redirector did not successfully send pvm‚Äôs return to colo-compare</li>
<li>svm‚Äôs rewrite did not send/receive packets successfully</li>
<li>colo-compare is not sending packets correctly</li>
<li>svm‚Äôs redirector did not successfully forward packets to colo-compare</li>
</ol>
<p>Problem processing</p>
<p>The processing of 1 mainly relies on the colo compare mechanism itself, for tcp packets will determine whether there are subsequent packets returned by ack, if there are subsequent packets, it means that the previous is missed</p>
<p>2 If the packet is not successfully sent to rewrite, it will not be processed by svm, so finally colo compare will encounter the situation where pvm has a packet but svm does not have a packet, and the processing is similar to 1</p>
<p>3 If mirror does not successfully copy the package, then there will also be a situation similar to 1, pvm exists package, svm no package</p>
<p>4 if pvm redirector did not successfully send the packet, then it seems from colo compare is pvm lost packets, but the same 1 processing, will wait for the pvm and svm minimum ack is exceeded, that is, both pvm or svm even if packet loss occurs, colo compare will wait for the updated packet to appear before returning the packet otherwise will always card does not reverse the current packet</p>
<p>5 If rewritte‚Äôs send-receive fails, this situation will cause the svm to not receive the packet and not return, similar to 1, but if failover occurs at this time, the svm packet is lost</p>
<p>6 this exception will lead to colo send and receive packet exceptions, network anomalies, not very well handled because itself colo compare is the core component</p>
<p>7 similar situation svm seems to have replied or actively sent the packet, but because colo compare did not receive, resulting in the svm within the data that did not reply, the benefit is that if the subsequent failover can occur, rewrite because the packet was recorded, will send the packet again, then it seems to be working again (need to test)</p>
<h3 id="Trigger-checkpoint"><a href="#Trigger-checkpoint" class="headerlink" title="Trigger checkpoint"></a>Trigger checkpoint</h3><p>There are two conditions for triggering from colo-comare, because COLO-FT will establish a notification mechanism when it is established, and colo compare will trigger checkpoint from inside actively through this mechanism</p>
<ol>
<li>Checkpoint will be triggered if the payload of the compare tcp packet is inconsistent</li>
<li>Timed to check if there is a certain period of time but has not received the same return packet (i.e., pvm, svm packet chain table content is inconsistent) trigger checkpoint</li>
<li>If there is a packet in the pvm list but not in the secondary packet, then it means that the packet reply is late, this situation is handled by 2, if the comparison finds that the non-tcp packet comparison is inconsistent will trigger a checkpoint</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/04/13/qemu-colo-details/" data-id="clgfbjhl80000e7wb9imx6mfo" data-title="Qemu Colo Details" class="article-share-link">Share</a>
      
      
        <a href="/2023/04/13/qemu-colo-details/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/04/13/qemu-colo-details/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/colo/" rel="tag">colo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ft/" rel="tag">ft</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-KVMËôöÊãüÂåñÊÄßËÉΩÂàÜÊûê" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2023-03-13T14:36:38.000Z" itemprop="datePublished">2023-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/kvm/">kvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">KVMËôöÊãüÂåñÊÄßËÉΩÂàÜÊûê</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>KVMËôöÊãüÂåñÊòØ‰∏ÄÁßçÂ∏∏Áî®ÁöÑËôöÊãüÂåñÊäÄÊúØÔºåÂÆÉÂèØ‰ª•Â∞Ü‰∏ÄÂè∞Áâ©ÁêÜÊúçÂä°Âô®ÂàíÂàÜ‰∏∫Â§ö‰∏™ËôöÊãüÊú∫Ôºå‰ªéËÄåÊèêÈ´òÊúçÂä°Âô®ÁöÑÂà©Áî®ÁéáÂíåÁÅµÊ¥ªÊÄß„ÄÇÁÑ∂ËÄåÔºåÁî±‰∫éËôöÊãüÂåñÂ∏¶Êù•ÁöÑÈ¢ùÂ§ñÂºÄÈîÄÔºåKVMËôöÊãüÂåñÁöÑÊÄßËÉΩÈóÆÈ¢òÊòØ‰∏Ä‰∏™Â∏∏ËßÅÁöÑÊåëÊàò„ÄÇ‰∏∫‰∫ÜËß£ÂÜ≥Ëøô‰∫õÈóÆÈ¢òÔºåÊàë‰ª¨ÈúÄË¶Å‰ΩøÁî®‰∏Ä‰∫õÊÄßËÉΩËØäÊñ≠Â∑•ÂÖ∑Êù•ÂàÜÊûêÂíå‰ºòÂåñKVMËôöÊãüÂåñÁöÑÊÄßËÉΩ„ÄÇ</p>
<p>‰ª•‰∏ãÊòØ‰∏Ä‰∫õÂ∏∏Áî®ÁöÑKVMËôöÊãüÂåñÊÄßËÉΩËØäÊñ≠Â∑•ÂÖ∑Ôºö</p>
<h2 id="Perf"><a href="#Perf" class="headerlink" title="Perf"></a>Perf</h2><p>PerfÊòØ‰∏ÄÁßçLinuxÊÄßËÉΩÂàÜÊûêÂ∑•ÂÖ∑ÔºåÂèØ‰ª•Áî®‰∫éÁõëËßÜÁ≥ªÁªüÊÄßËÉΩÂíåË∞ÉËØïÊÄßËÉΩÈóÆÈ¢ò„ÄÇÂÆÉÂü∫‰∫éLinuxÂÜÖÊ†∏Êèê‰æõÁöÑÊÄßËÉΩ‰∫ã‰ª∂Êé•Âè£ÔºåÂπ∂Êèê‰æõ‰∫Ü‰∏Ä‰∏™ÂëΩ‰ª§Ë°åÁïåÈù¢ÔºåÂèØ‰ª•Áî®‰∫éÁõëËßÜCPU‰ΩøÁî®Áéá„ÄÅÂÜÖÂ≠ò‰ΩøÁî®ÊÉÖÂÜµ„ÄÅÁ£ÅÁõòI/OÁ≠âÊÄßËÉΩÊåáÊ†á„ÄÇ</p>
<p>‰ª•‰∏ãÊòØ‰ΩøÁî®PerfËøõË°åKVMËôöÊãüÂåñÊÄßËÉΩÂàÜÊûêÁöÑÊúÄ‰Ω≥ÂÆûË∑µÔºö</p>
<ol>
<li>ÂÆâË£ÖPerf</li>
</ol>
<p>Ë¶ÅÂÆâË£ÖPerfÔºåËØ∑‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Ôºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-tools-common linux-tools-generic linux-tools-&#96;uname -r&#96;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Êî∂ÈõÜPerfÊï∞ÊçÆ</li>
</ol>
<p>Ë¶Å‰ΩøÁî®PerfÊî∂ÈõÜÊÄßËÉΩÊï∞ÊçÆÔºåËØ∑‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Ôºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -g -p &#96;pidof qemu-system-x86_64&#96; -F 99</span><br></pre></td></tr></table></figure>

<p>Âú®Ëøô‰∏™‰æãÂ≠ê‰∏≠Ôºå-gÈÄâÈ°πË°®Á§∫Êî∂ÈõÜÂáΩÊï∞Ë∞ÉÁî®ÂõæÔºàÁî®‰∫éÁîüÊàêFlame GraphÔºâÔºå-pÈÄâÈ°πË°®Á§∫ÁõëËßÜqemu-system-x86_64ËøõÁ®ãÔºå-FÈÄâÈ°πË°®Á§∫‰ΩøÁî®99HzÁöÑÈááÊ†∑È¢ëÁéáÊù•Êî∂ÈõÜÊÄßËÉΩÊï∞ÊçÆ„ÄÇ</p>
<ol start="3">
<li>ÁîüÊàêFlame Graph</li>
</ol>
<p>Ë¶ÅÁîüÊàêFlame GraphÔºåËØ∑‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Ôºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf script | stackcollapse-perf.pl | flamegraph.pl &gt; output.svg</span><br></pre></td></tr></table></figure>

<p>Âú®Ëøô‰∏™‰æãÂ≠ê‰∏≠Ôºåperf scriptÂëΩ‰ª§Â∞ÜPerfÊï∞ÊçÆËΩ¨Êç¢‰∏∫ËÑöÊú¨ËæìÂá∫Ôºåstackcollapse-perf.plÂëΩ‰ª§Â∞ÜËÑöÊú¨ËæìÂá∫ËΩ¨Êç¢‰∏∫ÊäòÂè†Ê†àÔºåflamegraph.plÂëΩ‰ª§Â∞ÜÊäòÂè†Ê†àËΩ¨Êç¢‰∏∫Flame Graph„ÄÇÊúÄÁªàÁöÑFlame GraphÂ∞Ü‰øùÂ≠òÂú®output.svgÊñá‰ª∂‰∏≠„ÄÇ</p>
<h2 id="Sysstat"><a href="#Sysstat" class="headerlink" title="Sysstat"></a>Sysstat</h2><p>SysstatÊòØ‰∏Ä‰∏™LinuxÁ≥ªÁªüÊÄßËÉΩÁõëÊéßÂ∑•ÂÖ∑ÔºåÂèØ‰ª•Áî®‰∫éÁõëËßÜCPU„ÄÅÂÜÖÂ≠ò„ÄÅÁ£ÅÁõòI/OÁ≠âÊÄßËÉΩÊåáÊ†á„ÄÇÂú®KVMËôöÊãüÂåñ‰∏≠ÔºåÊÇ®ÂèØ‰ª•‰ΩøÁî®SysstatÊù•ÁõëËßÜËôöÊãüÊú∫ÁöÑÊÄßËÉΩ„ÄÇ‰ª•‰∏ãÊòØ‰ΩøÁî®SysstatËøõË°åKVMËôöÊãüÂåñÊÄßËÉΩÂàÜÊûêÁöÑÊúÄ‰Ω≥ÂÆûË∑µÔºö</p>
<ol>
<li>ÂÆâË£ÖSysstat</li>
</ol>
<p>Ë¶ÅÂÆâË£ÖSysstatÔºåËØ∑‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Ôºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install sysstat</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ÈÖçÁΩÆSysstat</li>
</ol>
<p>Ë¶ÅÈÖçÁΩÆSysstatÔºåËØ∑ÁºñËæë/etc/default/sysstatÊñá‰ª∂ÔºåÂπ∂Êõ¥Êîπ‰ª•‰∏ãÂèòÈáèÔºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HISTORY&#x3D;7</span><br><span class="line">INTERVAL&#x3D;60</span><br></pre></td></tr></table></figure>

<p>Âú®Ëøô‰∏™‰æãÂ≠ê‰∏≠ÔºåSysstatÂ∞ÜÊØè1ÂàÜÈíüÊî∂ÈõÜ‰∏ÄÊ¨°ÊÄßËÉΩÊï∞ÊçÆÔºåÂπ∂Â∞ÜÊï∞ÊçÆ‰øùÂ≠òÊúÄËøë7Â§©„ÄÇ</p>
<ol start="3">
<li>ÂàÜÊûêSysstatÊï∞ÊçÆ</li>
</ol>
<p>SysstatÊî∂ÈõÜÁöÑÊï∞ÊçÆ‰øùÂ≠òÂú®/var/log/sysstatÁõÆÂΩï‰∏ã„ÄÇÊÇ®ÂèØ‰ª•‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Êù•Êü•ÁúãSysstatÊï∞ÊçÆÔºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sar -u</span><br><span class="line">sar -r</span><br><span class="line">sar -b</span><br><span class="line">sar -d</span><br></pre></td></tr></table></figure>

<p>Ëøô‰∫õÂëΩ‰ª§Â∞ÜÂàÜÂà´ÊòæÁ§∫CPU‰ΩøÁî®Áéá„ÄÅÂÜÖÂ≠ò‰ΩøÁî®ÊÉÖÂÜµ„ÄÅÁ£ÅÁõòI/OÁ≠âÊÄßËÉΩÊï∞ÊçÆ„ÄÇ</p>
<ol start="4">
<li>‰ΩøÁî®SysstatÊä•Âëä</li>
</ol>
<p>SysstatËøòÊèê‰æõ‰∫Ü‰∏Ä‰∏™Êä•ÂëäÁîüÊàêÂ∑•ÂÖ∑ÔºåÂèØ‰ª•Ê†πÊçÆSysstatÊï∞ÊçÆÁîüÊàêÊä•Âëä„ÄÇË¶ÅÁîüÊàêÊä•ÂëäÔºåËØ∑ËøêË°å‰ª•‰∏ãÂëΩ‰ª§Ôºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sar -A -o &lt;outfile&gt;</span><br><span class="line">sadf -dh &lt;outfile&gt; &gt; &lt;reportfile&gt;</span><br></pre></td></tr></table></figure>

<p>ËøôÂ∞ÜÁîüÊàê‰∏Ä‰∏™ÂåÖÂê´ÊâÄÊúâÊÄßËÉΩÊï∞ÊçÆÁöÑËæìÂá∫Êñá‰ª∂<outfile>ÔºåÁÑ∂Âêé‰ΩøÁî®sadfÂëΩ‰ª§Â∞ÜËæìÂá∫Êñá‰ª∂ËΩ¨Êç¢‰∏∫HTMLÊ†ºÂºèÁöÑÊä•ÂëäÊñá‰ª∂<reportfile>„ÄÇ</p>
<p>Â∏åÊúõËøô‰∫õÊúÄ‰Ω≥ÂÆûË∑µÂèØ‰ª•Â∏ÆÂä©ÊÇ®Êõ¥Â•ΩÂú∞‰ΩøÁî®SysstatËøõË°åKVMËôöÊãüÂåñÊÄßËÉΩÂàÜÊûê„ÄÇ</p>
<p>Â¶ÇÊûúÊÇ®Â∏åÊúõÈÄöËøáSysstatÊï∞ÊçÆËøõË°åË∂ãÂäøÂàÜÊûêÔºåÂèØ‰ª•‰ΩøÁî®‰∏Ä‰∏™Âêç‰∏∫<code>ksar</code>ÁöÑÂ∑•ÂÖ∑„ÄÇ</p>
<p><code>ksar</code>ÊòØ‰∏Ä‰∏™JavaÂ∫îÁî®Á®ãÂ∫èÔºåÂèØ‰ª•Â∞ÜSysstatÊï∞ÊçÆËΩ¨Êç¢‰∏∫ÂõæË°®Ôºå‰ªéËÄåÊõ¥Êñπ‰æøÂú∞ËøõË°åË∂ãÂäøÂàÜÊûê„ÄÇ</p>
<p>Ë¶Å‰ΩøÁî®<code>ksar</code>ÔºåËØ∑ÊåâÁÖß‰ª•‰∏ãÊ≠•È™§Êìç‰ΩúÔºö</p>
<ol>
<li>ÂÆâË£ÖJava</li>
</ol>
<p><code>ksar</code>ÊòØ‰∏Ä‰∏™JavaÂ∫îÁî®Á®ãÂ∫èÔºåÂõ†Ê≠§ÊÇ®ÈúÄË¶ÅÂÆâË£ÖJavaÊâçËÉΩËøêË°åÂÆÉ„ÄÇÊÇ®ÂèØ‰ª•‰ªéOracleÂÆòÊñπÁΩëÁ´ô‰∏ãËΩΩJava„ÄÇ</p>
<ol start="2">
<li>‰∏ãËΩΩÂíåÂÆâË£Ö<code>ksar</code></li>
</ol>
<p>ÊÇ®ÂèØ‰ª•‰ªé<code>ksar</code>ÁöÑÂÆòÊñπÁΩëÁ´ô‰∏ãËΩΩÊúÄÊñ∞ÁöÑÁâàÊú¨„ÄÇ‰∏ãËΩΩÂÆåÊàêÂêéÔºåÂ∞ÜÂéãÁº©Êñá‰ª∂Ëß£ÂéãÁº©Âà∞ÊÇ®ÈÄâÊã©ÁöÑÁõÆÂΩï‰∏≠„ÄÇ</p>
<ol start="3">
<li>ËøêË°å<code>ksar</code></li>
</ol>
<p>Ë¶ÅËøêË°å<code>ksar</code>ÔºåËØ∑ÊâìÂºÄÁªàÁ´ØÂπ∂ÂØºËà™Âà∞<code>ksar</code>ÁõÆÂΩï„ÄÇÁÑ∂ÂêéÔºåËøêË°å‰ª•‰∏ãÂëΩ‰ª§Ôºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ksar.jar</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Âä†ËΩΩSysstatÊï∞ÊçÆÊñá‰ª∂</li>
</ol>
<p>Âú®<code>ksar</code>Á™óÂè£‰∏≠ÔºåÂçïÂáª‚ÄúFile‚ÄùËèúÂçïÔºåÁÑ∂ÂêéÈÄâÊã©‚ÄúOpen‚ÄùÈÄâÈ°π„ÄÇÈÄâÊã©ÊÇ®Ë¶ÅÂä†ËΩΩÁöÑSysstatÊï∞ÊçÆÊñá‰ª∂„ÄÇ</p>
<ol start="5">
<li>ÁîüÊàêÂõæË°®</li>
</ol>
<p>Âú®<code>ksar</code>Á™óÂè£‰∏≠ÔºåÂçïÂáª‚ÄúGraphs‚ÄùËèúÂçïÔºåÁÑ∂ÂêéÈÄâÊã©Ë¶ÅÁîüÊàêÁöÑÂõæË°®Á±ªÂûã„ÄÇ<code>ksar</code>Â∞ÜÁîüÊàê‰∏Ä‰∏™ÂõæË°®ÔºåÊòæÁ§∫SysstatÊï∞ÊçÆÁöÑË∂ãÂäø„ÄÇ</p>
<p>Â¶ÇÊûúÊÇ®Âú®KVMËôöÊãüÂåñ‰∏≠ÈÅáÂà∞‰∫ÜÁΩëÁªúÊÄßËÉΩÈóÆÈ¢òÔºåÂèØ‰ª•‰ΩøÁî®‰ª•‰∏ãÂ∑•ÂÖ∑Êù•ËøõË°åËØäÊñ≠Ôºö</p>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>tcpdumpÊòØ‰∏ÄÁßçÂ∏∏Áî®ÁöÑÁΩëÁªúÊäìÂåÖÂ∑•ÂÖ∑„ÄÇÂú®KVMËôöÊãüÂåñ‰∏≠ÔºåÊÇ®ÂèØ‰ª•Âú®ÂÆø‰∏ªÊú∫‰∏ä‰ΩøÁî®tcpdumpÊù•ÁõëËßÜËôöÊãüÊú∫ÁöÑÁΩëÁªúÊµÅÈáè„ÄÇ‰ª•‰∏ãÊòØ‰∏Ä‰∏™Á§∫‰æãÂëΩ‰ª§Ôºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i &lt;interface&gt; -w &lt;output-file&gt;</span><br></pre></td></tr></table></figure>

<p>Âú®Ëøô‰∏™ÂëΩ‰ª§‰∏≠Ôºå<interface>ÊòØÊÇ®Ë¶ÅÁõëËßÜÁöÑÁΩëÁªúÊé•Âè£Ôºå<output-file>ÊòØ‰øùÂ≠òÊäìÂåÖÊï∞ÊçÆÁöÑËæìÂá∫Êñá‰ª∂„ÄÇËøêË°åÊ≠§ÂëΩ‰ª§ÂêéÔºåtcpdumpÂ∞ÜÂºÄÂßãÁõëËßÜÊåáÂÆöÁöÑÁΩëÁªúÊé•Âè£‰∏äÁöÑÊµÅÈáèÔºåÂπ∂Â∞ÜÊâÄÊúâÊï∞ÊçÆ‰øùÂ≠òÂà∞ËæìÂá∫Êñá‰ª∂‰∏≠„ÄÇ</p>
<h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p>WiresharkÊòØ‰∏ÄÁßçÁΩëÁªúÂçèËÆÆÂàÜÊûêÂ∑•ÂÖ∑ÔºåÂèØ‰ª•Áî®‰∫éÂàÜÊûêÁΩëÁªúÊµÅÈáè„ÄÇÂú®KVMËôöÊãüÂåñ‰∏≠ÔºåÊÇ®ÂèØ‰ª•Âú®ÂÆø‰∏ªÊú∫‰∏ä‰ΩøÁî®WiresharkÊù•ÂàÜÊûêËôöÊãüÊú∫ÁöÑÁΩëÁªúÊµÅÈáè„ÄÇ‰ª•‰∏ãÊòØ‰∏Ä‰∏™Á§∫‰æãÂëΩ‰ª§Ôºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tshark -i &lt;interface&gt; -w &lt;output-file&gt;</span><br></pre></td></tr></table></figure>

<h2 id="virt-top"><a href="#virt-top" class="headerlink" title="virt-top"></a>virt-top</h2><p>‰∏Ä‰∏™Êï¥ÂêàKVMËôöÊãüÂåñÊÄßËÉΩËØäÊñ≠Â∑•ÂÖ∑ÁöÑÈ°πÁõÆÊòØ<code>virt-top</code>„ÄÇ<code>virt-top</code>ÊòØ‰∏Ä‰∏™Âü∫‰∫éncursesÁöÑ‰∫§‰∫íÂºèÁõëËßÜÂô®ÔºåÂèØ‰ª•Áî®‰∫éÁõëËßÜKVMËôöÊãüÊú∫ÁöÑÊÄßËÉΩ„ÄÇ‰ª•‰∏ãÊòØ‰ΩøÁî®<code>virt-top</code>ËøõË°åKVMËôöÊãüÂåñÊÄßËÉΩÂàÜÊûêÁöÑÊúÄ‰Ω≥ÂÆûË∑µÔºö</p>
<ol>
<li>ÂÆâË£Ö<code>virt-top</code></li>
</ol>
<p>Ë¶ÅÂÆâË£Ö<code>virt-top</code>ÔºåËØ∑‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Ôºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install virt-top</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ËøêË°å<code>virt-top</code></li>
</ol>
<p>Ë¶ÅËøêË°å<code>virt-top</code>ÔºåËØ∑ËøêË°å‰ª•‰∏ãÂëΩ‰ª§Ôºö</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virt-top</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ÁõëËßÜËôöÊãüÊú∫ÊÄßËÉΩ</li>
</ol>
<p>Âú®<code>virt-top</code>Á™óÂè£‰∏≠ÔºåÊÇ®ÂèØ‰ª•‰ΩøÁî®‰∏ä‰∏ãÊñπÂêëÈîÆÈÄâÊã©Ë¶ÅÁõëËßÜÁöÑËôöÊãüÊú∫„ÄÇÁÑ∂ÂêéÔºåÊÇ®ÂèØ‰ª•Êü•ÁúãËôöÊãüÊú∫ÁöÑCPU‰ΩøÁî®Áéá„ÄÅÂÜÖÂ≠ò‰ΩøÁî®ÊÉÖÂÜµ„ÄÅÁ£ÅÁõòI/OÁ≠âÊÄßËÉΩÊåáÊ†á„ÄÇ</p>
<p>Â∏åÊúõËøô‰∫õÊúÄ‰Ω≥ÂÆûË∑µÂèØ‰ª•Â∏ÆÂä©ÊÇ®Êõ¥Â•ΩÂú∞‰ΩøÁî®KVMËôöÊãüÂåñÊÄßËÉΩËØäÊñ≠Â∑•ÂÖ∑„ÄÇ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" data-id="clf6xlaht0000cqwbf3o8cy3v" data-title="KVMËôöÊãüÂåñÊÄßËÉΩÂàÜÊûê" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kvm/" rel="tag">kvm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/performance/" rel="tag">performance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sysstat/" rel="tag">sysstat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virt-top/" rel="tag">virt-top</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cpu-features-about-kvm-hidden" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/09/cpu-features-about-kvm-hidden/" class="article-date">
  <time class="dt-published" datetime="2023-03-09T13:48:22.000Z" itemprop="datePublished">2023-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/kvm/">kvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/09/cpu-features-about-kvm-hidden/">Cpu features about kvm hidden</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="What-kvm-hidden-did-to-qemu"><a href="#What-kvm-hidden-did-to-qemu" class="headerlink" title="What kvm hidden did to qemu"></a>What kvm hidden did to qemu</h2><p>Based on last blog, we can see how libvirt cpu feature configuration changes qemu cpuid. And we figure out hypervisor disable configuration have what kind of influence.</p>
<p>Then another recommanded feature from libvirt is kvm hidden. In the same way with last blog, we can find libvirt will configure <code>kvm=off</code> to <code>-cpu</code> and according to qemu:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-relaxed&quot;</span>, X86CPU, hyperv_relaxed_timing, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-vapic&quot;</span>, X86CPU, hyperv_vapic, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-time&quot;</span>, X86CPU, hyperv_time, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-crash&quot;</span>, X86CPU, hyperv_crash, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-reset&quot;</span>, X86CPU, hyperv_reset, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-vpindex&quot;</span>, X86CPU, hyperv_vpindex, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-runtime&quot;</span>, X86CPU, hyperv_runtime, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-synic&quot;</span>, X86CPU, hyperv_synic, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-stimer&quot;</span>, X86CPU, hyperv_stimer, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-frequencies&quot;</span>, X86CPU, hyperv_frequencies, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;check&quot;</span>, X86CPU, check_cpuid, <span class="literal">true</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;enforce&quot;</span>, X86CPU, enforce_cpuid, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;kvm&quot;</span>, X86CPU, expose_kvm, <span class="literal">true</span>),</span><br></pre></td></tr></table></figure>

<p>those configures are defined by <code>target/i386/cpu.c</code> in variable <code>x86_cpu_properties</code>.</p>
<p><code>kvm=off</code> will be treated as ‚Äúkvm‚Äù is false and the local variable of this cpu changes <code>expose_kvm</code> to false.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x86_cpu_realizefn</code> will invoke <code>x86_cpu_expand_features</code> to expand features from configuration, as a result FEAT_KVM will disable all features after realize features.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[FEAT_KVM] = &#123;</span><br><span class="line">    .feat_names = &#123;</span><br><span class="line">        <span class="string">&quot;kvmclock&quot;</span>, <span class="string">&quot;kvm-nopiodelay&quot;</span>, <span class="string">&quot;kvm-mmu&quot;</span>, <span class="string">&quot;kvmclock&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kvm-asyncpf&quot;</span>, <span class="string">&quot;kvm-steal-time&quot;</span>, <span class="string">&quot;kvm-pv-eoi&quot;</span>, <span class="string">&quot;kvm-pv-unhalt&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">&quot;kvm-pv-tlb-flush&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="string">&quot;kvmclock-stable-bit&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .cpuid_eax = KVM_CPUID_FEATURES, .cpuid_reg = R_EAX,</span><br><span class="line">    .tcg_features = TCG_KVM_FEATURES,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>check its definition, almost all kvm related features is disabled.</p>
<p>Then go ahead to linux kernel <code>arch/x86/include/uapi/asm/kvm_para.h</code> defines those features from cpuid:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This CPUID returns a feature bitmap in eax.  Before enabling a particular</span></span><br><span class="line"><span class="comment"> * paravirtualization, the appropriate feature bit should be checked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_CPUID_FEATURES	0x40000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_NOP_IO_DELAY	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_MMU_OP		2</span></span><br><span class="line"><span class="comment">/* This indicates that the new set of kvmclock msrs</span></span><br><span class="line"><span class="comment"> * are available. The use of 0x11 and 0x12 is deprecated</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE2        3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_ASYNC_PF		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_STEAL_TIME		5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_PV_EOI		6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_PV_UNHALT		7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The last 8 bits are used to indicate how to interpret the flags field</span></span><br><span class="line"><span class="comment"> * in pvclock structure. If no bits are set, all flags are ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE_STABLE_BIT	24</span></span><br></pre></td></tr></table></figure>

<p>And before we check all features details let‚Äôs check how linux figure kvm feature at first.</p>
<p>For kernel, check kvm by <code>kvm_para_available</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kvm_para_available</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> kvm_cpuid_base() != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which will return a kvm based hypervisor by check <code>cpu_has_hypervisor</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> noinline <span class="keyword">uint32_t</span> __kvm_cpuid_base(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (boot_cpu_data.cpuid_level &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">/* So we don&#x27;t blow up on old processors */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu_has_hypervisor)</span><br><span class="line">		<span class="keyword">return</span> hypervisor_cpuid_base(<span class="string">&quot;KVMKVMKVM\0\0\0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and <code>cpu_has_hypervisor</code>  is defined from the hypervisor feature we mentioned in last post:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_has_hypervisor	boot_cpu_has(X86_FEATURE_HYPERVISOR)</span></span><br></pre></td></tr></table></figure>

<p>So we combine those two part together to check the influence introduced by kvm hidden.</p>
<p>Note: here is the brief description about those features in cpuid:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function: define KVM_CPUID_FEATURES (0x40000001)</span><br><span class="line">returns : ebx, ecx, edx = 0</span><br><span class="line">          eax = and OR&#x27;ed group of (1 &lt;&lt; flag), where each flags is:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag                               || value || meaning</span><br><span class="line">=============================================================================</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE            ||     0 || kvmclock available at msrs</span><br><span class="line">                                   ||       || 0x11 and 0x12.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_NOP_IO_DELAY           ||     1 || not necessary to perform delays</span><br><span class="line">                                   ||       || on PIO operations.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_MMU_OP                 ||     2 || deprecated.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE2           ||     3 || kvmclock available at msrs</span><br><span class="line">                                   ||       || 0x4b564d00 and 0x4b564d01</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_ASYNC_PF               ||     4 || async pf can be enabled by</span><br><span class="line">                                   ||       || writing to msr 0x4b564d02</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_STEAL_TIME             ||     5 || steal time can be enabled by</span><br><span class="line">                                   ||       || writing to msr 0x4b564d03.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_PV_EOI                 ||     6 || paravirtualized end of interrupt</span><br><span class="line">                                   ||       || handler can be enabled by writing</span><br><span class="line">                                   ||       || to msr 0x4b564d04.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_PV_UNHALT              ||     7 || guest checks this feature bit</span><br><span class="line">                                   ||       || before enabling paravirtualized</span><br><span class="line">                                   ||       || spinlock support.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE_STABLE_BIT ||    24 || host will warn if no guest-side</span><br><span class="line">                                   ||       || per-cpu warps are expected in</span><br><span class="line">                                   ||       || kvmclock.</span><br><span class="line">------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-CLOCKSOURCE-amp-KVM-FEATURE-CLOCKSOURCE2"><a href="#KVM-FEATURE-CLOCKSOURCE-amp-KVM-FEATURE-CLOCKSOURCE2" class="headerlink" title="KVM_FEATURE_CLOCKSOURCE &amp; KVM_FEATURE_CLOCKSOURCE2"></a>KVM_FEATURE_CLOCKSOURCE &amp; KVM_FEATURE_CLOCKSOURCE2</h3><p>This feature is used directly when implement <code>kvmclock_init</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvmclock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pvclock_vcpu_time_info</span> *<span class="title">vcpu_time</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mem, mem_wall_clock;</span><br><span class="line">	<span class="keyword">int</span> size, cpu, wall_clock_size;</span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	size = PAGE_ALIGN(<span class="keyword">sizeof</span>(struct pvclock_vsyscall_time_info)*NR_CPUS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvmclock &amp;&amp; kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) &#123;</span><br><span class="line">		msr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;</span><br><span class="line">		msr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(kvmclock &amp;&amp; kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-NOP-IO-DELAY"><a href="#KVM-FEATURE-NOP-IO-DELAY" class="headerlink" title="KVM_FEATURE_NOP_IO_DELAY"></a>KVM_FEATURE_NOP_IO_DELAY</h3><p>During guest init, paravirt_ops_setup will use this feature:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_guest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	paravirt_ops_setup();</span><br></pre></td></tr></table></figure>

<p>which changes <code>io_delay</code> of paravirt cpu ops to <code>kvm_io_delay</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">paravirt_ops_setup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pv_info.name = <span class="string">&quot;KVM&quot;</span>;</span><br><span class="line">	pv_info.paravirt_enabled = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_NOP_IO_DELAY))</span><br><span class="line">		pv_cpu_ops.io_delay = kvm_io_delay;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_IO_APIC</span></span><br><span class="line">	no_timer_check = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which just means without any io delay:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * No need for any &quot;IO delay&quot; on KVM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_io_delay</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-MMU-OP"><a href="#KVM-FEATURE-MMU-OP" class="headerlink" title="KVM_FEATURE_MMU_OP"></a>KVM_FEATURE_MMU_OP</h3><p>Deprecated.</p>
<h3 id="KVM-FEATURE-ASYNC-PF"><a href="#KVM-FEATURE-ASYNC-PF" class="headerlink" title="KVM_FEATURE_ASYNC_PF"></a>KVM_FEATURE_ASYNC_PF</h3><p>When init kvm guest:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_guest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF))</span><br><span class="line">		x86_init.irqs.trap_init = kvm_apf_trap_init;</span><br></pre></td></tr></table></figure>

<p><code>kvm_apf_trap_init</code> will be set to <code>x86_init.irqs.trap_init</code> which will set <code>async_page_fault</code> when interrupt request for trap operations:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">kvm_apf_trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_intr_gate(<span class="number">14</span>, async_page_fault);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then when init kvm guest cpu, will manually enable cpu to allow to write async page fault:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_guest_cpu_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF) &amp;&amp; kvmapf) &#123;</span><br><span class="line">		u64 pa = slow_virt_to_phys(this_cpu_ptr(&amp;apf_reason));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">		pa |= KVM_ASYNC_PF_SEND_ALWAYS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		wrmsrl(MSR_KVM_ASYNC_PF_EN, pa | KVM_ASYNC_PF_ENABLED);</span><br><span class="line">		__this_cpu_write(apf_reason.enabled, <span class="number">1</span>);</span><br><span class="line">		printk(KERN_INFO<span class="string">&quot;KVM setup async PF for cpu %d\n&quot;</span>,</span><br><span class="line">		       smp_processor_id());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Then feature will enable async PF for this cpu.</p>
<p>Note: trap initialize will be done by <code>arch/x86/kernel/traps.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EISA</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *p = early_ioremap(<span class="number">0x0FFFD9</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (readl(p) == <span class="string">&#x27;E&#x27;</span> + (<span class="string">&#x27;I&#x27;</span>&lt;&lt;<span class="number">8</span>) + (<span class="string">&#x27;S&#x27;</span>&lt;&lt;<span class="number">16</span>) + (<span class="string">&#x27;A&#x27;</span>&lt;&lt;<span class="number">24</span>))</span><br><span class="line">		EISA_bus = <span class="number">1</span>;</span><br><span class="line">	early_iounmap(p, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	set_intr_gate(X86_TRAP_DE, divide_error);</span><br><span class="line">	set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);</span><br><span class="line">	<span class="comment">/* int4 can be called from all */</span></span><br><span class="line">	set_system_intr_gate(X86_TRAP_OF, &amp;overflow);</span><br><span class="line">	set_intr_gate(X86_TRAP_BR, bounds);</span><br><span class="line">	set_intr_gate(X86_TRAP_UD, invalid_op);</span><br><span class="line">	set_intr_gate(X86_TRAP_NM, device_not_available);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	set_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);</span><br><span class="line">	set_intr_gate(X86_TRAP_TS, invalid_TSS);</span><br><span class="line">	set_intr_gate(X86_TRAP_NP, segment_not_present);</span><br><span class="line">	set_intr_gate(X86_TRAP_SS, stack_segment);</span><br><span class="line">	set_intr_gate(X86_TRAP_GP, general_protection);</span><br><span class="line">	set_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);</span><br><span class="line">	set_intr_gate(X86_TRAP_MF, coprocessor_error);</span><br><span class="line">	set_intr_gate(X86_TRAP_AC, alignment_check);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_MCE</span></span><br><span class="line">	set_intr_gate_ist(X86_TRAP_MC, &amp;machine_check, MCE_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_intr_gate(X86_TRAP_XF, simd_coprocessor_error);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reserve all the builtin and the syscall vector: */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FIRST_EXTERNAL_VECTOR; i++)</span><br><span class="line">		set_bit(i, used_vectors);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IA32_EMULATION</span></span><br><span class="line">	set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);</span><br><span class="line">	set_bit(IA32_SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</span><br><span class="line">	set_bit(SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set the IDT descriptor to a fixed read-only location, so that the</span></span><br><span class="line"><span class="comment">	 * &quot;sidt&quot; instruction will not leak the location of the kernel, and</span></span><br><span class="line"><span class="comment">	 * to defend the IDT against arbitrary memory write vulnerabilities.</span></span><br><span class="line"><span class="comment">	 * It will be reloaded in cpu_init() */</span></span><br><span class="line">	__set_fixmap(FIX_RO_IDT, __pa_symbol(idt_table), PAGE_KERNEL_RO);</span><br><span class="line">	idt_descr.address = fix_to_virt(FIX_RO_IDT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Should be a barrier for any external CPU state:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu_init();</span><br><span class="line"></span><br><span class="line">	x86_init.irqs.trap_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;debug_idt_table, &amp;idt_table, IDT_ENTRIES * <span class="number">16</span>);</span><br><span class="line">	set_nmi_gate(X86_TRAP_DB, &amp;debug);</span><br><span class="line">	set_nmi_gate(X86_TRAP_BP, &amp;int3);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and <code>x86_init.irqs.trap_init();</code> will be used post other features.    </p>
<h3 id="KVM-FEATURE-STEAL-TIME"><a href="#KVM-FEATURE-STEAL-TIME" class="headerlink" title="KVM_FEATURE_STEAL_TIME"></a>KVM_FEATURE_STEAL_TIME</h3><p>when do kvm guest init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) &#123;</span><br><span class="line">	has_steal_clock = <span class="number">1</span>;</span><br><span class="line">	pv_time_ops.steal_clock = kvm_steal_clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Paravirt steal lock will be replaced by kvm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">kvm_steal_clock</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 steal;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_steal_time</span> *<span class="title">src</span>;</span></span><br><span class="line">	<span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">	src = &amp;per_cpu(steal_time, cpu);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		version = src-&gt;version;</span><br><span class="line">		rmb();</span><br><span class="line">		steal = src-&gt;steal;</span><br><span class="line">		rmb();</span><br><span class="line">	&#125; <span class="keyword">while</span> ((version &amp; <span class="number">1</span>) || (version != src-&gt;version));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> steal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which will steal the time from cpu directly.</p>
<h3 id="KVM-FEATURE-PV-EOI"><a href="#KVM-FEATURE-PV-EOI" class="headerlink" title="KVM_FEATURE_PV_EOI"></a>KVM_FEATURE_PV_EOI</h3><p>From kvm guest init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">	apic_set_eoi_write(kvm_guest_apic_eoi_write);</span><br></pre></td></tr></table></figure>

<p>During kvm guest cpu init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI)) &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pa;</span><br><span class="line">	<span class="comment">/* Size alignment is implied but just to make it explicit. */</span></span><br><span class="line">	BUILD_BUG_ON(__alignof__(kvm_apic_eoi) &lt; <span class="number">4</span>);</span><br><span class="line">	__this_cpu_write(kvm_apic_eoi, <span class="number">0</span>);</span><br><span class="line">	pa = slow_virt_to_phys(this_cpu_ptr(&amp;kvm_apic_eoi))</span><br><span class="line">		| KVM_MSR_ENABLED;</span><br><span class="line">	wrmsrl(MSR_KVM_PV_EOI_EN, pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Besides, those paravirt kvm features is used by kernel so those features need to be disabled if kernel changed, for example, load kernel by kexec, to avoid the features pointing to old memory of old kernel, those features will disabled by write msr manually:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_pv_guest_cpu_reboot</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We disable PV EOI before we load a new kernel by kexec,</span></span><br><span class="line"><span class="comment">	 * since MSR_KVM_PV_EOI_EN stores a pointer into old kernel&#x27;s memory.</span></span><br><span class="line"><span class="comment">	 * New kernel can re-enable when it boots.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">		wrmsrl(MSR_KVM_PV_EOI_EN, <span class="number">0</span>);</span><br><span class="line">	kvm_pv_disable_apf();</span><br><span class="line">	kvm_disable_steal_time();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So does kvm guest cpu offline do:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_guest_cpu_offline</span><span class="params">(<span class="keyword">void</span> *dummy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	kvm_disable_steal_time();</span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">		wrmsrl(MSR_KVM_PV_EOI_EN, <span class="number">0</span>);</span><br><span class="line">	kvm_pv_disable_apf();</span><br><span class="line">	apf_task_wake_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That‚Äôs all due to paravirt use shared memory to use those features between guest and host.</p>
<h3 id="KVM-FEATURE-PV-UNHALT"><a href="#KVM-FEATURE-PV-UNHALT" class="headerlink" title="KVM_FEATURE_PV_UNHALT"></a>KVM_FEATURE_PV_UNHALT</h3><p>Allow to use para-virtualized spinlock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_spinlock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/* Does host kernel support KVM_FEATURE_PV_UNHALT? */</span></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_has_feature(KVM_FEATURE_PV_UNHALT))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-CLOCKSOURCE-STABLE-BIT"><a href="#KVM-FEATURE-CLOCKSOURCE-STABLE-BIT" class="headerlink" title="KVM_FEATURE_CLOCKSOURCE_STABLE_BIT"></a>KVM_FEATURE_CLOCKSOURCE_STABLE_BIT</h3><p>kvm clock will set a <code>PVCLOCK_TSC_STABLE_BIT</code> to pvclock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_INFO <span class="string">&quot;kvm-clock: Using msrs %x and %x&quot;</span>,</span><br><span class="line">       msr_kvm_system_time, msr_kvm_wall_clock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))</span><br><span class="line">	pvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);</span><br></pre></td></tr></table></figure>

<p>when stable source detected:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u64 <span class="title">pvclock_clocksource_read</span><span class="params">(struct pvclock_vcpu_time_info *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> version;</span><br><span class="line">	u64 ret;</span><br><span class="line">	u64 last;</span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		version = pvclock_read_begin(src);</span><br><span class="line">		ret = __pvclock_read_cycles(src, rdtsc_ordered());</span><br><span class="line">		flags = src-&gt;flags;</span><br><span class="line">	&#125; <span class="keyword">while</span> (pvclock_read_retry(src, version));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely((flags &amp; PVCLOCK_GUEST_STOPPED) != <span class="number">0</span>)) &#123;</span><br><span class="line">		src-&gt;flags &amp;= ~PVCLOCK_GUEST_STOPPED;</span><br><span class="line">		pvclock_touch_watchdogs();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((valid_flags &amp; PVCLOCK_TSC_STABLE_BIT) &amp;&amp;</span><br><span class="line">		(flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>

<p>clocksource read will return directly.</p>
<h4 id="Hyper-v-impact"><a href="#Hyper-v-impact" class="headerlink" title="Hyper-v impact"></a>Hyper-v impact</h4><p>linux will converting hyperv and kvmclock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compute_tsc_page_parameters</span><span class="params">(struct pvclock_vcpu_time_info *hv_clock,</span></span></span><br><span class="line"><span class="function"><span class="params">					HV_REFERENCE_TSC_PAGE *tsc_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 max_mul;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(hv_clock-&gt;flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>but if no stable tsc allowed, hypervclock and kvmclock computing will be skipped.</p>
<p>Function chain as following:</p>
<p><code>kvm_guest_time_update</code> -&gt; <code>kvm_hv_setup_tsc_page</code> -&gt; <code>compute_tsc_page_parameters</code></p>
<p>And source is from kvm request:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) &#123;</span><br><span class="line">	r = kvm_guest_time_update(vcpu);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(r))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to know more about <code>KVM_REQ_CLOCK_UPDATE</code> to figure out when. this request will be used.</p>
<p>The clue is <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code> make request usage.</p>
<ul>
<li><p>Ioctl kvm clock set -&gt; <code>KVM_SET_CLOCK</code> -&gt;  <code>kvm_gen_update_masterclock</code> </p>
</li>
<li><p><code>kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu)</code> -&gt;  <code>kvm_gen_update_masterclock</code> </p>
</li>
<li><p><code>kvm_guest_time_update</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code><br>first update is from kvm request:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) &#123;</span><br><span class="line">	r = kvm_guest_time_update(vcpu);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(r))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>then interrupt will be disabled to prevent clock changes:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keep irq disabled to prevent changes to the clock */</span></span><br><span class="line">local_irq_save(flags);</span><br><span class="line">this_tsc_khz = __this_cpu_read(cpu_tsc_khz);</span><br><span class="line"><span class="keyword">if</span> (unlikely(this_tsc_khz == <span class="number">0</span>)) &#123;</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>INIT_DELAYED_WORK(&amp;kvm-&gt;arch.kvmclock_update_work, kvmclock_update_fn);</code> -&gt; <code>kvmclock_update_fn</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code><br>kvm lock will be updated by a schedule:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kvmclock updates which are isolated to a given vcpu, such as</span></span><br><span class="line"><span class="comment"> * vcpu-&gt;cpu migration, should not allow system_timestamp from</span></span><br><span class="line"><span class="comment"> * the rest of the vcpus to remain static. Otherwise ntp frequency</span></span><br><span class="line"><span class="comment"> * correction applies to one vcpu&#x27;s system_timestamp but not</span></span><br><span class="line"><span class="comment"> * the others.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So in those cases, request a kvmclock update for all vcpus.</span></span><br><span class="line"><span class="comment"> * We need to rate-limit these requests though, as they can</span></span><br><span class="line"><span class="comment"> * considerably slow guests that have a large number of vcpus.</span></span><br><span class="line"><span class="comment"> * The time for a remote vcpu to update its kvmclock is bound</span></span><br><span class="line"><span class="comment"> * by the delay we use to rate-limit the updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)</span></span><br></pre></td></tr></table></figure>

<p>and kvmlock sync delays are</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVMCLOCK_SYNC_PERIOD (300 * HZ)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu)</code> -&gt;  <code>kvm_gen_kvmclock_update</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code></p>
<ul>
<li><p>MSR_KVM_SYSTEM_TIME</p>
</li>
<li><p>kvm_arch_vcpu_load<br>update clock if no master clock or host cpu to sync.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On a host with synchronized TSC, there is no need to update</span></span><br><span class="line"><span class="comment"> * kvmclock on vcpu-&gt;cpu migration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!vcpu-&gt;kvm-&gt;arch.use_master_clock || vcpu-&gt;cpu == <span class="number">-1</span>)</span><br><span class="line">	kvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);</span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;cpu != cpu)</span><br><span class="line">	kvm_migrate_timers(vcpu);</span><br><span class="line">vcpu-&gt;cpu = cpu;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>kvm_arch_vcpu_load</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>Adjust time if needed</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Apply any externally detected TSC adjustments (due to suspend) */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(vcpu-&gt;arch.tsc_offset_adjustment)) &#123;</span><br><span class="line">	adjust_tsc_offset_host(vcpu, vcpu-&gt;arch.tsc_offset_adjustment);</span><br><span class="line">	vcpu-&gt;arch.tsc_offset_adjustment = <span class="number">0</span>;</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvm_set_guest_paused</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>if guest kernel stopped by hypervisor use this to update pv clock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kvm_set_guest_paused() indicates to the guest kernel that it has been</span></span><br><span class="line"><span class="comment"> * stopped by the hypervisor.  This function will be called from the host only.</span></span><br><span class="line"><span class="comment"> * EINVAL is returned when the host attempts to set the flag for a guest that</span></span><br><span class="line"><span class="comment"> * does not support pv clocks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kvm_set_guest_paused</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!vcpu-&gt;arch.pv_time_enabled)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	vcpu-&gt;arch.pvclock_set_guest_stopped_request = <span class="literal">true</span>;</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvmclock_cpufreq_notifier</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>see the annotation from code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We allow guests to temporarily run on slowing clocks,</span></span><br><span class="line"><span class="comment"> * provided we notify them after, or to run on accelerating</span></span><br><span class="line"><span class="comment"> * clocks, provided we notify them before.  Thus time never</span></span><br><span class="line"><span class="comment"> * goes backwards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, we have a problem.  We can&#x27;t atomically update</span></span><br><span class="line"><span class="comment"> * the frequency of a given CPU from this function; it is</span></span><br><span class="line"><span class="comment"> * merely a notifier, which can be called from any CPU.</span></span><br><span class="line"><span class="comment"> * Changing the TSC frequency at arbitrary points in time</span></span><br><span class="line"><span class="comment"> * requires a recomputation of local variables related to</span></span><br><span class="line"><span class="comment"> * the TSC for each VCPU.  We must flag these local variables</span></span><br><span class="line"><span class="comment"> * to be updated and be sure the update takes place with the</span></span><br><span class="line"><span class="comment"> * new frequency before any guests proceed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unfortunately, the combination of hotplug CPU and frequency</span></span><br><span class="line"><span class="comment"> * change creates an intractable locking scenario; the order</span></span><br><span class="line"><span class="comment"> * of when these callouts happen is undefined with respect to</span></span><br><span class="line"><span class="comment"> * CPU hotplug, and they can race with each other.  As such,</span></span><br><span class="line"><span class="comment"> * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is</span></span><br><span class="line"><span class="comment"> * undefined; you can actually have a CPU frequency change take</span></span><br><span class="line"><span class="comment"> * place in between the computation of X and the setting of the</span></span><br><span class="line"><span class="comment"> * variable.  To protect against this problem, all updates of</span></span><br><span class="line"><span class="comment"> * the per_cpu tsc_khz variable are done in an interrupt</span></span><br><span class="line"><span class="comment"> * protected IPI, and all callers wishing to update the value</span></span><br><span class="line"><span class="comment"> * must wait for a synchronous IPI to complete (which is trivial</span></span><br><span class="line"><span class="comment"> * if the caller is on the CPU already).  This establishes the</span></span><br><span class="line"><span class="comment"> * necessary total order on variable updates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that because a guest time update may take place</span></span><br><span class="line"><span class="comment"> * anytime after the setting of the VCPU&#x27;s request bit, the</span></span><br><span class="line"><span class="comment"> * correct TSC value must be set before the request.  However,</span></span><br><span class="line"><span class="comment"> * to ensure the update actually makes it to any guest which</span></span><br><span class="line"><span class="comment"> * starts running in hardware virtualization between the set</span></span><br><span class="line"><span class="comment"> * and the acquisition of the spinlock, we must also ping the</span></span><br><span class="line"><span class="comment"> * CPU after setting the request bit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>after <code>kvm_guest_exit();</code><br>update clock if vcpu request clock always up to date.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(vcpu-&gt;arch.tsc_always_catchup))</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hardware_enable_nolock</code> -&gt; <code>kvm_arch_hardware_enable</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>multi functino access hardware_enable_nolock</p>
<ul>
<li><code>kvm_cpu_hotplug</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kvm_cpu_hotplug</span><span class="params">(struct notifier_block *notifier, <span class="keyword">unsigned</span> <span class="keyword">long</span> val,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	val &amp;= ~CPU_TASKS_FROZEN;</span><br><span class="line">	<span class="keyword">switch</span> (val) &#123;</span><br><span class="line">	<span class="keyword">case</span> CPU_DYING:</span><br><span class="line">		hardware_disable();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CPU_STARTING:</span><br><span class="line">		hardware_enable();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kvm_resume</code> </li>
</ul>
</li>
</ul>
<p>Note: for <code>hv_stimer</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * KVM_REQ_HV_STIMER has to be processed after</span></span><br><span class="line"><span class="comment"> * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers</span></span><br><span class="line"><span class="comment"> * depend on the guest clock being up-to-date</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))</span><br><span class="line">	kvm_hv_process_stimers(vcpu);</span><br></pre></td></tr></table></figure>

<p>will be done after guest clock up-to-date.</p>
<h4 id="Hyper-v-impact-conclusion"><a href="#Hyper-v-impact-conclusion" class="headerlink" title="Hyper-v impact conclusion"></a>Hyper-v impact conclusion</h4><p>With kvm hidden, hyper-v tsc compute will be skipped:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compute_tsc_page_parameters</span><span class="params">(struct pvclock_vcpu_time_info *hv_clock,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct ms_hyperv_tsc_page *tsc_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 max_mul;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(hv_clock-&gt;flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>which can be triggered by above kvm code.</p>
<p>During migration, we know that guest will be stopped (paused) by <code>KVM_KVMCLOCK_CTRL</code> and we could check kvm userspace‚Äôs (qemu) usage:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvmclock_vm_state_change</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> running,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     RunState state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KVMClockState *s = opaque;</span><br><span class="line">    CPUState *cpu;</span><br><span class="line">    <span class="keyword">int</span> cap_clock_ctrl = kvm_check_extension(kvm_state, KVM_CAP_KVMCLOCK_CTRL);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">data</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the host where s-&gt;clock was read did not support reliable</span></span><br><span class="line"><span class="comment">         * KVM_GET_CLOCK, read kvmclock value from memory.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;clock_is_reliable) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> pvclock_via_mem = kvmclock_current_nsec(s);</span><br><span class="line">            <span class="comment">/* We can&#x27;t rely on the saved clock value, just discard it */</span></span><br><span class="line">            <span class="keyword">if</span> (pvclock_via_mem) &#123;</span><br><span class="line">                s-&gt;clock = pvclock_via_mem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s-&gt;clock_valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        data.clock = s-&gt;clock;</span><br><span class="line">        ret = kvm_vm_ioctl(kvm_state, KVM_SET_CLOCK, &amp;data);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;KVM_SET_CLOCK failed: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cap_clock_ctrl) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CPU_FOREACH(cpu) &#123;</span><br><span class="line">            run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;clock_valid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s-&gt;runstate_paused = runstate_check(RUN_STATE_PAUSED);</span><br><span class="line"></span><br><span class="line">        kvm_synchronize_all_tsc();</span><br><span class="line"></span><br><span class="line">        kvm_update_clock(s);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the VM is stopped, declare the clock state valid to</span></span><br><span class="line"><span class="comment">         * avoid re-reading it on next vmsave (which would return</span></span><br><span class="line"><span class="comment">         * a different value). Will be reset when the VM is continued.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s-&gt;clock_valid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>when set guest to running, qemu will use <code>KVM_SET_CLOCK</code> else will use <code>kvm_update_clock</code>  works as following:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_update_clock</span><span class="params">(KVMClockState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &amp;data);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;KVM_GET_CLOCK failed: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;clock = data.clock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If kvm_has_adjust_clock_stable() is false, KVM_GET_CLOCK returns</span></span><br><span class="line"><span class="comment">     * essentially CLOCK_MONOTONIC plus a guest-specific adjustment.  This</span></span><br><span class="line"><span class="comment">     * can drift from the TSC-based value that is computed by the guest,</span></span><br><span class="line"><span class="comment">     * so we need to go through kvmclock_current_nsec().  If</span></span><br><span class="line"><span class="comment">     * kvm_has_adjust_clock_stable() is true, and the flags contain</span></span><br><span class="line"><span class="comment">     * KVM_CLOCK_TSC_STABLE, then KVM_GET_CLOCK returns a TSC-based value</span></span><br><span class="line"><span class="comment">     * and kvmclock_current_nsec() is not necessary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here, however, we need not check KVM_CLOCK_TSC_STABLE.  This is because:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if the host has disabled the kvmclock master clock, the guest already</span></span><br><span class="line"><span class="comment">     *   has protection against time going backwards.  This &quot;safety net&quot; is only</span></span><br><span class="line"><span class="comment">     *   absent when kvmclock is stable;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - therefore, we can replace a check like</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if last KVM_GET_CLOCK was not reliable then</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   with</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if last KVM_GET_CLOCK was not reliable &amp;&amp; masterclock is enabled</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * However:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if kvm_has_adjust_clock_stable() returns false, the left side is</span></span><br><span class="line"><span class="comment">     *   always true (KVM_GET_CLOCK is never reliable), and the right side is</span></span><br><span class="line"><span class="comment">     *   unknown (because we don&#x27;t have data.flags).  We must assume it&#x27;s true</span></span><br><span class="line"><span class="comment">     *   and read from memory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if kvm_has_adjust_clock_stable() returns true, the result of the &amp;&amp;</span></span><br><span class="line"><span class="comment">     *   is always false (masterclock is enabled iff KVM_GET_CLOCK is reliable)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So we can just use this instead:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if !kvm_has_adjust_clock_stable() then</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s-&gt;clock_is_reliable = kvm_has_adjust_clock_stable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But from the annotation in <code>kvmclock_vm_state_change</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the VM is stopped, declare the clock state valid to</span></span><br><span class="line"><span class="comment"> * avoid re-reading it on next vmsave (which would return</span></span><br><span class="line"><span class="comment"> * a different value). Will be reset when the VM is continued.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>qemu seems to relay on vmsave to reset the guest while vm is continued, we just keep our eyes on that.</p>
<p>Combine qemu guest state change hook:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_SET_CLOCK: &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_arch</span> *<span class="title">ka</span> =</span> &amp;kvm-&gt;arch;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">user_ns</span>;</span></span><br><span class="line">	u64 now_ns;</span><br><span class="line"></span><br><span class="line">	r = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;user_ns, argp, <span class="keyword">sizeof</span>(user_ns)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	r = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (user_ns.flags)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	r = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">TODO:</span> userspace has to take care of races with VCPU_RUN, so</span></span><br><span class="line"><span class="comment">	 * kvm_gen_update_masterclock() can be cut down to locked</span></span><br><span class="line"><span class="comment">	 * pvclock_update_vm_gtod_copy().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kvm_gen_update_masterclock(kvm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This pairs with kvm_guest_time_update(): when masterclock is</span></span><br><span class="line"><span class="comment">	 * in use, we use master_kernel_ns + kvmclock_offset to set</span></span><br><span class="line"><span class="comment">	 * unsigned &#x27;system_time&#x27; so if we use get_kvmclock_ns() (which</span></span><br><span class="line"><span class="comment">	 * is slightly ahead) here we risk going negative on unsigned</span></span><br><span class="line"><span class="comment">	 * &#x27;system_time&#x27; when &#x27;user_ns.clock&#x27; is very small.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_lock_irq(&amp;ka-&gt;pvclock_gtod_sync_lock);</span><br><span class="line">	<span class="keyword">if</span> (kvm-&gt;arch.use_master_clock)</span><br><span class="line">		now_ns = ka-&gt;master_kernel_ns;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		now_ns = get_kvmclock_base_ns();</span><br><span class="line">	ka-&gt;kvmclock_offset = user_ns.clock - now_ns;</span><br><span class="line">	spin_unlock_irq(&amp;ka-&gt;pvclock_gtod_sync_lock);</span><br><span class="line"></span><br><span class="line">	kvm_make_all_cpus_request(kvm, KVM_REQ_CLOCK_UPDATE);</span><br></pre></td></tr></table></figure>

<p>will be used to update guest clock.</p>
<h2 id="Hand-on-test-to-confirm-clock-updates"><a href="#Hand-on-test-to-confirm-clock-updates" class="headerlink" title="Hand on test to confirm clock updates"></a>Hand on test to confirm clock updates</h2><p>Enable kvm trace by:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/kernel/debug/tracing/events/kvm/enable</span><br></pre></td></tr></table></figure>

<p>Then collect the output when vm migrated to this host:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/kernel/debug/tracing/trace_pipe &gt; trace_migrated_vm</span><br></pre></td></tr></table></figure>

<p>We can see following logs at first:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;<span class="number">-89383</span> [<span class="number">001</span>] .... <span class="number">97852.765277</span>: kvm_update_master_clock: masterclock <span class="number">0</span> hostclock <span class="number">0x2</span> offsetmatched <span class="number">0</span></span><br><span class="line">&lt;...&gt;<span class="number">-89441</span> [<span class="number">002</span>] d... <span class="number">97852.785366</span>: kvm_write_tsc_offset: vcpu=<span class="number">0</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89441</span> [<span class="number">002</span>] d... <span class="number">97852.785402</span>: kvm_track_tsc: vcpu_id <span class="number">0</span> masterclock <span class="number">0</span> offsetmatched <span class="number">0</span> nr_online <span class="number">1</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89442</span> [<span class="number">002</span>] d... <span class="number">97852.786522</span>: kvm_write_tsc_offset: vcpu=<span class="number">1</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89442</span> [<span class="number">002</span>] d... <span class="number">97852.786533</span>: kvm_track_tsc: vcpu_id <span class="number">1</span> masterclock <span class="number">0</span> offsetmatched <span class="number">1</span> nr_online <span class="number">2</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89443</span> [<span class="number">002</span>] d... <span class="number">97852.787341</span>: kvm_write_tsc_offset: vcpu=<span class="number">2</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89443</span> [<span class="number">002</span>] d... <span class="number">97852.787348</span>: kvm_track_tsc: vcpu_id <span class="number">2</span> masterclock <span class="number">0</span> offsetmatched <span class="number">2</span> nr_online <span class="number">3</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89444</span> [<span class="number">002</span>] d... <span class="number">97852.788099</span>: kvm_write_tsc_offset: vcpu=<span class="number">3</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89444</span> [<span class="number">002</span>] d... <span class="number">97852.788120</span>: kvm_track_tsc: vcpu_id <span class="number">3</span> masterclock <span class="number">0</span> offsetmatched <span class="number">3</span> nr_online <span class="number">4</span> hostclock <span class="number">0x2</span></span><br></pre></td></tr></table></figure>

<p><code>kvm_update_master_clock</code> is used for vm migration:</p>
<p>And the tsc offset changed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-89441 [002] d... 97852.785366: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89441 [002] d... 97852.785402: kvm_track_tsc: vcpu_id 0 masterclock 0 offsetmatched 0 nr_online 1 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89442 [002] d... 97852.786522: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89442 [002] d... 97852.786533: kvm_track_tsc: vcpu_id 1 masterclock 0 offsetmatched 1 nr_online 2 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89443 [002] d... 97852.787341: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89443 [002] d... 97852.787348: kvm_track_tsc: vcpu_id 2 masterclock 0 offsetmatched 2 nr_online 3 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89444 [002] d... 97852.788099: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line"></span><br><span class="line">&lt;...&gt;-89441 [003] d... 97852.872014: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89442 [003] d... 97852.872105: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89443 [003] d... 97852.872189: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89444 [003] d... 97852.872264: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line"></span><br><span class="line">&lt;...&gt;-89441 [000] d... 97856.399432: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89442 [000] d... 97856.403066: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89443 [000] d... 97856.403273: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89444 [000] d... 97856.403414: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br></pre></td></tr></table></figure>

<p>Follow the trace we can find linux kernel code:</p>
<p><code>kvm_vcpu_write_tsc_offset</code> -&gt; <code>kvm_x86_write_l1_tsc_offset</code> -&gt;  <code>write_l1_tsc_offset</code> -&gt; <code>vmx_write_l1_tsc_offset</code> -&gt; <code>trace_kvm_write_tsc_offset</code></p>
<p>And there are multi usages of <code>kvm_vcpu_write_tsc_offset</code></p>
<ul>
<li><code>kvm_synchronize_tsc</code><ul>
<li><code>MSR_IA32_TSC</code> -&gt; <code>kvm_synchronize_tsc</code></li>
<li><code>kvm_vm_ioctl_create_vcpu</code> -&gt; <code>kvm_arch_vcpu_postcreate</code> -&gt; <code>kvm_synchronize_tsc</code></li>
</ul>
</li>
<li><code>adjust_tsc_offset_guest</code><ul>
<li><code>kvm_guest_time_update</code> -&gt; <code>adjust_tsc_offset_guest</code> and <code>kvm_hv_setup_tsc_page</code> this is hyper-v impacted case</li>
<li><code>MSR_IA32_TSC</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
<li><code>MSR_IA32_TSC_ADJUST</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
<li><code>kvm_arch_vcpu_load</code> -&gt; <code>adjust_tsc_offset_host</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
</ul>
</li>
<li><code>kvm_arch_vcpu_load</code> same as above</li>
</ul>
<p>So the following three parts of <code>kvm_vcpu_write_tsc_offset</code> matches with guest creation.</p>
<ul>
<li>Create vcpu</li>
<li>Load vcpu</li>
<li>Adjust tsc offset</li>
</ul>
<p>In last guest hang post, we can see windows guest try to get counter ref:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_time_ref_counter</span><span class="params">(struct kvm *kvm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_hv</span> *<span class="title">hv</span> =</span> to_kvm_hv(kvm);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span>;</span></span><br><span class="line">	u64 tsc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fall back to get_kvmclock_ns() when TSC page hasn&#x27;t been set up,</span></span><br><span class="line"><span class="comment">	 * is broken, disabled or being updated.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (hv-&gt;hv_tsc_page_status != HV_TSC_PAGE_SET)</span><br><span class="line">		<span class="keyword">return</span> div_u64(get_kvmclock_ns(kvm), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	vcpu = kvm_get_vcpu(kvm, <span class="number">0</span>);</span><br><span class="line">	tsc = kvm_read_l1_tsc(vcpu, rdtsc());</span><br><span class="line">	<span class="keyword">return</span> mul_u64_u64_shr(tsc, hv-&gt;tsc_ref.tsc_scale, <span class="number">64</span>)</span><br><span class="line">		+ hv-&gt;tsc_ref.tsc_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But this is used by MSR read request from guest. And now we need to debug <code>hv_tsc_page_status</code> and <code>kvm_hv_setup_tsc_page</code> usage.</p>
<p>Without kvm hidden:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114210 [002] d... 12255.411580: kvm_exit: vcpu 1 reason MSR_READ rip 0xfffff800ece454c5 info1 0x0000000000000000 info2 0x0000000000000000 intr_info 0x00000000 error_code 0x00000000</span><br><span class="line">&lt;...&gt;-114210 [002] .... 12255.411581: kvm_msr: msr_read 40000020 &#x3D; 0x6fac3c27</span><br><span class="line">&lt;...&gt;-114210 [002] d... 12255.411582: kvm_entry: vcpu 1, rip 0xfffff800ece454c7</span><br><span class="line">&lt;...&gt;-114211 [000] .... 12255.411585: kvm_vcpu_wakeup: wait time 1759974 ns, polling valid</span><br><span class="line">&lt;...&gt;-114211 [000] .... 12255.411585: kvm_hv_timer_state: vcpu_id 2 hv_timer 0</span><br></pre></td></tr></table></figure>

<p>We can find <code>kvm_hv_timer_state</code> in trace, and according to linux kernel code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRACE_EVENT(kvm_hv_timer_state,</span><br><span class="line">		TP_PROTO(<span class="keyword">unsigned</span> <span class="keyword">int</span> vcpu_id, <span class="keyword">unsigned</span> <span class="keyword">int</span> hv_timer_in_use),</span><br></pre></td></tr></table></figure>

<p>There are two ways to show the trace:</p>
<ul>
<li><code>start_sw_timer</code> -&gt; <code>trace_kvm_hv_timer_state(apic-&gt;vcpu-&gt;vcpu_id, false);</code> which is always false (means 0 in trace)</li>
<li><code>start_hv_timer</code> -&gt; <code>trace_kvm_hv_timer_state(vcpu-&gt;vcpu_id, ktimer-&gt;hv_timer_in_use);</code> which returns <code>hv_timer_in_use</code> from  <code>ktimer-&gt;hv_timer_in_use</code></li>
</ul>
<p>Check the code about <code>start_hv_timer</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_hv_timer</span><span class="params">(struct kvm_lapic *apic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_timer</span> *<span class="title">ktimer</span> =</span> &amp;apic-&gt;lapic_timer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> =</span> apic-&gt;vcpu;</span><br><span class="line">	<span class="keyword">bool</span> expired;</span><br><span class="line"></span><br><span class="line">	WARN_ON(preemptible());</span><br><span class="line">	<span class="keyword">if</span> (!kvm_can_use_hv_timer(vcpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ktimer-&gt;tscdeadline)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (static_call(kvm_x86_set_hv_timer)(vcpu, ktimer-&gt;tscdeadline, &amp;expired))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	ktimer-&gt;hv_timer_in_use = <span class="literal">true</span>;</span><br><span class="line">	hrtimer_cancel(&amp;ktimer-&gt;timer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * To simplify handling the periodic timer, leave the hv timer running</span></span><br><span class="line"><span class="comment">	 * even if the deadline timer has expired, i.e. rely on the resulting</span></span><br><span class="line"><span class="comment">	 * VM-Exit to recompute the periodic timer&#x27;s target expiration.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!apic_lvtt_period(apic)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Cancel the hv timer if the sw timer fired while the hv timer</span></span><br><span class="line"><span class="comment">		 * was being programmed, or if the hv timer itself expired.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (atomic_read(&amp;ktimer-&gt;pending)) &#123;</span><br><span class="line">			cancel_hv_timer(apic);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (expired) &#123;</span><br><span class="line">			apic_timer_expired(apic, <span class="literal">false</span>);</span><br><span class="line">			cancel_hv_timer(apic);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_kvm_hv_timer_state(vcpu-&gt;vcpu_id, ktimer-&gt;hv_timer_in_use);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ktimer-&gt;hv_timer_in_use</code> is set to <code>true</code> so we focus on <code>start_sw_timer</code> next.</p>
<p>There are several ways to goes into <code>restart_apic_timer</code></p>
<ul>
<li><code>restart_apic_timer</code> -&gt; <code>start_sw_timer</code><ul>
<li><code>vmx_exit_handlers_fastpath</code> or <code>__vmx_handle_exit</code> -&gt; <code> handle_fastpath_preemption_timer</code> -&gt; <code>kvm_lapic_expired_hv_timer</code>  -&gt; <code>restart_apic_timer</code></li>
<li><code>vcpu_block</code> -&gt; <code>post_block</code> -&gt; <code>vmx_post_block</code> -&gt;  <code>kvm_lapic_switch_to_hv_timer</code> -&gt; <code>restart_apic_timer</code></li>
<li><code>MSR_IA32_TSC_DEADLINE</code> -&gt;<code>handle_fastpath_set_tscdeadline</code> -&gt; <code>kvm_set_lapic_tscdeadline_msr</code> -&gt;  <code>__start_apic_timer</code> -&gt; <code>restart_apic_timer</code></li>
<li><code>APIC_TDCR</code> -&gt; <code>restart_apic_timer</code> </li>
</ul>
</li>
<li><code>vcpu_block</code> -&gt;  <code>vmx_pre_block</code> -&gt; <code>kvm_lapic_switch_to_sw_timer</code> -&gt; <code>start_sw_timer</code></li>
</ul>
<p>Because we see a trace before shows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kvm_vcpu_wakeup: wait time 1759974 ns, polling valid</span><br></pre></td></tr></table></figure>

<p>which is in kvm_vcpu_block, so this means vmx_post_block <code>restart_apic_timer</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trace_kvm_vcpu_wakeup(block_ns, waited, vcpu_valid_wakeup(vcpu));</span><br><span class="line">kvm_arch_vcpu_block_finish(vcpu);</span><br></pre></td></tr></table></figure>

<p>And because the code runs as:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!start_hv_timer(apic))</span><br><span class="line">	start_sw_timer(apic);</span><br></pre></td></tr></table></figure>

<p><code>start_hv_timer</code> must returns false:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_hv_timer</span><span class="params">(struct kvm_lapic *apic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_timer</span> *<span class="title">ktimer</span> =</span> &amp;apic-&gt;lapic_timer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> =</span> apic-&gt;vcpu;</span><br><span class="line">	<span class="keyword">bool</span> expired;</span><br><span class="line"></span><br><span class="line">	WARN_ON(preemptible());</span><br><span class="line">	<span class="keyword">if</span> (!kvm_can_use_hv_timer(vcpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ktimer-&gt;tscdeadline)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (static_call(kvm_x86_set_hv_timer)(vcpu, ktimer-&gt;tscdeadline, &amp;expired))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><code>kvm_can_use_hv_timer</code> check seems works on x86 machine and while <code>X86_FEATURE_MWAIT</code> is supported.</p>
<p>From the trace we could know, when vcpu exit and come back to work, the timer will be updated, and use vcpu 3 as example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114212 [002] d... 12297.437890: kvm_exit: vcpu 3 reason HLT rip 0xfffff800ecc2b36e info1 0x0000000000000000 info2 0x0000000000000000 intr_info 0x00000000 error_code 0x00000000</span><br></pre></td></tr></table></figure>

<p>vcpu 3 HLT and cause kvm_exit.</p>
<p>Then it wakeup after <code>4774180 ns</code>  and hv_timer is traced without usage.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114212 [002] .... 12255.393408: kvm_vcpu_wakeup: wait time 4774180 ns, polling valid</span><br><span class="line">&lt;...&gt;-114212 [002] .... 12255.393410: kvm_hv_timer_state: vcpu_id 3 hv_timer 0</span><br></pre></td></tr></table></figure>

<p>And hv_timer will be cancelled after live migration:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (apic-&gt;lapic_timer.hv_timer_in_use)</span><br><span class="line">	cancel_hv_timer(apic);</span><br></pre></td></tr></table></figure>

<p>Let‚Äôs check hv_timer before migration:</p>
<h2 id="Can-we-resolve-compatibility-issues"><a href="#Can-we-resolve-compatibility-issues" class="headerlink" title="Can we resolve compatibility issues?"></a>Can we resolve compatibility issues?</h2><p>See the code of qemu, it will disable features of FEAT_KVM after all features setup, so we can not manually assign those features:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (l = plus_features; l; l = l-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prop = l-&gt;data;</span><br><span class="line">    object_property_set_bool(OBJECT(cpu), <span class="literal">true</span>, prop, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (l = minus_features; l; l = l-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prop = l-&gt;data;</span><br><span class="line">    object_property_set_bool(OBJECT(cpu), <span class="literal">false</span>, prop, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/09/cpu-features-about-kvm-hidden/" data-id="clf6xo0140000ibwb0fajc90n" data-title="Cpu features about kvm hidden" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/09/cpu-features-about-kvm-hidden/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/09/cpu-features-about-kvm-hidden/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-virtio-on-linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/virtio-on-linux/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T14:38:09.000Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/virtio-on-linux/">Virtio on Linux</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote>
<p>Virtio is an open standard that defines a protocol for communication between drivers and devices of different types, see Chapter 5 (‚ÄúDevice Types‚Äù) of the virtio spec ([<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id2">1]</a>). Originally developed as a standard for paravirtualized devices implemented by a hypervisor, it can be used to interface any compliant device (real or emulated) with a driver.</p>
</blockquote>
<p>VirtioÊòØ‰∏Ä‰∏™ÂºÄÊîæÁöÑÊ†áÂáÜÔºåÂÆÉÂÆö‰πâ‰∫ÜÈ©±Âä®Á®ãÂ∫èÂíå‰∏çÂêåÁ±ªÂûãÁöÑËÆæÂ§á‰πãÈó¥ÁöÑÈÄö‰ø°ÂçèËÆÆÔºåËßÅvirtioËßÑËåÉÔºà[<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id2">1]</a>ÔºâÁöÑÁ¨¨‰∫îÁ´†Ôºà‚ÄùËÆæÂ§áÁ±ªÂûã‚ÄùÔºâ„ÄÇÂÆÉÊúÄÂàùÊòØ‰Ωú‰∏∫Áî±ÁÆ°ÁêÜÁ®ãÂ∫èÂÆûÁé∞ÁöÑÂáÜËôöÊãüÂåñËÆæÂ§áÁöÑÊ†áÂáÜËÄåÂºÄÂèëÁöÑÔºå‰ΩÜÂÆÉÂèØ‰ª•Áî®Êù•Â∞Ü‰ªª‰ΩïÁ¨¶ÂêàË¶ÅÊ±ÇÁöÑËÆæÂ§áÔºàÁúüÂÆûÁöÑÊàñÊ®°ÊãüÁöÑÔºâ‰∏éÈ©±Âä®Á®ãÂ∫èËøûÊé•„ÄÇ</p>
<blockquote>
<p>For illustrative purposes, this document will focus on the common case of a Linux kernel running in a virtual machine and using paravirtualized devices provided by the hypervisor, which exposes them as virtio devices via standard mechanisms such as PCI.</p>
</blockquote>
<p>‰∏∫‰∫ÜËØ¥ÊòéÈóÆÈ¢òÔºåÊú¨ÊñáÂ∞ÜÈáçÁÇπËÆ®ËÆ∫LinuxÂÜÖÊ†∏Âú®ËôöÊãüÊú∫‰∏≠ËøêË°åÂπ∂‰ΩøÁî®Áî±ÁÆ°ÁêÜÁ®ãÂ∫èÊèê‰æõÁöÑÂáÜËôöÊãüÂåñËÆæÂ§áÁöÑÂ∏∏ËßÅÊÉÖÂÜµÔºåÁÆ°ÁêÜÁ®ãÂ∫èÈÄöËøáÊ†áÂáÜÊú∫Âà∂ÔºàÂ¶ÇPCIÔºâÂ∞ÜÂÆÉ‰ª¨Êö¥Èú≤‰∏∫virtioËÆæÂ§á„ÄÇ</p>
<h2 id="Device-Driver-communication-virtqueues"><a href="#Device-Driver-communication-virtqueues" class="headerlink" title="Device - Driver communication: virtqueues"></a>Device - Driver communication: virtqueues</h2><blockquote>
<p>Although the virtio devices are really an abstraction layer in the hypervisor, they‚Äôre exposed to the guest as if they are physical devices using a specific transport method ‚Äì PCI, MMIO or CCW ‚Äì that is orthogonal to the device itself. The virtio spec defines these transport methods in detail, including device discovery, capabilities and interrupt handling.</p>
</blockquote>
<p>Â∞ΩÁÆ°virtioËÆæÂ§áÂÆûÈôÖ‰∏äÊòØÁÆ°ÁêÜÁ®ãÂ∫è‰∏≠ÁöÑ‰∏Ä‰∏™ÊäΩË±°Â±ÇÔºå‰ΩÜÂÆÉ‰ª¨Ë¢´Êö¥Èú≤ÁªôÂÆ¢Êà∑ÔºåÂ∞±ÂÉèÂÆÉ‰ª¨ÊòØ‰ΩøÁî®ÁâπÂÆöÁöÑ‰º†ËæìÊñπÊ≥ï‚ÄìPCI„ÄÅMMIOÊàñCCW‚ÄìÁöÑÁâ©ÁêÜËÆæÂ§á‰∏ÄÊ†∑ÔºåËøô‰∏éËÆæÂ§áÊú¨Ë∫´ÊòØÊ≠£‰∫§ÁöÑ„ÄÇvirtioËßÑËåÉËØ¶ÁªÜÂÆö‰πâ‰∫ÜËøô‰∫õ‰º†ËæìÊñπÊ≥ïÔºåÂåÖÊã¨ËÆæÂ§áÂèëÁé∞„ÄÅËÉΩÂäõÂíå‰∏≠Êñ≠Â§ÑÁêÜ„ÄÇ</p>
<blockquote>
<p>The communication between the driver in the guest OS and the device in the hypervisor is done through shared memory (that‚Äôs what makes virtio devices so efficient) using specialized data structures called virtqueues, which are actually ring buffers <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#f1">1</a> of buffer descriptors similar to the ones used in a network device:</p>
</blockquote>
<p>ÂÆ¢Êà∑Êìç‰ΩúÁ≥ªÁªü‰∏≠ÁöÑÈ©±Âä®Á®ãÂ∫èÂíåÁÆ°ÁêÜÁ®ãÂ∫è‰∏≠ÁöÑËÆæÂ§á‰πãÈó¥ÁöÑÈÄö‰ø°ÊòØÈÄöËøáÂÖ±‰∫´ÂÜÖÂ≠òÂÆåÊàêÁöÑÔºàËøôÂ∞±ÊòØvirtioËÆæÂ§áÂ¶ÇÊ≠§È´òÊïàÁöÑÂéüÂõ†ÔºâÔºå‰ΩøÁî®Áß∞‰∏∫virtqueuesÁöÑ‰∏ìÈó®Êï∞ÊçÆÁªìÊûÑÔºåËøôÂÆûÈôÖ‰∏äÊòØÁ±ª‰ºº‰∫éÁΩëÁªúËÆæÂ§á‰∏≠‰ΩøÁî®ÁöÑÁºìÂÜ≤Âå∫ÊèèËø∞Á¨¶ÁöÑÁéØÂΩ¢ÁºìÂÜ≤Âå∫<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#f1">1</a>„ÄÇ</p>
<p>struct <strong>vring_desc</strong></p>
<p>Virtio ring descriptors, 16 bytes long. These can chain together via <strong>next</strong>.</p>
<p><strong>Definition</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct vring_desc &#123;</span><br><span class="line">    __virtio64 addr;</span><br><span class="line">    __virtio32 len;</span><br><span class="line">    __virtio16 flags;</span><br><span class="line">    __virtio16 next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Members</strong></p>
<ul>
<li><p><code>addr</code></p>
<p>buffer address (guest-physical)</p>
</li>
<li><p><code>len</code></p>
<p>buffer length</p>
</li>
<li><p><code>flags</code></p>
<p>descriptor flags</p>
</li>
<li><p><code>next</code></p>
<p>index of the next descriptor in the chain, if the VRING_DESC_F_NEXT flag is set. We chain unused descriptors via this, too.</p>
</li>
</ul>
<blockquote>
<p>All the buffers the descriptors point to are allocated by the guest and used by the host either for reading or for writing but not for both.</p>
<p>Refer to Chapter 2.5 (‚ÄúVirtqueues‚Äù) of the virtio spec ([<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id2">1]</a>) for the reference definitions of virtqueues and ‚ÄúVirtqueues and virtio ring: How the data travels‚Äù blog post ([<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id3">2]</a>) for an illustrated overview of how the host device and the guest driver communicate.</p>
</blockquote>
<p>ÊèèËø∞Á¨¶ÊåáÂêëÁöÑÊâÄÊúâÁºìÂÜ≤Âå∫ÈÉΩÊòØÁî±guestÂàÜÈÖçÁöÑÔºåÂπ∂Áî±hostÁî®‰∫éËØªÂèñÊàñÂÜôÂÖ•Ôºå‰ΩÜ‰∏çËÉΩÂêåÊó∂‰ΩøÁî®„ÄÇ</p>
<p>ËØ∑ÂèÇËÄÉvirtioËßÑËåÉÔºà[1]ÔºâÁöÑÁ¨¨2.5Á´†Ôºà‚ÄùËôöÊãüÈòüÂàó‚ÄùÔºâÔºå‰∫ÜËß£ËôöÊãüÈòüÂàóÁöÑÂèÇËÄÉÂÆö‰πâÂíå ‚ÄúËôöÊãüÈòüÂàóÂíåvirtioÁéØ„ÄÇÊï∞ÊçÆÊòØÂ¶Ç‰Ωï‰º†ËæìÁöÑ ‚ÄúÂçöÊñáÔºà[2]ÔºâÔºå‰ª•ÂõæÊñáÂπ∂ËåÇÁöÑÊñπÂºèÊ¶ÇËø∞‰∫Ü‰∏ªÊú∫ËÆæÂ§áÂíåÂÆ¢Êà∑È©±Âä®ÁöÑÈÄö‰ø°ÊñπÂºè„ÄÇ</p>
<p>The <code>vring_virtqueue</code> struct models a virtqueue, including the ring buffers and management data. Embedded in this struct is the <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.virtqueue"><code>virtqueue</code></a> struct, which is the data structure that‚Äôs ultimately used by virtio drivers:</p>
<p>struct <strong>virtqueue</strong></p>
<p>a queue to register buffers for sending or receiving.</p>
<p><strong>Definition</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct virtqueue &#123;</span><br><span class="line">    struct list_head list;</span><br><span class="line">    void (*callback)(struct virtqueue *vq);</span><br><span class="line">    const char *name;</span><br><span class="line">    struct virtio_device *vdev;</span><br><span class="line">    unsigned int index;</span><br><span class="line">    unsigned int num_free;</span><br><span class="line">    unsigned int num_max;</span><br><span class="line">    void *priv;</span><br><span class="line">    bool reset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Members</strong></p>
<ul>
<li><p><code>list</code></p>
<p>the chain of virtqueues for this device</p>
</li>
<li><p><code>callback</code></p>
<p>the function to call when buffers are consumed (can be NULL).</p>
</li>
<li><p><code>name</code></p>
<p>the name of this virtqueue (mainly for debugging)</p>
</li>
<li><p><code>vdev</code></p>
<p>the virtio device this queue was created for.</p>
</li>
<li><p><code>index</code></p>
<p>the zero-based ordinal number for this queue.</p>
</li>
<li><p><code>num_free</code></p>
<p>number of elements we expect to be able to fit.</p>
</li>
<li><p><code>num_max</code></p>
<p>the maximum number of elements supported by the device.</p>
</li>
<li><p><code>priv</code></p>
<p>a pointer for the virtqueue implementation to use.</p>
</li>
<li><p><code>reset</code></p>
<p>vq is in reset state or not.</p>
</li>
</ul>
<p><strong>Description</strong></p>
<blockquote>
<p> A note on <strong>num_free</strong>: with indirect buffers, each buffer needs one element in the queue, otherwise a buffer will need one element per sg element.</p>
<p>The callback function pointed by this struct is triggered when the device has consumed the buffers provided by the driver. More specifically, the trigger will be an interrupt issued by the hypervisor (see <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.vring_interrupt"><code>vring_interrupt()</code></a>). Interrupt request handlers are registered for a virtqueue during the virtqueue setup process (transport-specific).</p>
</blockquote>
<p>ÂÖ≥‰∫é<strong>num_free</strong>ÁöÑËØ¥ÊòéÔºöÂØπ‰∫éÈó¥Êé•ÁºìÂÜ≤Âå∫ÔºåÊØè‰∏™ÁºìÂÜ≤Âå∫ÈúÄË¶ÅÈòüÂàó‰∏≠ÁöÑ‰∏Ä‰∏™ÂÖÉÁ¥†ÔºåÂê¶Âàô‰∏Ä‰∏™ÁºìÂÜ≤Âå∫Â∞ÜÈúÄË¶ÅÊØè‰∏™sgÂÖÉÁ¥†ÁöÑ‰∏Ä‰∏™ÂÖÉÁ¥†„ÄÇ</p>
<p>ÂΩìËÆæÂ§áÊ∂àËÄóÂÆåÈ©±Âä®Êèê‰æõÁöÑÁºìÂÜ≤Âå∫Êó∂ÔºåËøô‰∏™ÁªìÊûÑÊâÄÊåáÂêëÁöÑÂõûË∞ÉÂáΩÊï∞‰ºöË¢´Ëß¶Âèë„ÄÇÊõ¥ÂÖ∑‰ΩìÂú∞ËØ¥ÔºåËß¶ÂèëÂô®Â∞ÜÊòØÁî±ÁÆ°ÁêÜÁ®ãÂ∫èÂèëÂá∫ÁöÑ‰∏≠Êñ≠ÔºàËßÅ<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.vring_interrupt"><code>vring_interrupt()</code></a>Ôºâ„ÄÇ‰∏≠Êñ≠ËØ∑Ê±ÇÂ§ÑÁêÜÁ®ãÂ∫èÊòØÂú®ËôöÊãüÈòüÂàóËÆæÁΩÆËøáÁ®ã‰∏≠‰∏∫ËôöÊãüÈòüÂàóÊ≥®ÂÜåÁöÑÔºàÁâπÂÆö‰∫é‰º†ËæìÔºâ„ÄÇ</p>
<p>irqreturn_t <strong>vring_interrupt</strong>(int irq, void *_vq)</p>
<p>notify a virtqueue on an interrupt</p>
<p><strong>Parameters</strong></p>
<ul>
<li><p><code>int irq</code></p>
<p>the IRQ number (ignored)</p>
</li>
<li><p><code>void *_vq</code></p>
<p>the <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.virtqueue"><code>struct virtqueue</code></a> to notify</p>
</li>
</ul>
<p><strong>Description</strong></p>
<p>Calls the callback function of <strong>_vq</strong> to process the virtqueue notification.</p>
<h2 id="Device-discovery-and-probing"><a href="#Device-discovery-and-probing" class="headerlink" title="Device discovery and probing"></a>Device discovery and probing</h2><blockquote>
<p>In the kernel, the virtio core contains the virtio bus driver and transport-specific drivers like virtio-pci and virtio-mmio. Then there are individual virtio drivers for specific device types that are registered to the virtio bus driver.</p>
</blockquote>
<p>Âú®ÂÜÖÊ†∏‰∏≠ÔºåvirtioÊ†∏ÂøÉÂåÖÂê´virtioÊÄªÁ∫øÈ©±Âä®ÂíåÁâπÂÆöÁöÑ‰º†ËæìÈ©±Âä®ÔºåÂ¶Çvirtio-pciÂíåvirtio-mmio„ÄÇÁÑ∂ÂêéÔºåËøòÊúâÈíàÂØπÁâπÂÆöËÆæÂ§áÁ±ªÂûãÁöÑÂçïÁã¨ÁöÑvirtioÈ©±Âä®Á®ãÂ∫èÔºåÂÆÉ‰ª¨Ë¢´Ê≥®ÂÜåÂà∞virtioÊÄªÁ∫øÈ©±Âä®Á®ãÂ∫è‰∏ä„ÄÇ</p>
<blockquote>
<p>How a virtio device is found and configured by the kernel depends on how the hypervisor defines it. Taking the QEMU virtio-console device as an example. When using PCI as a transport method, the device will present itself on the PCI bus with vendor 0x1af4 (Red Hat, Inc.) and device id 0x1003 (virtio console), as defined in the spec, so the kernel will detect it as it would do with any other PCI device.</p>
</blockquote>
<p>ÂÜÖÊ†∏Â¶Ç‰ΩïÂèëÁé∞ÂíåÈÖçÁΩÆvirtioËÆæÂ§áÔºåÂèñÂÜ≥‰∫éÁÆ°ÁêÜÁ®ãÂ∫èÂ¶Ç‰ΩïÂÆö‰πâÂÆÉ„ÄÇ‰ª•QEMU virtio-consoleËÆæÂ§á‰∏∫‰æã„ÄÇÂΩì‰ΩøÁî®PCI‰Ωú‰∏∫‰º†ËæìÊñπÂºèÊó∂ÔºåËØ•ËÆæÂ§áÂ∞ÜÂú®PCIÊÄªÁ∫ø‰∏ä‰ª•‰æõÂ∫îÂïÜ0x1af4ÔºàRed Hat, Inc.ÔºâÂíåËÆæÂ§áID 0x1003Ôºàvirtio consoleÔºâÁöÑÂΩ¢ÂºèÂá∫Áé∞ÔºåÊ≠£Â¶ÇËßÑËåÉ‰∏≠ÊâÄÂÆö‰πâÁöÑÈÇ£Ê†∑ÔºåÊâÄ‰ª•ÂÜÖÊ†∏‰ºöÂÉèÊ£ÄÊµãÂÖ∂‰ªñPCIËÆæÂ§áÈÇ£Ê†∑Ê£ÄÊµãÂÆÉ„ÄÇ</p>
<blockquote>
<p>During the PCI enumeration process, if a device is found to match the virtio-pci driver (according to the virtio-pci device table, any PCI device with vendor id = 0x1af4):</p>
</blockquote>
<p>Âú®PCIÊûö‰∏æËøáÁ®ã‰∏≠ÔºåÂ¶ÇÊûúÂèëÁé∞‰∏Ä‰∏™ËÆæÂ§á‰∏évirtio-pciÈ©±Âä®Áõ∏ÂåπÈÖçÔºàÊ†πÊçÆvirtio-pciËÆæÂ§áË°®Ôºå‰ªª‰ΩïPCIËÆæÂ§áÁöÑÂéÇÂïÜID=0x1af4Ôºâ„ÄÇ</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Qumranet donated their vendor ID for devices 0x1000 thru 0x10FF. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> <span class="title">virtio_pci_id_table</span>[] =</span> &#123;</span><br><span class="line">        &#123; PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_ANY_ID) &#125;,</span><br><span class="line">        &#123; <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>then the virtio-pci driver is probed and, if the probing goes well, the device is registered to the virtio bus:</p>
</blockquote>
<p>ÁÑ∂ÂêéÂØπvirtio-pciÈ©±Âä®ËøõË°åÊé¢ÊµãÔºåÂ¶ÇÊûúÊé¢ÊµãÈ°∫Âà©ÔºåËØ•ËÆæÂ§áÂ∞±Ë¢´Ê≥®ÂÜåÂà∞virtioÊÄªÁ∫ø‰∏ä„ÄÇ</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">virtio_pci_probe</span><span class="params">(struct pci_dev *pci_dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct pci_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (force_legacy) &#123;</span><br><span class="line">                rc = virtio_pci_legacy_probe(vp_dev);</span><br><span class="line">                <span class="comment">/* Also try modern mode if we can&#x27;t map BAR0 (no IO space). */</span></span><br><span class="line">                <span class="keyword">if</span> (rc == -ENODEV || rc == -ENOMEM)</span><br><span class="line">                        rc = virtio_pci_modern_probe(vp_dev);</span><br><span class="line">                <span class="keyword">if</span> (rc)</span><br><span class="line">                        <span class="keyword">goto</span> err_probe;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rc = virtio_pci_modern_probe(vp_dev);</span><br><span class="line">                <span class="keyword">if</span> (rc == -ENODEV)</span><br><span class="line">                        rc = virtio_pci_legacy_probe(vp_dev);</span><br><span class="line">                <span class="keyword">if</span> (rc)</span><br><span class="line">                        <span class="keyword">goto</span> err_probe;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        rc = register_virtio_device(&amp;vp_dev-&gt;vdev);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>When the device is registered to the virtio bus the kernel will look for a driver in the bus that can handle the device and call that driver‚Äôs probe method.</p>
<p>At this point, the virtqueues will be allocated and configured by calling the appropriate virtio_find helper function, such as virtio_find_single_vq() or virtio_find_vqs(), which will end up calling a transport-specific find_vqs method.</p>
</blockquote>
<p>ÂΩìËÆæÂ§áË¢´Ê≥®ÂÜåÂà∞virtioÊÄªÁ∫ø‰∏äÊó∂ÔºåÂÜÖÊ†∏Â∞ÜÂú®ÊÄªÁ∫ø‰∏äÂØªÊâæ‰∏Ä‰∏™ÂèØ‰ª•Â§ÑÁêÜËØ•ËÆæÂ§áÁöÑÈ©±Âä®Á®ãÂ∫èÔºåÂπ∂Ë∞ÉÁî®ËØ•È©±Âä®Á®ãÂ∫èÁöÑÊé¢ÊµãÊñπÊ≥ï„ÄÇ</p>
<p>Ê≠§Êó∂ÔºåÂ∞ÜÈÄöËøáË∞ÉÁî®ÈÄÇÂΩìÁöÑvirtio_findËæÖÂä©ÂáΩÊï∞ÔºåÂ¶Çvirtio_find_single_vq()Êàñvirtio_find_vqs()Êù•ÂàÜÈÖçÂíåÈÖçÁΩÆvirtqueuesÔºåÊúÄÁªà‰ºöË∞ÉÁî®‰∏Ä‰∏™ÁâπÂÆö‰∫é‰º†ËæìÁöÑfind_vqsÊñπÊ≥ï„ÄÇ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/03/virtio-on-linux/" data-id="clesn3uub00004xwb5f94h8vb" data-title="Virtio on Linux" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/03/virtio-on-linux/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/03/virtio-on-linux/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cpu-feature-configuration-code-diving" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/cpu-feature-configuration-code-diving/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:48:22.000Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/libvirt/">libvirt</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/cpu-feature-configuration-code-diving/">Cpu feature configuration code diving</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>If disable a feature in libvirt domain xml configuration, what will happen?</p>
<h2 id="General-code-about-libvirt-cpu-conf"><a href="#General-code-about-libvirt-cpu-conf" class="headerlink" title="General code about libvirt cpu conf"></a>General code about libvirt cpu conf</h2><p>Read cpu_conf.c main entrance is <code>virCPUDefFormatBuf</code></p>
<p>Libvirt have two types format:</p>
<ul>
<li><code>CUSTOM</code>: user define model and features of a cpu conf</li>
<li><code>HOST_MODEL</code>: matches a most suitable feature list with host</li>
</ul>
<p>And while handle conf definition:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">formatModel = (def-&gt;mode == VIR_CPU_MODE_CUSTOM ||</span><br><span class="line">               def-&gt;mode == VIR_CPU_MODE_HOST_MODEL);</span><br><span class="line">formatFallback = (def-&gt;type == VIR_CPU_TYPE_GUEST &amp;&amp;</span><br><span class="line">                  (def-&gt;mode == VIR_CPU_MODE_HOST_MODEL ||</span><br><span class="line">                   (def-&gt;mode == VIR_CPU_MODE_CUSTOM &amp;&amp; def-&gt;model)));</span><br></pre></td></tr></table></figure>

<p>see the enum:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    VIR_CPU_TYPE_HOST,</span><br><span class="line">    VIR_CPU_TYPE_GUEST,</span><br><span class="line">    VIR_CPU_TYPE_AUTO,</span><br><span class="line"></span><br><span class="line">    VIR_CPU_TYPE_LAST</span><br><span class="line">&#125; virCPUType;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VIR_CPU_TYPE_AUTO</code> : detect the input xml to tell is guest or host cpu model definition</li>
<li><code>VIR_CPU_TYPE_GUEST</code> : guest cpu model means the cpu conf define from domain xml</li>
<li><code>VIR_CPU_TYPE_HOST</code> : host cpu model means the cpu conf load from host capabilities xml</li>
</ul>
<p>So the could focus on <code>formatFallback</code>. </p>
<p>Verification is required, if you use a custom mode without a cpu model is not allowed, because custom means you need specify a collections of cpu features and custom features of the subset.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!def-&gt;model &amp;&amp; def-&gt;mode == VIR_CPU_MODE_CUSTOM &amp;&amp; def-&gt;nfeatures) &#123;</span><br><span class="line">    virReportError(VIR_ERR_INTERNAL_ERROR, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                   _(<span class="string">&quot;Non-empty feature list specified without CPU model&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while define model, need to get a fallback value for guest cpu</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((formatModel &amp;&amp; def-&gt;model) || formatFallback) &#123;</span><br><span class="line">    virBufferAddLit(buf, <span class="string">&quot;&lt;model&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (formatFallback) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *fallback;</span><br><span class="line"></span><br><span class="line">        fallback = virCPUFallbackTypeToString(def-&gt;fallback);</span><br><span class="line">        <span class="keyword">if</span> (!fallback) &#123;</span><br><span class="line">            virReportError(VIR_ERR_INTERNAL_ERROR,</span><br><span class="line">                           _(<span class="string">&quot;Unexpected CPU fallback value: %d&quot;</span>),</span><br><span class="line">                           def-&gt;fallback);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        virBufferAsprintf(buf, <span class="string">&quot; fallback=&#x27;%s&#x27;&quot;</span>, fallback);</span><br><span class="line">        <span class="keyword">if</span> (def-&gt;vendor_id)</span><br><span class="line">            virBufferEscapeString(buf, <span class="string">&quot; vendor_id=&#x27;%s&#x27;&quot;</span>, def-&gt;vendor_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (formatModel &amp;&amp; def-&gt;model) &#123;</span><br><span class="line">        virBufferEscapeString(buf, <span class="string">&quot;&gt;%s&lt;/model&gt;\n&quot;</span>, def-&gt;model);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        virBufferAddLit(buf, <span class="string">&quot;/&gt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fallback type:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    VIR_CPU_FALLBACK_ALLOW,</span><br><span class="line">    VIR_CPU_FALLBACK_FORBID,</span><br><span class="line"></span><br><span class="line">    VIR_CPU_FALLBACK_LAST</span><br><span class="line">&#125; virCPUFallback;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VIR_CPU_FALLBACK_ALLOW</code> means just use the cpu capabilities from host capabilities xml</li>
<li><code>VIR_CPU_FALLBACK_FORBID</code>means can stop guest from start with unsupported feature</li>
</ul>
<p>Also the topology can be defined:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (def-&gt;sockets &amp;&amp; def-&gt;cores &amp;&amp; def-&gt;threads) &#123;</span><br><span class="line">    virBufferAddLit(buf, <span class="string">&quot;&lt;topology&quot;</span>);</span><br><span class="line">    virBufferAsprintf(buf, <span class="string">&quot; sockets=&#x27;%u&#x27;&quot;</span>, def-&gt;sockets);</span><br><span class="line">    virBufferAsprintf(buf, <span class="string">&quot; cores=&#x27;%u&#x27;&quot;</span>, def-&gt;cores);</span><br><span class="line">    virBufferAsprintf(buf, <span class="string">&quot; threads=&#x27;%u&#x27;&quot;</span>, def-&gt;threads);</span><br><span class="line">    virBufferAddLit(buf, <span class="string">&quot;/&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>from xml too.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; def-&gt;nfeatures; i++) &#123;</span><br><span class="line">    virCPUFeatureDefPtr feature = def-&gt;features + i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!feature-&gt;name) &#123;</span><br><span class="line">        virReportError(VIR_ERR_INTERNAL_ERROR, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                       _(<span class="string">&quot;Missing CPU feature name&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (def-&gt;type == VIR_CPU_TYPE_GUEST) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *policy;</span><br><span class="line"></span><br><span class="line">        policy = virCPUFeaturePolicyTypeToString(feature-&gt;policy);</span><br><span class="line">        <span class="keyword">if</span> (!policy) &#123;</span><br><span class="line">            virReportError(VIR_ERR_INTERNAL_ERROR,</span><br><span class="line">                           _(<span class="string">&quot;Unexpected CPU feature policy %d&quot;</span>),</span><br><span class="line">                           feature-&gt;policy);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        virBufferAsprintf(buf, <span class="string">&quot;&lt;feature policy=&#x27;%s&#x27; name=&#x27;%s&#x27;/&gt;\n&quot;</span>,</span><br><span class="line">                          policy, feature-&gt;name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        virBufferAsprintf(buf, <span class="string">&quot;&lt;feature name=&#x27;%s&#x27;/&gt;\n&quot;</span>,</span><br><span class="line">                          feature-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Features will follow policies:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VIR_ENUM_IMPL(virCPUFeaturePolicy, VIR_CPU_FEATURE_LAST,</span><br><span class="line">              <span class="string">&quot;force&quot;</span>,</span><br><span class="line">              <span class="string">&quot;require&quot;</span>,</span><br><span class="line">              <span class="string">&quot;optional&quot;</span>,</span><br><span class="line">              <span class="string">&quot;disable&quot;</span>,</span><br><span class="line">              <span class="string">&quot;forbid&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Following part explains about those policies.</p>
<p><strong>force</strong></p>
<p>The virtual CPU will claim the feature is supported regardless of it being supported by host CPU.</p>
<p><strong>require</strong></p>
<p>Guest creation will fail unless the feature is supported by the host CPU or the hypervisor is able to emulate it.</p>
<p><strong>optional</strong></p>
<p>The feature will be supported by virtual CPU if and only if it is supported by host CPU.</p>
<p><strong>disable</strong></p>
<p>The feature will not be supported by virtual CPU.</p>
<p><strong>forbid</strong></p>
<p>Guest creation will fail if the feature is supported by host CPU.</p>
<p><code>virCPUDefFormatBuf</code> is used by <code>capabilities.c</code> which collects host features from host capabilities xml. But now we need to check the code in <code>domain_capabilities.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> virCPUDef *virCPUDefPtr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">virCPUDef</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> type;           <span class="comment">/* enum virCPUType */</span></span><br><span class="line">    <span class="keyword">int</span> mode;           <span class="comment">/* enum virCPUMode */</span></span><br><span class="line">    <span class="keyword">int</span> match;          <span class="comment">/* enum virCPUMatch */</span></span><br><span class="line">    virCPUCheck check;</span><br><span class="line">    virArch arch;</span><br><span class="line">    <span class="keyword">char</span> *model;</span><br><span class="line">    <span class="keyword">char</span> *vendor_id;    <span class="comment">/* vendor id returned by CPUID in the guest */</span></span><br><span class="line">    <span class="keyword">int</span> fallback;       <span class="comment">/* enum virCPUFallback */</span></span><br><span class="line">    <span class="keyword">char</span> *vendor;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> microcodeVersion;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sockets;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cores;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> threads;</span><br><span class="line">    <span class="keyword">size_t</span> nfeatures;</span><br><span class="line">    <span class="keyword">size_t</span> nfeatures_max;</span><br><span class="line">    virCPUFeatureDefPtr features;</span><br><span class="line">    virCPUCacheDefPtr cache;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>nfeatures will be set in _virCPUDef and supported features are parsed from domain xml:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Parses CPU definition XML from a node pointed to by @xpath. If @xpath is</span></span><br><span class="line"><span class="comment"> * NULL, the current node of @ctxt is used (i.e., it is a shortcut to &quot;.&quot;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Missing &lt;cpu&gt; element in the XML document is not considered an error unless</span></span><br><span class="line"><span class="comment"> * @xpath is NULL in which case the function expects it was provided with a</span></span><br><span class="line"><span class="comment"> * valid &lt;cpu&gt; element already. In other words, the function returns success</span></span><br><span class="line"><span class="comment"> * and sets @cpu to NULL if @xpath is not NULL and the node pointed to by</span></span><br><span class="line"><span class="comment"> * @xpath is not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success, -1 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">virCPUDefParseXML(xmlXPathContextPtr ctxt,</span><br><span class="line">                  <span class="keyword">const</span> <span class="keyword">char</span> *xpath,</span><br><span class="line">                  virCPUType type,</span><br><span class="line">                  virCPUDefPtr *cpu)</span><br></pre></td></tr></table></figure>

<p>Finally, <code>qemu_command.c</code> would use those features to qemu commandline:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cpu-&gt;nfeatures; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (STREQ(<span class="string">&quot;rtm&quot;</span>, cpu-&gt;features[i].name))</span><br><span class="line">        rtm = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (STREQ(<span class="string">&quot;hle&quot;</span>, cpu-&gt;features[i].name))</span><br><span class="line">        hle = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ((virCPUFeaturePolicy) cpu-&gt;features[i].policy) &#123;</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_FORCE:</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_REQUIRE:</span><br><span class="line">        <span class="keyword">if</span> (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))</span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,%s=on&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,+%s&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_DISABLE:</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_FORBID:</span><br><span class="line">        <span class="keyword">if</span> (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))</span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,%s=off&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,-%s&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_OPTIONAL:</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_LAST:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>like <code>-cpu ... feature1=on,feature2=off</code> to make those features take effects.</p>
<h2 id="Turn-to-qemu"><a href="#Turn-to-qemu" class="headerlink" title="Turn to qemu"></a>Turn to qemu</h2><p>Firstly, qemu will parse input <code>-cpu ....</code> string:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">parse_cpu_model</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cpu_model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectClass *oc;</span><br><span class="line">    CPUClass *cc;</span><br><span class="line">    gchar **model_pieces;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cpu_type;</span><br><span class="line"></span><br><span class="line">    model_pieces = g_strsplit(cpu_model, <span class="string">&quot;,&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    oc = cpu_class_by_name(CPU_RESOLVING_TYPE, model_pieces[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (oc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;unable to find CPU model &#x27;%s&#x27;&quot;</span>, model_pieces[<span class="number">0</span>]);</span><br><span class="line">        g_strfreev(model_pieces);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpu_type = object_class_get_name(oc);</span><br><span class="line">    cc = CPU_CLASS(oc);</span><br><span class="line">    cc-&gt;parse_features(cpu_type, model_pieces[<span class="number">1</span>], &amp;error_fatal);</span><br><span class="line">    g_strfreev(model_pieces);</span><br><span class="line">    <span class="keyword">return</span> cpu_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>An object from <code>oc = cpu_class_by_name(CPU_RESOLVING_TYPE, model_pieces[0]);</code>will return a cpu object class which support parse features. See following code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_common_parse_features</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">typename</span>, <span class="keyword">char</span> *features,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *val;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> cpu_globals_initialized;</span><br><span class="line">    <span class="comment">/* Single &quot;key=value&quot; string being parsed */</span></span><br><span class="line">    <span class="keyword">char</span> *featurestr = features ? strtok(features, <span class="string">&quot;,&quot;</span>) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should be called only once, catch invalid users */</span></span><br><span class="line">    assert(!cpu_globals_initialized);</span><br><span class="line">    cpu_globals_initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (featurestr) &#123;</span><br><span class="line">        val = <span class="built_in">strchr</span>(featurestr, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">            GlobalProperty *prop = g_new0(typeof(*prop), <span class="number">1</span>);</span><br><span class="line">            *val = <span class="number">0</span>;</span><br><span class="line">            val++;</span><br><span class="line">            prop-&gt;driver = <span class="keyword">typename</span>;</span><br><span class="line">            prop-&gt;property = g_strdup(featurestr);</span><br><span class="line">            prop-&gt;value = g_strdup(val);</span><br><span class="line">            prop-&gt;errp = &amp;error_fatal;</span><br><span class="line">            qdev_prop_register_global(prop);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;Expected key=value format, found %s.&quot;</span>,</span><br><span class="line">                       featurestr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        featurestr = strtok(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>key=value</code> format will be parse and store into qemu‚Äôs global property.</p>
<p>From: <code>target/i386/cpu.c</code></p>
<p>qemu defined <code>#define CPUID_EXT_HYPERVISOR  (1U &lt;&lt; 31)</code> for CPUID EXT to expose hypervisor information.</p>
<p>Then x86 cpu will use those global properties to initialize vcpu:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Parse &quot;+feature,-feature,feature=foo&quot; CPU feature string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_parse_featurestr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">typename</span>, <span class="keyword">char</span> *features,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *featurestr; <span class="comment">/* Single &#x27;key=value&quot; string being parsed */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> cpu_globals_initialized;</span><br><span class="line">    <span class="keyword">bool</span> ambiguous = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpu_globals_initialized) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cpu_globals_initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!features) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (featurestr = strtok(features, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">         featurestr;</span><br><span class="line">         featurestr = strtok(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *val = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> *eq = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> num[<span class="number">32</span>];</span><br><span class="line">        GlobalProperty *prop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Compatibility syntax: */</span></span><br><span class="line">        <span class="keyword">if</span> (featurestr[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            plus_features = g_list_append(plus_features,</span><br><span class="line">                                          g_strdup(featurestr + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (featurestr[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            minus_features = g_list_append(minus_features,</span><br><span class="line">                                           g_strdup(featurestr + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eq = <span class="built_in">strchr</span>(featurestr, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eq) &#123;</span><br><span class="line">            *eq++ = <span class="number">0</span>;</span><br><span class="line">            val = eq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        feat2prop(featurestr);</span><br><span class="line">        name = featurestr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_list_find_custom(plus_features, name, compare_string)) &#123;</span><br><span class="line">            warn_report(<span class="string">&quot;Ambiguous CPU model string. &quot;</span></span><br><span class="line">                        <span class="string">&quot;Don&#x27;t mix both \&quot;+%s\&quot; and \&quot;%s=%s\&quot;&quot;</span>,</span><br><span class="line">                        name, name, val);</span><br><span class="line">            ambiguous = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g_list_find_custom(minus_features, name, compare_string)) &#123;</span><br><span class="line">            warn_report(<span class="string">&quot;Ambiguous CPU model string. &quot;</span></span><br><span class="line">                        <span class="string">&quot;Don&#x27;t mix both \&quot;-%s\&quot; and \&quot;%s=%s\&quot;&quot;</span>,</span><br><span class="line">                        name, name, val);</span><br><span class="line">            ambiguous = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Special case: */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;tsc-freq&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret;</span><br><span class="line">            <span class="keyword">uint64_t</span> tsc_freq;</span><br><span class="line"></span><br><span class="line">            ret = qemu_strtosz_metric(val, <span class="literal">NULL</span>, &amp;tsc_freq);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span> || tsc_freq &gt; INT64_MAX) &#123;</span><br><span class="line">                error_setg(errp, <span class="string">&quot;bad numerical value %s&quot;</span>, val);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">snprintf</span>(num, <span class="keyword">sizeof</span>(num), <span class="string">&quot;%&quot;</span> PRId64, tsc_freq);</span><br><span class="line">            val = num;</span><br><span class="line">            name = <span class="string">&quot;tsc-frequency&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prop = g_new0(typeof(*prop), <span class="number">1</span>);</span><br><span class="line">        prop-&gt;driver = <span class="keyword">typename</span>;</span><br><span class="line">        prop-&gt;property = g_strdup(name);</span><br><span class="line">        prop-&gt;value = g_strdup(val);</span><br><span class="line">        prop-&gt;errp = &amp;error_fatal;</span><br><span class="line">        qdev_prop_register_global(prop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ambiguous) &#123;</span><br><span class="line">        warn_report(<span class="string">&quot;Compatibility of ambiguous CPU model &quot;</span></span><br><span class="line">                    <span class="string">&quot;strings won&#x27;t be kept on future QEMU versions&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which is registered as <code>cc-&gt;parse_features = x86_cpu_parse_featurestr;</code>.</p>
<p>features from qemu commandline will be put as global property for x86 cpu.</p>
<p>And before start virtual machine, qemu will insure there is not unavailable or missing features:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_get_unavailable_features</span><span class="params">(Object *obj, Visitor *v,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *opaque,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X86CPU *xc = X86_CPU(obj);</span><br><span class="line">    strList *result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    x86_cpu_list_feature_names(xc-&gt;filtered_features, &amp;result);</span><br><span class="line">    visit_type_strList(v, <span class="string">&quot;unavailable-features&quot;</span>, &amp;result, errp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for missing features that may prevent the CPU class from</span></span><br><span class="line"><span class="comment"> * running using the current machine and accelerator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_class_check_missing_features</span><span class="params">(X86CPUClass *xcc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 strList **missing_feats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X86CPU *xc;</span><br><span class="line">    Error *err = <span class="literal">NULL</span>;</span><br><span class="line">    strList **next = missing_feats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xcc-&gt;host_cpuid_required &amp;&amp; !accel_uses_host_cpuid()) &#123;</span><br><span class="line">        strList *<span class="keyword">new</span> = g_new0(strList, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span>-&gt;value = g_strdup(<span class="string">&quot;kvm&quot;</span>);</span><br><span class="line">        *missing_feats = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xc = X86_CPU(object_new(object_class_get_name(OBJECT_CLASS(xcc))));</span><br><span class="line"></span><br><span class="line">    x86_cpu_expand_features(xc, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">/* Errors at x86_cpu_expand_features should never happen,</span></span><br><span class="line"><span class="comment">         * but in case it does, just report the model as not</span></span><br><span class="line"><span class="comment">         * runnable at all using the &quot;type&quot; property.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        strList *<span class="keyword">new</span> = g_new0(strList, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span>-&gt;value = g_strdup(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">        *next = <span class="keyword">new</span>;</span><br><span class="line">        next = &amp;<span class="keyword">new</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x86_cpu_filter_features(xc, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    x86_cpu_list_feature_names(xc-&gt;filtered_features, next);</span><br><span class="line"></span><br><span class="line">    object_unref(OBJECT(xc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while qemu init cpu:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_realizefn</span><span class="params">(DeviceState *dev, Error **errp)</span></span></span><br></pre></td></tr></table></figure>

<p>features will be set to a CPU object:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>we could find ‚Äúhypervisor‚Äù related cpu features defined by <code>FEAT_1_ECX</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[FEAT_1_ECX] = &#123;</span><br><span class="line">    .type = CPUID_FEATURE_WORD,</span><br><span class="line">    .feat_names = &#123;</span><br><span class="line">        <span class="string">&quot;pni&quot;</span> <span class="comment">/* Intel,AMD sse3 */</span>, <span class="string">&quot;pclmulqdq&quot;</span>, <span class="string">&quot;dtes64&quot;</span>, <span class="string">&quot;monitor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ds-cpl&quot;</span>, <span class="string">&quot;vmx&quot;</span>, <span class="string">&quot;smx&quot;</span>, <span class="string">&quot;est&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tm2&quot;</span>, <span class="string">&quot;ssse3&quot;</span>, <span class="string">&quot;cid&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="string">&quot;fma&quot;</span>, <span class="string">&quot;cx16&quot;</span>, <span class="string">&quot;xtpr&quot;</span>, <span class="string">&quot;pdcm&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">&quot;pcid&quot;</span>, <span class="string">&quot;dca&quot;</span>, <span class="string">&quot;sse4.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sse4.2&quot;</span>, <span class="string">&quot;x2apic&quot;</span>, <span class="string">&quot;movbe&quot;</span>, <span class="string">&quot;popcnt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tsc-deadline&quot;</span>, <span class="string">&quot;aes&quot;</span>, <span class="string">&quot;xsave&quot;</span>, <span class="string">&quot;osxsave&quot;</span>,</span><br><span class="line">        <span class="string">&quot;avx&quot;</span>, <span class="string">&quot;f16c&quot;</span>, <span class="string">&quot;rdrand&quot;</span>, <span class="string">&quot;hypervisor&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .cpuid = &#123; .eax = <span class="number">1</span>, .reg = R_ECX, &#125;,</span><br><span class="line">    .tcg_features = TCG_EXT_FEATURES,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>then cpu will read those features with key words:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Finishes initialization of CPUID data, filters CPU feature</span></span><br><span class="line"><span class="comment"> * words based on host availability of each feature.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: 0 if all flags are supported by the host, non-zero otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_filter_features</span><span class="params">(X86CPU *cpu, <span class="keyword">bool</span> verbose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPUX86State *env = &amp;cpu-&gt;env;</span><br><span class="line">    FeatureWord w;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prefix = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        prefix = accel_uses_host_cpuid()</span><br><span class="line">                 ? <span class="string">&quot;host doesn&#x27;t support requested feature&quot;</span></span><br><span class="line">                 : <span class="string">&quot;TCG doesn&#x27;t support requested feature&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; FEATURE_WORDS; w++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> host_feat =</span><br><span class="line">            x86_cpu_get_supported_feature_word(w, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">uint64_t</span> requested_features = env-&gt;features[w];</span><br><span class="line">        <span class="keyword">uint64_t</span> unavailable_features = requested_features &amp; ~host_feat;</span><br><span class="line">        mark_unavailable_features(cpu, w, unavailable_features, prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((env-&gt;features[FEAT_7_0_EBX] &amp; CPUID_7_0_EBX_INTEL_PT) &amp;&amp;</span><br><span class="line">        kvm_enabled()) &#123;</span><br><span class="line">        KVMState *s = CPU(cpu)-&gt;kvm_state;</span><br><span class="line">        <span class="keyword">uint32_t</span> eax_0 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">0</span>, R_EAX);</span><br><span class="line">        <span class="keyword">uint32_t</span> ebx_0 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">0</span>, R_EBX);</span><br><span class="line">        <span class="keyword">uint32_t</span> ecx_0 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">0</span>, R_ECX);</span><br><span class="line">        <span class="keyword">uint32_t</span> eax_1 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">1</span>, R_EAX);</span><br><span class="line">        <span class="keyword">uint32_t</span> ebx_1 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">1</span>, R_EBX);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!eax_0 ||</span><br><span class="line">           ((ebx_0 &amp; INTEL_PT_MINIMAL_EBX) != INTEL_PT_MINIMAL_EBX) ||</span><br><span class="line">           ((ecx_0 &amp; INTEL_PT_MINIMAL_ECX) != INTEL_PT_MINIMAL_ECX) ||</span><br><span class="line">           ((eax_1 &amp; INTEL_PT_MTC_BITMAP) != INTEL_PT_MTC_BITMAP) ||</span><br><span class="line">           ((eax_1 &amp; INTEL_PT_ADDR_RANGES_NUM_MASK) &lt;</span><br><span class="line">                                           INTEL_PT_ADDR_RANGES_NUM) ||</span><br><span class="line">           ((ebx_1 &amp; (INTEL_PT_PSB_BITMAP | INTEL_PT_CYCLE_BITMAP)) !=</span><br><span class="line">                (INTEL_PT_PSB_BITMAP | INTEL_PT_CYCLE_BITMAP)) ||</span><br><span class="line">           (ecx_0 &amp; INTEL_PT_IP_LIP)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Processor Trace capabilities aren&#x27;t configurable, so if the</span></span><br><span class="line"><span class="comment">             * host can&#x27;t emulate the capabilities we report on</span></span><br><span class="line"><span class="comment">             * cpu_x86_cpuid(), intel-pt can&#x27;t be enabled on the current host.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mark_unavailable_features(cpu, FEAT_7_0_EBX, CPUID_7_0_EBX_INTEL_PT, prefix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mainly the features is set by:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; FEATURE_WORDS; w++) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> host_feat =</span><br><span class="line">        x86_cpu_get_supported_feature_word(w, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> requested_features = env-&gt;features[w];</span><br><span class="line">    <span class="keyword">uint64_t</span> unavailable_features = requested_features &amp; ~host_feat;</span><br><span class="line">    mark_unavailable_features(cpu, w, unavailable_features, prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this part and supported feature keeps 0 because </p>
<p><code>requested_features &amp; ~host_feat</code> host unavialable features would be <code>~</code> at first.</p>
<p>We can dump those configurations from qemu vcpu to check is usage. </p>
<h2 id="How-kernel-use-it"><a href="#How-kernel-use-it" class="headerlink" title="How kernel use it"></a>How kernel use it</h2><p>Then we move to linux kernel check about those features usages.</p>
<p><code>#define X86_FEATURE_HYPERVISOR  (4*32+31) /* Running on a hypervisor */</code></p>
<p>kernel use <code>X86_FEATURE_HYPERVISOR</code> means if running on hypervisor.</p>
<h2 id="Hand-on-test"><a href="#Hand-on-test" class="headerlink" title="Hand on test"></a>Hand on test</h2><p>Now try to run a guest detecting hypervisor and figure out how to bypass the detection by virtualization level configs.</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><a target="_blank" rel="noopener" href="http://www.etallen.com/cpuid.html">http://www.etallen.com/cpuid.html</a> use a cpuid tool to dump cpu id of a guest to check our configuration.</p>
<p>By run <code>cpuid</code> to dump features, we can see following output with our expected values:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">feature information (1/ecx):</span><br><span class="line">   PNI/SSE3: Prescott New Instructions     = true</span><br><span class="line">   PCLMULDQ instruction                    = true</span><br><span class="line">   DTES64: 64-bit debug store              = false</span><br><span class="line">   MONITOR/MWAIT                           = false</span><br><span class="line">   CPL-qualified debug store               = false</span><br><span class="line">   VMX: virtual machine extensions         = true</span><br><span class="line">   SMX: safer mode extensions              = false</span><br><span class="line">   Enhanced Intel SpeedStep Technology     = false</span><br><span class="line">   TM2: thermal monitor 2                  = false</span><br><span class="line">   SSSE3 extensions                        = true</span><br><span class="line">   context ID: adaptive or shared L1 data  = false</span><br><span class="line">   SDBG: IA32_DEBUG_INTERFACE              = false</span><br><span class="line">   FMA instruction                         = true</span><br><span class="line">   CMPXCHG16B instruction                  = true</span><br><span class="line">   xTPR disable                            = false</span><br><span class="line">   PDCM: perfmon and debug                 = false</span><br><span class="line">   PCID: process context identifiers       = true</span><br><span class="line">   DCA: direct cache access                = false</span><br><span class="line">   SSE4.1 extensions                       = true</span><br><span class="line">   SSE4.2 extensions                       = true</span><br><span class="line">   x2APIC: extended xAPIC support          = true</span><br><span class="line">   MOVBE instruction                       = true</span><br><span class="line">   POPCNT instruction                      = true</span><br><span class="line">   time stamp counter deadline             = true</span><br><span class="line">   AES instruction                         = true</span><br><span class="line">   XSAVE/XSTOR states                      = true</span><br><span class="line">   OS-enabled XSAVE/XSTOR                  = true</span><br><span class="line">   AVX: advanced vector extensions         = true</span><br><span class="line">   F16C half-precision convert instruction = true</span><br><span class="line">   RDRAND instruction                      = true</span><br><span class="line">   hypervisor guest status                 = true</span><br></pre></td></tr></table></figure>

<p>the <code>hypervisor guest status                 = true</code> matches with linux kernel‚Äôs definition.</p>
<p>While with hypervisor feature disabled the output changed to:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">feature <span class="title">information</span> <span class="params">(<span class="number">1</span>/edx)</span>:</span></span><br><span class="line"><span class="function">   x87 FPU on chip                        </span>= <span class="literal">true</span></span><br><span class="line">   VME: <span class="keyword">virtual</span><span class="number">-8086</span> mode enhancement     = <span class="literal">true</span></span><br><span class="line">   DE: debugging extensions               = <span class="literal">true</span></span><br><span class="line">   PSE: page size extensions              = <span class="literal">true</span></span><br><span class="line">   TSC: time stamp counter                = <span class="literal">true</span></span><br><span class="line">   RDMSR <span class="keyword">and</span> WRMSR support                = <span class="literal">true</span></span><br><span class="line">   PAE: physical address extensions       = <span class="literal">true</span></span><br><span class="line">   MCE: machine check exception           = <span class="literal">true</span></span><br><span class="line">   CMPXCHG8B inst.                        = <span class="literal">true</span></span><br><span class="line">   APIC on chip                           = <span class="literal">true</span></span><br><span class="line">   SYSENTER <span class="keyword">and</span> SYSEXIT                   = <span class="literal">true</span></span><br><span class="line">   MTRR: memory type range registers      = <span class="literal">true</span></span><br><span class="line">   PTE global bit                         = <span class="literal">true</span></span><br><span class="line">   MCA: machine check architecture        = <span class="literal">true</span></span><br><span class="line">   CMOV: conditional move/compare instr   = <span class="literal">true</span></span><br><span class="line">   PAT: page attribute table              = <span class="literal">true</span></span><br><span class="line">   PSE<span class="number">-36</span>: page size extension            = <span class="literal">true</span></span><br><span class="line">   PSN: processor serial number           = <span class="literal">false</span></span><br><span class="line">   CLFLUSH instruction                    = <span class="literal">true</span></span><br><span class="line">   DS: debug store                        = <span class="literal">false</span></span><br><span class="line">   ACPI: thermal monitor <span class="keyword">and</span> clock ctrl   = <span class="literal">false</span></span><br><span class="line">   MMX Technology                         = <span class="literal">true</span></span><br><span class="line">   FXSAVE/FXRSTOR                         = <span class="literal">true</span></span><br><span class="line">   SSE extensions                         = <span class="literal">true</span></span><br><span class="line">   SSE2 extensions                        = <span class="literal">true</span></span><br><span class="line">   SS: self snoop                         = <span class="literal">true</span></span><br><span class="line">   hyper-threading / multi-core supported = <span class="literal">true</span></span><br><span class="line">   TM: therm. monitor                     = <span class="literal">false</span></span><br><span class="line">   IA64                                   = <span class="literal">false</span></span><br><span class="line">   PBE: pending <span class="keyword">break</span> event               = <span class="literal">false</span></span><br><span class="line">feature information (<span class="number">1</span>/ecx):</span><br><span class="line">   PNI/SSE3: Prescott New Instructions     = <span class="literal">true</span></span><br><span class="line">   PCLMULDQ instruction                    = <span class="literal">true</span></span><br><span class="line">   DTES64: <span class="number">64</span>-bit debug store              = <span class="literal">false</span></span><br><span class="line">   MONITOR/MWAIT                           = <span class="literal">false</span></span><br><span class="line">   CPL-qualified debug store               = <span class="literal">false</span></span><br><span class="line">   VMX: <span class="keyword">virtual</span> machine extensions         = <span class="literal">true</span></span><br><span class="line">   SMX: safer mode extensions              = <span class="literal">false</span></span><br><span class="line">   Enhanced Intel SpeedStep Technology     = <span class="literal">false</span></span><br><span class="line">   TM2: thermal monitor <span class="number">2</span>                  = <span class="literal">false</span></span><br><span class="line">   SSSE3 extensions                        = <span class="literal">true</span></span><br><span class="line">   context ID: adaptive <span class="keyword">or</span> shared L1 data  = <span class="literal">false</span></span><br><span class="line">   SDBG: IA32_DEBUG_INTERFACE              = <span class="literal">false</span></span><br><span class="line">   FMA instruction                         = <span class="literal">true</span></span><br><span class="line">   CMPXCHG16B instruction                  = <span class="literal">true</span></span><br><span class="line">   xTPR disable                            = <span class="literal">false</span></span><br><span class="line">   PDCM: perfmon <span class="keyword">and</span> debug                 = <span class="literal">false</span></span><br><span class="line">   PCID: process context identifiers       = <span class="literal">true</span></span><br><span class="line">   DCA: direct cache access                = <span class="literal">false</span></span><br><span class="line">   SSE4<span class="number">.1</span> extensions                       = <span class="literal">true</span></span><br><span class="line">   SSE4<span class="number">.2</span> extensions                       = <span class="literal">true</span></span><br><span class="line">   x2APIC: extended xAPIC support          = <span class="literal">true</span></span><br><span class="line">   MOVBE instruction                       = <span class="literal">true</span></span><br><span class="line">   POPCNT instruction                      = <span class="literal">true</span></span><br><span class="line">   time stamp counter deadline             = <span class="literal">true</span></span><br><span class="line">   AES instruction                         = <span class="literal">true</span></span><br><span class="line">   XSAVE/XSTOR states                      = <span class="literal">true</span></span><br><span class="line">   OS-enabled XSAVE/XSTOR                  = <span class="literal">true</span></span><br><span class="line">   AVX: advanced <span class="built_in">vector</span> extensions         = <span class="literal">true</span></span><br><span class="line">   F16C half-precision convert instruction = <span class="literal">true</span></span><br><span class="line">   RDRAND instruction                      = <span class="literal">true</span></span><br><span class="line">   hypervisor guest status                 = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>the <code>hypervisor guest status                 = false</code> value changed as expected.</p>
<h4 id="Linux-drawbacks"><a href="#Linux-drawbacks" class="headerlink" title="Linux drawbacks"></a>Linux drawbacks</h4><p>Read the usage about <code>X86_FEATURE_HYPERVISOR</code> in linux kernel. Some drawbacks can be found in kernel code directly.</p>
<p>From <code>qspintlock.h</code> :    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RHEL7 specific:</span></span><br><span class="line"><span class="comment"> * To provide backward compatibility with pre-7.4 kernel modules that</span></span><br><span class="line"><span class="comment"> * inlines the ticket spinlock unlock code. The virt_spin_lock() function</span></span><br><span class="line"><span class="comment"> * will have to recognize both a lock value of 0 or _Q_UNLOCKED_VAL as</span></span><br><span class="line"><span class="comment"> * being in an unlocked state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">virt_spin_lock</span><span class="params">(struct qspinlock *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lockval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!static_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>Slow spin lock will not be detected.</p>
<p>From <code>paravirt-spinlocks.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">queued_enable_pv_ticketlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!static_cpu_has(X86_FEATURE_HYPERVISOR) ||</span><br><span class="line">	   (pv_lock_ops.queued_spin_lock_slowpath !=</span><br><span class="line">	    native_queued_spin_lock_slowpath))</span><br><span class="line">		static_key_slow_inc(&amp;paravirt_ticketlocks_enabled);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>From <code>tsc.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t enable ART in a VM, non-stop TSC required,</span></span><br><span class="line"><span class="comment"> * and the TSC counter resets must not occur asynchronously.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (boot_cpu_has(X86_FEATURE_HYPERVISOR) ||</span><br><span class="line">    !boot_cpu_has(X86_FEATURE_NONSTOP_TSC) ||</span><br><span class="line">    art_to_tsc_denominator &lt; ART_MIN_DENOMINATOR ||</span><br><span class="line">    tsc_async_resets)</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>Always run timer will be started which actually should not be enabled.</p>
<p>From <code>apic.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER) ||</span><br><span class="line">    boot_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>From <code>mshyperv.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!boot_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>Can not detect if run on hyperv.</p>
<p>From <code>radeon_device</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * radeon_device_is_virtual - check if we are running is a virtual environment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Check if the asic has been passed through to a VM (all asics).</span></span><br><span class="line"><span class="comment"> * Used at driver startup.</span></span><br><span class="line"><span class="comment"> * Returns true if virtual or false if not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">radeon_device_is_virtual</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">	<span class="keyword">return</span> boot_cpu_has(X86_FEATURE_HYPERVISOR);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Radeon gpu will not detect it is running as guest.</p>
<p>For kernel it may failed to detect that it is running over hypervisor. So related performance improvement changed won‚Äôt be applied so there will be a performance drop for those guests.</p>
<p>So does the userspace application also can not do specific things without knowing it is running in virtual machine.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/01/cpu-feature-configuration-code-diving/" data-id="clepog9dl0000fdwb444cfiz4" data-title="Cpu feature configuration code diving" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/01/cpu-feature-configuration-code-diving/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/01/cpu-feature-configuration-code-diving/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-packed-virtqueue-how-to-reduce-overhead-with-virtio" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" class="article-date">
  <time class="dt-published" datetime="2023-02-23T15:13:20.000Z" itemprop="datePublished">2023-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/">Packed virtqueue: How to reduce overhead with virtio</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>This is the final post of a three-post series, the previous posts are ‚Äú<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">Virtio devices and drivers overview: The headjack and the phone</a>,‚Äù and ‚Äú<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtqueues-and-virtio-ring-how-data-travels">Virtqueues and virtio ring: How the data travels</a>.‚Äù</p>
</blockquote>
<p> ËøôÊòØ‰∏âÁØáÁ≥ªÂàóÊñáÁ´†ÁöÑÊúÄÂêé‰∏ÄÁØáÔºå‰πãÂâçÁöÑÊñáÁ´†ÊòØ‚Äù<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">VirtioËÆæÂ§áÂíåÈ©±Âä®Ê¶ÇËø∞ÔºöÂ§¥Êà¥ÂºèËÄ≥Êú∫ÂíåÊâãÊú∫</a>‚ÄúÔºå‰ª•Âèä‚Äù<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtqueues-and-virtio-ring-how-data-travels">VirtqueuesÂíåvirtioÁéØÔºöÊï∞ÊçÆÂ¶Ç‰Ωï‰º†Ëæì</a>‚Äú„ÄÇ</p>
<h2 id="Split-virtqueue-issues-Too-much-spinning-around"><a href="#Split-virtqueue-issues-Too-much-spinning-around" class="headerlink" title="Split virtqueue issues: Too much spinning around"></a>Split virtqueue issues: Too much spinning around</h2><blockquote>
<p>While the split virtqueue shines because of the simplicity of its design, it has a fundamental problem: The avail-used buffer cycle needs to use memory in a very sparse way. This puts pressure on the CPU cache utilization, and in the case of hardware means several PCI transactions for each descriptor.</p>
</blockquote>
<p>ËôΩÁÑ∂split virtqueueÂõ†ÂÖ∂ËÆæËÆ°ÁöÑÁÆÄÂçïÊÄßËÄåÂ§ßÊîæÂºÇÂΩ©Ôºå‰ΩÜÂÆÉÊúâ‰∏Ä‰∏™Âü∫Êú¨ÈóÆÈ¢òÔºöÂèØÁî®ÁöÑÁºìÂÜ≤Âå∫ÁéØÈúÄË¶Å‰ª•‰∏ÄÁßçÈùûÂ∏∏Á®ÄÁñèÁöÑÊñπÂºè‰ΩøÁî®ÂÜÖÂ≠ò„ÄÇËøôÁªôCPUÁöÑÁºìÂ≠òÂà©Áî®ÁéáÂ∏¶Êù•‰∫ÜÂéãÂäõÔºåÂú®Á°¨‰ª∂ÁöÑÊÉÖÂÜµ‰∏ãÔºåÊÑèÂë≥ÁùÄÊØè‰∏™ÊèèËø∞Á¨¶ÈÉΩË¶ÅÊúâÂá†‰∏™PCI‰∫ãÂä°„ÄÇ</p>
<blockquote>
<p>Packed virtqueue amends it by merging the three rings in just one location in virtual environment guest memory. While this may seem complicated at first glance, it‚Äôs a natural step after the split version if we realize that the device can discard and overwrite the data it already has read from the driver, and the same happens the other way around.</p>
</blockquote>
<p>Packed virtqueueÂØπÂÖ∂ËøõË°å‰∫Ü‰øÆÊ≠£ÔºåÂ∞Ü‰∏â‰∏™ÁéØÂêàÂπ∂Âú®ËôöÊãüÁéØÂ¢ÉguestÂÜÖÂ≠òÁöÑ‰∏Ä‰∏™‰ΩçÁΩÆ„ÄÇËôΩÁÑ∂Ëøô‰πçÁúãËµ∑Êù•ÂæàÂ§çÊùÇÔºå‰ΩÜÂ¶ÇÊûúÊàë‰ª¨ÊÑèËØÜÂà∞ËÆæÂ§áÂèØ‰ª•‰∏¢ÂºÉÂíåË¶ÜÁõñÂÆÉÂ∑≤Áªè‰ªéÈ©±Âä®‰∏≠ËØªÂèñÁöÑÊï∞ÊçÆÔºåÈÇ£‰πàËøôÂ∞±ÊòØÂàÜË£ÇÁâàÊú¨‰πãÂêéÁöÑ‰∏Ä‰∏™Ëá™ÁÑ∂Ê≠•È™§ÔºåÂèç‰πã‰∫¶ÁÑ∂„ÄÇ</p>
<h3 id="Supplying-descriptors-to-the-device-How-to-fill-device-todo-list"><a href="#Supplying-descriptors-to-the-device-How-to-fill-device-todo-list" class="headerlink" title="Supplying descriptors to the device: How to fill device todo-list"></a>Supplying descriptors to the device: How to fill device todo-list</h3><blockquote>
<p>After initialization in the same process as described in Virtio device initialization: feature bits, and after the agreement on RING_PACKED feature flag, the driver and the device starts with a shared blank canvas of descriptors with an agreed length (up to 215 entries) in a agreed guest‚Äôs memory location. The layout of these descriptors is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_desc</span> &#123;</span> </span><br><span class="line">        le64 addr;</span><br><span class="line">        le32 len;</span><br><span class="line">        le16 id;</span><br><span class="line">        le16 flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Memory layout of a packed virtqueue descriptor</strong></p>
</blockquote>
<p>Âú®VirtioËÆæÂ§áÂàùÂßãÂåñÔºöÁâπÂæÅ‰Ωç‰∏≠ÊèèËø∞ÁöÑÁõ∏ÂêåËøáÁ®ã‰∏≠ËøõË°åÂàùÂßãÂåñÂêéÔºåÂú®Â∞±RING_PACKEDÁâπÂæÅÊ†áÂøóËææÊàê‰∏ÄËá¥ÂêéÔºåÈ©±Âä®Á®ãÂ∫èÂíåËÆæÂ§áÂºÄÂßãÂú®ÂïÜÂÆöÁöÑÂÆ¢‰ΩìÂÜÖÂ≠ò‰ΩçÁΩÆ‰∏äÂÖ±‰∫´‰∏Ä‰∏™Á©∫ÁôΩÁöÑÊèèËø∞Á¨¶ÔºåÂÖ∂ÈïøÂ∫¶ÊòØÂïÜÂÆöÁöÑÔºàÊúÄÂ§ö215Êù°Ôºâ„ÄÇËøô‰∫õÊèèËø∞Á¨¶ÁöÑÂ∏ÉÂ±ÄÊòØÔºö„ÄÇ</p>
<blockquote>
<p>This time, the id field is not an index for the device to look for the buffer: it is an opaque value for it, only has meaning for the driver.</p>
<p>The driver also maintains an internal single-bit ring wrap counter initialized to 1. The driver will flip its value every time it makes available the last descriptor in the ring.</p>
<p>As with split descriptors, the first step is to write the different fields: address, length, id and flags. However, packed descriptors take into account two new flags: <code>AVAIL(0x7)</code> and <code>USED(0x15)</code>. To mark a descriptor as available, the driver makes the <code>AVAIL(0x7)</code> flag the same as its internal wrap counter, and the used flag the inverse. While just a binary flag avail/used would be easier to implement, it would prevent useful optimizations we will describe later.</p>
</blockquote>
<p>Ëøô‰∏ÄÊ¨°ÔºåidÂ≠óÊÆµ‰∏çÊòØËÆæÂ§áÂØªÊâæÁºìÂÜ≤Âå∫ÁöÑÁ¥¢ÂºïÔºöÂÆÉÊòØ‰∏Ä‰∏™‰∏çÈÄèÊòéÁöÑÂÄºÔºåÂè™ÂØπÈ©±Âä®ÊúâÊÑè‰πâ„ÄÇ</p>
<p>È©±Âä®Á®ãÂ∫èËøòÁª¥Êä§‰∏Ä‰∏™ÂÜÖÈÉ®ÁöÑÂçïÊØîÁâπÁéØÂΩ¢Áº†ÁªïËÆ°Êï∞Âô®ÔºåÂàùÂßãÂåñ‰∏∫1ÔºåÊØèÊ¨°Êèê‰æõÁéØÂΩ¢ÁöÑÊúÄÂêé‰∏Ä‰∏™ÊèèËø∞Á¨¶Êó∂ÔºåÈ©±Âä®Á®ãÂ∫èÈÉΩ‰ºöÁøªËΩ¨ÂÖ∂ÂÄº„ÄÇ</p>
<p>‰∏éÂàÜÂâ≤ÊèèËø∞Á¨¶‰∏ÄÊ†∑ÔºåÁ¨¨‰∏ÄÊ≠•ÊòØÂÜôÂÖ•‰∏çÂêåÁöÑÂ≠óÊÆµÔºöÂú∞ÂùÄ„ÄÅÈïøÂ∫¶„ÄÅIDÂíåÊ†áÂøó„ÄÇÁÑ∂ËÄåÔºåÊâìÂåÖÊèèËø∞Á¨¶ËÄÉËôëÂà∞‰∫Ü‰∏§‰∏™Êñ∞ÁöÑÊ†áÂøó„ÄÇAVAIL(0x7)ÂíåUSED(0x15)„ÄÇ‰∏∫‰∫ÜÂ∞Ü‰∏Ä‰∏™ÊèèËø∞Á¨¶Ê†áËÆ∞‰∏∫ÂèØÁî®ÔºåÈ©±Âä®Á®ãÂ∫è‰ΩøAVAIL(0x7)Ê†áÂøó‰∏éÂÆÉÁöÑÂÜÖÈÉ®ÂåÖË£ÖËÆ°Êï∞Âô®Áõ∏ÂêåÔºåËÄå‰ΩøÁî®ÁöÑÊ†áÂøóÂàôÊòØÁõ∏ÂèçÁöÑ„ÄÇËôΩÁÑ∂Âè™Êúâ‰∏Ä‰∏™‰∫åËøõÂà∂Ê†áÂøóAVA/USED‰ºöÊõ¥ÂÆπÊòìÂÆûÁé∞Ôºå‰ΩÜÂÆÉ‰ºöÂ¶®Á¢çÊàë‰ª¨ÂêéÈù¢Ë¶ÅÊèèËø∞ÁöÑÊúâÁî®ÁöÑ‰ºòÂåñ„ÄÇ</p>
<blockquote>
<p>As an example, if the driver allocates a write buffer with <code>0x1000</code> bytes on position <code>0x80000000</code> in the step 1 in the diagram, and makes it the first available descriptor setting <code>AVAIL(0x7)</code> flag the same as internal wrap counter (set) in step 2. The descriptor table would look like this:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>‚Üê</td>
</tr>
<tr>
<td>‚Üí</td>
<td>‚Ä¶</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Descriptor table after add the first buffer</strong></p>
</blockquote>
<p>‰∏æ‰∏™‰æãÂ≠êÔºåÂ¶ÇÊûúÈ©±Âä®Á®ãÂ∫èÂú®Âõæ‰∏≠ÁöÑÁ¨¨1Ê≠•‰∏≠Âú®<code>0x80000000</code>‰ΩçÁΩÆÂàÜÈÖç‰∫Ü‰∏Ä‰∏™<code>0x1000</code>Â≠óËäÇÁöÑÂÜôÁºìÂÜ≤Âå∫ÔºåÂπ∂‰ΩøÂÖ∂Êàê‰∏∫Á¨¨‰∏Ä‰∏™ÂèØÁî®ÁöÑÊèèËø∞Á¨¶ÔºåÂú®Á¨¨2Ê≠•‰∏≠ËÆæÁΩÆ<code>AVAIL(0x7)</code>Ê†áÂøó‰∏éÂÜÖÈÉ®ÂåÖÁªúËÆ°Êï∞Áõ∏ÂêåÔºàËÆæÁΩÆÔºâ„ÄÇÊèèËø∞Á¨¶Ë°®Â∞ÜÁúãËµ∑Êù•ÂÉèËøôÊ†∑„ÄÇ</p>
<blockquote>
<p>Note that the avail and used idx columns are in the table just for guidance, they don‚Äôt exist in the descriptor table: Each side should have its internal counter to know which position needs to poll or write next, and also the device must track the driver‚Äôs wrap counter. Lastly, as with used virtqueue, the driver notifies the device if the latter has notifications enabled (step 3 in the diagram).</p>
</blockquote>
<p>Ê≥®ÊÑèÔºåË°®‰∏≠ÁöÑavailÂíåused idxÂàóÂè™ÊòØ‰∏∫‰∫ÜÊåáÂØºÔºåÂÆÉ‰ª¨Âú®ÊèèËø∞Á¨¶Ë°®‰∏≠Âπ∂‰∏çÂ≠òÂú®„ÄÇÊØè‰∏ÄÊñπÈÉΩÂ∫îËØ•ÊúâËá™Â∑±ÁöÑÂÜÖÈÉ®ËÆ°Êï∞Âô®Ôºå‰ª•Áü•ÈÅì‰∏ã‰∏ÄÊ≠•ÈúÄË¶ÅËΩÆËØ¢ÊàñÂÜôÂÖ•Âì™‰∏™‰ΩçÁΩÆÔºåÂêåÊó∂ËÆæÂ§á‰πüÂøÖÈ°ªË∑üË∏™È©±Âä®ÁöÑwrapËÆ°Êï∞Âô®„ÄÇÊúÄÂêéÔºåÂíå‰ΩøÁî®ÁöÑvirtqueue‰∏ÄÊ†∑ÔºåÂ¶ÇÊûúËÆæÂ§áÂêØÁî®‰∫ÜÈÄöÁü•ÂäüËÉΩÔºåÈ©±Âä®Á®ãÂ∫èÂ∞±‰ºöÈÄöÁü•ËÆæÂ§áÔºàÂõæ‰∏≠Á¨¨3Ê≠•Ôºâ„ÄÇ</p>
<blockquote>
<p>And the usual diagram of the updates. Note the lack of the avail and used ring, as only the descriptor table is needed now.</p>
</blockquote>
<p>ËøòÊúâÈÄöÂ∏∏ÁöÑÊõ¥Êñ∞Âõæ„ÄÇËØ∑Ê≥®ÊÑèÔºåÁî±‰∫éÁé∞Âú®Âè™ÈúÄË¶ÅÊèèËø∞Á¨¶Ë°®ÔºåÊâÄ‰ª•Áº∫Â∞ëÂèØÁî®ÂíåÂ∑≤Áî®ÁéØ„ÄÇ</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-1.png" class="">

<p><strong>Diagram: Driver makes available a descriptor using a packed queue</strong></p>
<h3 id="Returning-used-descriptors-How-the-device-fills-the-‚Äúdone‚Äù-list"><a href="#Returning-used-descriptors-How-the-device-fills-the-‚Äúdone‚Äù-list" class="headerlink" title="Returning used descriptors: How the device fills the ‚Äúdone‚Äù list"></a>Returning used descriptors: How the device fills the ‚Äúdone‚Äù list</h3><blockquote>
<p>As the driver, the device maintains an internal single-bit ring wrap counter initialized to 1, and knows that the driver also has its internal ring wrap counter set. When the latter first searches for the first descriptor the driver has made available, it polls the first entry of the ring, looking for the avail flag equal to the driver internal wrap flag (set in this case).</p>
</blockquote>
<p>‰Ωú‰∏∫È©±Âä®Á®ãÂ∫èÔºåËÆæÂ§áÁª¥Êä§ÁùÄ‰∏Ä‰∏™ÂàùÂßãÂåñ‰∏∫1ÁöÑÂÜÖÈÉ®ÂçïÊØîÁâπÁéØÂΩ¢Áº†ÁªïËÆ°Êï∞Âô®ÔºåÂπ∂‰∏îÁü•ÈÅìÈ©±Âä®Á®ãÂ∫è‰πüËÆæÁΩÆ‰∫ÜÂÖ∂ÂÜÖÈÉ®ÁéØÂΩ¢Áº†ÁªïËÆ°Êï∞Âô®„ÄÇÂΩìÂêéËÄÖÁ¨¨‰∏ÄÊ¨°ÊêúÁ¥¢È©±Âä®Âô®Êèê‰æõÁöÑÁ¨¨‰∏Ä‰∏™ÊèèËø∞Á¨¶Êó∂ÔºåÂÆÉÂ∞±‰ºöËΩÆËØ¢ÁéØÁöÑÁ¨¨‰∏Ä‰∏™Êù°ÁõÆÔºåÂØªÊâæÁ≠â‰∫éÈ©±Âä®Âô®ÂÜÖÈÉ®ÂåÖÁªúÊ†áÂøóÁöÑÂèØÁî®Ê†áÂøóÔºàÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÊòØËÆæÁΩÆÁöÑÔºâ„ÄÇ</p>
<blockquote>
<p>As with a used ring, the length of the written data is returned in the ‚Äúlength‚Äù entry (if any), and the id of the used descriptor. At last, the device will make the avail (A) and used (U) flag the same as the device‚Äôs internal wrap counter.</p>
<p>Following the example, the device will let the descriptor table as figure 6. The device will know that the buffer has been returned because the used flag matches the available flag, and with the device internal wrap counter at the moment it wrote the descriptor. The returned address is not important: only the ID.</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td>‚Üí</td>
<td>‚Ä¶</td>
<td></td>
<td></td>
<td></td>
<td>‚Üê</td>
</tr>
</tbody></table>
<p><strong>Figure: Descriptor table after add the first buffer</strong></p>
</blockquote>
<p>‰∏éÂ∑≤Áî®ÁéØ‰∏ÄÊ†∑ÔºåÂÜôÂÖ•Êï∞ÊçÆÁöÑÈïøÂ∫¶‰ºöÂú® ‚Äúlength ‚ÄúÊù°ÁõÆ‰∏≠ËøîÂõûÔºàÂ¶ÇÊûúÊúâÁöÑËØùÔºâÔºå‰ª•ÂèäÂ∑≤Áî®ÊèèËø∞Á¨¶ÁöÑid„ÄÇÊúÄÂêéÔºåËÆæÂ§áÂ∞Ü‰ΩøÂèØÁî®(A)ÂíåÂ∑≤Áî®(U)Ê†áÂøó‰∏éËÆæÂ§áÁöÑÂÜÖÈÉ®Áº†ÁªïËÆ°Êï∞Âô®Áõ∏Âêå„ÄÇ</p>
<p>ÊåâÁÖßËøô‰∏™‰æãÂ≠êÔºåËÆæÂ§áÂ∞ÜËÆ©ÊèèËø∞Á¨¶Ë°®Â¶ÇÂõæ6ÊâÄÁ§∫„ÄÇËÆæÂ§áÂ∞ÜÁü•ÈÅìÁºìÂÜ≤Âå∫Â∑≤ÁªèË¢´ËøîÂõûÔºåÂõ†‰∏∫‰ΩøÁî®ÁöÑÊ†áÂøó‰∏éÂèØÁî®ÁöÑÊ†áÂøóÁõ∏ÂåπÈÖçÔºåÂπ∂‰∏îÂú®ÂÜôÊèèËø∞Á¨¶ÁöÑÊó∂ÂÄô‰∏éËÆæÂ§áÂÜÖÈÉ®ÁöÑwrapËÆ°Êï∞Âô®Áõ∏ÂåπÈÖç„ÄÇËøîÂõûÁöÑÂú∞ÂùÄÂπ∂‰∏çÈáçË¶ÅÔºöÂè™ÊúâID„ÄÇ</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-2.png" class="">

<p><strong>Diagram: Device marks a descriptor as used using a packed queue</strong></p>
<h3 id="Wrapping-the-descriptor-ring-How-the-lanes-keep-separated"><a href="#Wrapping-the-descriptor-ring-How-the-lanes-keep-separated" class="headerlink" title="Wrapping the descriptor ring: How the lanes keep separated?"></a>Wrapping the descriptor ring: How the lanes keep separated?</h3><blockquote>
<p>When the driver fills the complete descriptor table, it wraps and changes its internal Driver Ring Wrap. So, in the second round, the available descriptions will have the avail and used flags clear, so the device will have to poll looking for this condition once it wraps reading descriptors. Let‚Äôs see a full example of the different situations.</p>
</blockquote>
<p>ÂΩìÈ©±Âä®Á®ãÂ∫èÂ°´Êª°‰∫ÜÂÆåÊï¥ÁöÑÊèèËø∞Á¨¶Ë°®ÔºåÂÆÉÂ∞±‰ºöÂåÖË£πÂπ∂ÊîπÂèòÂÖ∂ÂÜÖÈÉ®ÁöÑÈ©±Âä®Á®ãÂ∫èÁéØÂΩ¢ÂåÖË£π„ÄÇÊâÄ‰ª•ÔºåÂú®Á¨¨‰∫åËΩÆ‰∏≠ÔºåÂèØÁî®ÁöÑÊèèËø∞Á¨¶Â∞ÜÊúâavailÂíåusedÊ†áÂøóË¢´Ê∏ÖÈô§ÔºåÊâÄ‰ª•ËÆæÂ§á‰∏ÄÊó¶ÂåÖË£πËØªÂèñÊèèËø∞Á¨¶ÔºåÂ∞±ÂøÖÈ°ªËΩÆËØ¢ÂØªÊâæËøô‰∏™Êù°‰ª∂„ÄÇËÆ©Êàë‰ª¨Êù•ÁúãÁúã‰∏çÂêåÊÉÖÂÜµÁöÑÂÆåÊï¥‰æãÂ≠ê„ÄÇ</p>
<blockquote>
<p>If we have a descriptor table with only two entries, the Driver Ring Wrap Counter is set, and it fills the descriptor table making available two buffers at the beginning of the operation, driver will reverse its internal wrap counter, so it will be clear (0). We have the next table:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>‚Üí</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>‚Üê</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Full two-entries descriptor table</strong></p>
</blockquote>
<p>Â¶ÇÊûúÊàë‰ª¨Êúâ‰∏Ä‰∏™Âè™Êúâ‰∏§‰∏™Êù°ÁõÆÁöÑÊèèËø∞Á¨¶Ë°®ÔºåÈ©±Âä®ÁéØÂΩ¢Áº†ÁªïËÆ°Êï∞Âô®Ë¢´ËÆæÁΩÆÔºåÂÆÉÂ°´Êª°ÊèèËø∞Á¨¶Ë°®ÔºåÂú®Êìç‰ΩúÂºÄÂßãÊó∂ËÖæÂá∫‰∏§‰∏™ÁºìÂÜ≤Âå∫ÔºåÈ©±Âä®Â∞ÜÊâ≠ËΩ¨ÂÖ∂ÂÜÖÈÉ®Áº†ÁªïËÆ°Êï∞Âô®ÔºåÊâÄ‰ª•ÂÆÉÂ∞ÜÊòØclearÔºà0Ôºâ„ÄÇÊàë‰ª¨Êúâ‰∏ã‰∏Ä‰∏™Ë°®„ÄÇ</p>
<blockquote>
<p>After that, the device realizes that has both descriptors with id #0 and #1 available: it knows that the driver had its wrap counter set when it wrote them, the avail flag is set on them, and the used one is clear on both. If device uses the descriptor with id #1, we have the Figure 8 descriptor table. The buffer #0 still belongs to the device!</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>‚Üí</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td>‚Üê</td>
</tr>
</tbody></table>
<p><strong>Figure: Using first buffer out of order</strong></p>
</blockquote>
<p>‰πãÂêéÔºåËÆæÂ§áÊÑèËØÜÂà∞Êúâ‰∏§‰∏™ID‰∏∫#0Âíå#1ÁöÑÊèèËø∞Á¨¶ÊòØÂèØÁî®ÁöÑÔºöÂÆÉÁü•ÈÅìÈ©±Âä®Á®ãÂ∫èÂú®ÂÜôÂÆÉ‰ª¨ÁöÑÊó∂ÂÄôËÆæÁΩÆ‰∫ÜwrapËÆ°Êï∞Âô®ÔºåÂÆÉ‰ª¨ÁöÑavailÊ†áÂøóË¢´ËÆæÁΩÆÔºåËÄå‰∏îËøô‰∏§‰∏™ÊèèËø∞Á¨¶ÁöÑusedÊ†áÂøóÈÉΩÊòØÊ∏ÖÈõ∂ÁöÑ„ÄÇÂ¶ÇÊûúËÆæÂ§á‰ΩøÁî®id‰∏∫#1ÁöÑÊèèËø∞Á¨¶ÔºåÊàë‰ª¨Â∞±Êúâ‰∫ÜÂõæ8ÁöÑÊèèËø∞Á¨¶Ë°®„ÄÇÁºìÂÜ≤Âå∫#0‰ªçÁÑ∂Â±û‰∫éËÆæÂ§á!</p>
<blockquote>
<p>Now the driver realize the buffer #1 has been used, since avail and used flags are the same (set) and match the device‚Äôs internal wrap counter at the moment it wrote it. If device now uses the buffer id #0, it will make the table look like this:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>‚Üí</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A|U</td>
<td>‚Üê</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Using second buffer out of order</strong></p>
</blockquote>
<p>Áé∞Âú®È©±Âä®Á®ãÂ∫èÊÑèËØÜÂà∞1Âè∑ÁºìÂÜ≤Âå∫Â∑≤ÁªèË¢´‰ΩøÁî®‰∫ÜÔºåÂõ†‰∏∫availÂíåusedÊ†áÂøóÊòØ‰∏ÄÊ†∑ÁöÑÔºàËÆæÁΩÆÔºâÔºåÂπ∂‰∏î‰∏éËÆæÂ§áÁöÑÂÜÖÈÉ®wrapËÆ°Êï∞Âô®Âú®ÂÜôÁöÑÊó∂ÂÄôÊòØ‰∏ÄËá¥ÁöÑ„ÄÇÂ¶ÇÊûúËÆæÂ§áÁé∞Âú®‰ΩøÁî®ÁºìÂÜ≤Âå∫ID #0ÔºåÂÆÉÂ∞Ü‰ΩøË°®ÁúãËµ∑Êù•ÂÉèËøôÊ†∑„ÄÇ</p>
<blockquote>
<p>But there is a more interesting case: Starting from the ‚Äúfirst buffer out of order‚Äù situation, the driver makes available the buffer #1 again. In that case, the descriptor table goes directly from the ‚Äúfirst buffer‚Äù to the next figure, ‚ÄúFull two-entries descriptor table.‚Äù</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td>‚Üê</td>
</tr>
<tr>
<td>‚Üí</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Full two-entries descriptor table</strong></p>
</blockquote>
<p>‰ΩÜËøòÊúâ‰∏ÄÁßçÊõ¥ÊúâË∂£ÁöÑÊÉÖÂÜµ„ÄÇ‰ªé ‚ÄúÁ¨¨‰∏Ä‰∏™ÁºìÂÜ≤Âå∫Â§±ÁÅµ ‚ÄúÁöÑÊÉÖÂÜµÂºÄÂßãÔºåÈ©±Âä®Á®ãÂ∫èÂÜçÊ¨°Êèê‰æõ‰∫Ü1Âè∑ÁºìÂÜ≤Âå∫„ÄÇÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÊèèËø∞Á¨¶Ë°®Áõ¥Êé•‰ªé ‚ÄúÁ¨¨‰∏Ä‰∏™ÁºìÂÜ≤Âå∫ ‚ÄúËøõÂÖ•‰∏ã‰∏Ä‰∏™ÂõæÔºå‚ÄùÂÆåÊï¥ÁöÑ‰∏§Ë°åÊèèËø∞Á¨¶Ë°®‚Äù„ÄÇ</p>
<h3 id="Chained-descriptors-No-more-jumps"><a href="#Chained-descriptors-No-more-jumps" class="headerlink" title="Chained descriptors: No more jumps"></a>Chained descriptors: No more jumps</h3><blockquote>
<p>Chained descriptors work likewise: no need for the next field in the head (or subsequent) descriptor in the chain to search subsequent ones, since the latter always occupies the next position. However, while in the split used ring you only need to return as used the id of the head of the chain, in packed you only need to return the tail id.</p>
</blockquote>
<p>ÈìæÂºèÊèèËø∞Á¨¶ÁöÑÂ∑•‰ΩúÂéüÁêÜ‰πüÊòØÂ¶ÇÊ≠§Ôºö‰∏çÈúÄË¶ÅÂú®Èìæ‰∏≠ÁöÑÂ§¥ÈÉ®ÔºàÊàñÂêéÁª≠ÔºâÊèèËø∞Á¨¶ÁöÑ‰∏ã‰∏Ä‰∏™Â≠óÊÆµÊù•ÊêúÁ¥¢ÂêéÁª≠ÁöÑÊèèËø∞Á¨¶ÔºåÂõ†‰∏∫ÂêéËÄÖÊÄªÊòØÂç†ÊçÆÁùÄ‰∏ã‰∏Ä‰∏™‰ΩçÁΩÆ„ÄÇÁÑ∂ËÄåÔºåÂú®ÂàÜÂâ≤‰ΩøÁî®ÁöÑÁéØ‰∏≠Ôºå‰Ω†Âè™ÈúÄË¶ÅËøîÂõûÈìæÂ§¥ÁöÑid‰Ωú‰∏∫‰ΩøÁî®ÔºåËÄåÂú®ÊâìÂåÖ‰∏≠‰Ω†Âè™ÈúÄË¶ÅËøîÂõûÂ∞æÈÉ®ÁöÑid„ÄÇ</p>
<blockquote>
<p>Back to the used ring, every time we use chained descriptors, we make the used idx lag regarding the avail idx. More than one descriptor mark as available to the device, but we only send one as used to the driver. While this is not a problem in the split ring, this would cause descriptor entry exhaustion in the packed version.</p>
</blockquote>
<p>ÂõûÂà∞Â∑≤Áî®ÁéØÔºåÊØèÊ¨°Êàë‰ª¨‰ΩøÁî®ÈìæÂºèÊèèËø∞Á¨¶Êó∂ÔºåÈÉΩ‰ºö‰ΩøÂ∑≤Áî®idxÊªûÂêé‰∫éÂèØÁî®idx„ÄÇ‰∏Ä‰∏™‰ª•‰∏äÁöÑÊèèËø∞Á¨¶Ë¢´Ê†áËÆ∞‰∏∫ËÆæÂ§áÂèØÁî®Ôºå‰ΩÜÊàë‰ª¨Âè™Êää‰∏Ä‰∏™ÊèèËø∞Á¨¶‰Ωú‰∏∫Â∑≤‰ΩøÁî®ÁöÑÊèèËø∞Á¨¶ÂèëÈÄÅÁªôÈ©±Âä®„ÄÇËôΩÁÑ∂ËøôÂú®ÂàÜÂâ≤ÁéØ‰∏≠‰∏çÊòØ‰∏Ä‰∏™ÈóÆÈ¢òÔºå‰ΩÜÂú®ÊâìÂåÖÁâàÊú¨‰∏≠‰ºöÂØºËá¥ÊèèËø∞Á¨¶Êù°ÁõÆËÄóÂ∞Ω„ÄÇ</p>
<blockquote>
<p>The straightforward solution is to make the device mark as used every descriptor in the chain. However, this can be expensive, since we are modifying a shared area of memory, and could cause cache bounces.</p>
<p>However, the driver already knows the chain, so it can skip all the chain with only the last id. This is why we need to compare the used/avail pair with the driver/device Wrap Counter: after a jump, we wouldn‚Äôt know if the next descriptor has been made available in this driver‚Äôs round or in the next if we only have a binary available/used flag.</p>
</blockquote>
<p>Áõ¥Êé•ÁöÑËß£ÂÜ≥ÊñπÊ°àÊòØËÆ©ËÆæÂ§áÂ∞ÜÈìæ‰∏äÁöÑÊØè‰∏™ÊèèËø∞Á¨¶ÈÉΩÊ†áËÆ∞‰∏∫Â∑≤‰ΩøÁî®„ÄÇÁÑ∂ËÄåÔºåËøôÂèØËÉΩÊòØÊòÇË¥µÁöÑÔºåÂõ†‰∏∫Êàë‰ª¨Ê≠£Âú®‰øÆÊîπÂÜÖÂ≠òÁöÑÂÖ±‰∫´Âå∫ÂüüÔºåÂπ∂ÂèØËÉΩÂØºËá¥ÁºìÂ≠òË∑≥Âá∫„ÄÇ</p>
<p>ÁÑ∂ËÄåÔºåÈ©±Âä®Á®ãÂ∫èÂ∑≤ÁªèÁü•ÈÅì‰∫ÜÈìæÔºåÊâÄ‰ª•ÂÆÉÂèØ‰ª•Ë∑≥ËøáÊâÄÊúâÁöÑÈìæÔºåÂè™‰øùÁïôÊúÄÂêé‰∏Ä‰∏™ID„ÄÇËøôÂ∞±ÊòØ‰∏∫‰ªÄ‰πàÊàë‰ª¨ÈúÄË¶ÅÂ∞ÜÂ∑≤Áî®/ÂèØÁî®ÂØπ‰∏éÈ©±Âä®/ËÆæÂ§áÁöÑWrap CounterËøõË°åÊØîËæÉÔºöÂú®Ë∑≥ËΩ¨‰πãÂêéÔºåÂ¶ÇÊûúÊàë‰ª¨Âè™Êúâ‰∏Ä‰∏™‰∫åËøõÂà∂ÁöÑÂèØÁî®/Â∑≤Áî®Ê†áÂøóÔºåÊàë‰ª¨Â∞±‰∏çÁü•ÈÅì‰∏ã‰∏Ä‰∏™ÊèèËø∞Á¨¶ÊòØÂú®Ëøô‰∏™È©±Âä®ÁöÑÂõûÂêà‰∏≠ËøòÊòØÂú®‰∏ã‰∏Ä‰∏™ÂõûÂêà‰∏≠Ë¢´Êèê‰æõÁöÑ„ÄÇ</p>
<blockquote>
<p>For example, in a four entries ring, the driver makes available the chain of three descriptors:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>‚Üê</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td>‚Üí</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Three chained descriptors available</strong></p>
</blockquote>
<p>‰æãÂ¶ÇÔºåÂú®‰∏Ä‰∏™ÂõõÈ°πÁéØ‰∏≠ÔºåÈ©±Âä®Âô®Êèê‰æõ‰∫Ü‰∏â‰∏™ÊèèËø∞Á¨¶ÁöÑÈìæ„ÄÇ</p>
<blockquote>
<p>After that, the device discovers the chain (polling position 0) and marks it as used, overwriting only the position 0. It skips completely the positions 1 and 2. When the driver polls for used, it will skip them too, knowing that the chain was 3 descriptors long:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td>‚Üí</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>‚Üê</td>
</tr>
</tbody></table>
<p><strong>Figure: Using the descriptor chain</strong></p>
</blockquote>
<p>‰πãÂêéÔºåËÆæÂ§á‰ºöÂèëÁé∞Ëøô‰∏™ÈìæÔºàËΩÆËØ¢‰ΩçÁΩÆ0ÔºâÔºåÂπ∂Â∞ÜÂÖ∂Ê†áËÆ∞‰∏∫Â∑≤Áî®ÔºåÂè™Ë¶ÜÁõñ‰ΩçÁΩÆ0ÔºåÂÆåÂÖ®Ë∑≥Ëøá‰ΩçÁΩÆ1Âíå2„ÄÇÂΩìÈ©±Âä®ËΩÆËØ¢Â∑≤‰ΩøÁî®Êó∂ÔºåÂÆÉ‰πü‰ºöË∑≥ËøáËøô‰∫õ‰ΩçÁΩÆÔºåÂõ†‰∏∫ÂÆÉÁü•ÈÅìËØ•ÈìæÊúâ3‰∏™ÊèèËø∞Á¨¶Èïø„ÄÇ</p>
<blockquote>
<p>Now the driver produces another two descriptor long chain, and it has to take into account the wrapping:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td></td>
</tr>
<tr>
<td>‚Üí</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>‚Üê</td>
</tr>
</tbody></table>
<p><strong>Figure: Make available another descriptor chain</strong></p>
</blockquote>
<p>Áé∞Âú®ÔºåÈ©±Âä®Á®ãÂ∫èÂèà‰∫ßÁîü‰∫Ü‰∏Ä‰∏™‰∏§Ê†πÊèèËø∞Á¨¶ÁöÑÈïøÈìæÔºåÂÆÉÂøÖÈ°ªËÄÉËôëÂà∞ÂåÖË£ÖÁöÑÈóÆÈ¢ò„ÄÇ</p>
<blockquote>
<p>And the device marks it as used, so only the first descriptor in the chain (4th in the table) needs to be updated.</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td></td>
</tr>
<tr>
<td>‚Üí</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td>‚Üê</td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Using another descriptor chain</strong></p>
<p>Although the next descriptor (2nd) seems like available, since the avail flag is different from the used one, the device knows that it is not because of knowing the internal Driver Wrap Counter: The right flag combination is avail clear, used set.</p>
</blockquote>
<p>ËÄåËÆæÂ§áÂ∞ÜÂÖ∂Ê†áËÆ∞‰∏∫Â∑≤‰ΩøÁî®ÔºåÊâÄ‰ª•Âè™ÊúâÈìæ‰∏≠ÁöÑÁ¨¨‰∏Ä‰∏™ÊèèËø∞Á¨¶ÔºàË°®‰∏≠ÁöÑÁ¨¨Âõõ‰∏™ÔºâÈúÄË¶ÅÊõ¥Êñ∞„ÄÇ</p>
<p>Â∞ΩÁÆ°‰∏ã‰∏Ä‰∏™ÊèèËø∞Á¨¶ÔºàÁ¨¨2‰∏™ÔºâÁúãËµ∑Êù•ÊòØÂèØÁî®ÁöÑÔºå‰ΩÜÁî±‰∫éavailÊ†áÂøó‰∏éusedÊ†áÂøó‰∏çÂêåÔºåËÆæÂ§áÁü•ÈÅìÂÆÉ‰∏çÊòØÔºåÂõ†‰∏∫Áü•ÈÅìÂÜÖÈÉ®ÁöÑDriver Wrap Counter„ÄÇÊ≠£Á°ÆÁöÑÊ†áÂøóÁªÑÂêàÊòØavail clearÔºåused set„ÄÇ</p>
<h3 id="Indirect-descriptors-When-chains-are-not-enough"><a href="#Indirect-descriptors-When-chains-are-not-enough" class="headerlink" title="Indirect descriptors: When chains are not enough"></a>Indirect descriptors: When chains are not enough</h3><blockquote>
<p>Indirect descriptors work like in the split case. First, the driver allocates a table of indirect descriptors each with the same layout as the regular packed descriptors anywhere in memory. After that, it sets each descriptor in this indirect table to the buffer it wants to make available for the driver (steps 1-2), and inserts a descriptor in the virtqueue with the flag <code>VIRTQ_DESC_F_INDIRECT (0x4)</code> set (step 3). The descriptor‚Äôs address and length correspond to the indirect table‚Äôs ones.</p>
</blockquote>
<p>Èó¥Êé•ÊèèËø∞Á¨¶ÁöÑÂ∑•‰ΩúÊñπÂºè‰∏éÂàÜÂâ≤ÊÉÖÂÜµÁ±ª‰ºº„ÄÇÈ¶ñÂÖàÔºåÈ©±Âä®Á®ãÂ∫èÂàÜÈÖç‰∏Ä‰∏™Èó¥Êé•ÊèèËø∞Á¨¶Ë°®ÔºåÊØè‰∏™ÊèèËø∞Á¨¶ÁöÑÂ∏ÉÂ±Ä‰∏éÂÜÖÂ≠ò‰∏≠‰ªª‰ΩïÂú∞ÊñπÁöÑÂ∏∏ËßÑÊâìÂåÖÊèèËø∞Á¨¶Áõ∏Âêå„ÄÇ‰πãÂêéÔºåÂÆÉÂ∞ÜËøô‰∏™Èó¥Êé•Ë°®‰∏≠ÁöÑÊØè‰∏™ÊèèËø∞Á¨¶ËÆæÁΩÆ‰∏∫ÂÆÉÊÉ≥‰∏∫È©±Âä®Êèê‰æõÁöÑÁºìÂÜ≤Âå∫ÔºàÊ≠•È™§1-2ÔºâÔºåÂπ∂Âú®virtqueue‰∏≠ÊèíÂÖ•‰∏Ä‰∏™ËÆæÁΩÆ‰∫ÜÊ†áÂøóVIRTQ_DESC_F_INDIRECTÔºà0x4ÔºâÁöÑÊèèËø∞Á¨¶ÔºàÊ≠•È™§3Ôºâ„ÄÇËØ•ÊèèËø∞Á¨¶ÁöÑÂú∞ÂùÄÂíåÈïøÂ∫¶ÂØπÂ∫î‰∫éÈó¥Êé•Ë°®ÁöÑÈÇ£‰∫õ„ÄÇ</p>
<blockquote>
<p>In packed layout buffers must come in order in the indirect table, and the ID field is completely ignored. Also, the only valid flag for them is <code>VIRTQ_DESC_F_WRITE</code>, others are reserved and ignored by the device. As usual, the driver will notify the device if the conditions for the notification are met (step 4).</p>
</blockquote>
<p>Âú®ÊâìÂåÖÂ∏ÉÂ±Ä‰∏≠ÔºåÁºìÂÜ≤Âå∫ÂøÖÈ°ªÊåâÈ°∫Â∫èÂá∫Áé∞Âú®Èó¥Êé•Ë°®‰∏≠ÔºåIDÂ≠óÊÆµÂÆåÂÖ®Ë¢´ÂøΩÁï•„ÄÇÂè¶Â§ñÔºåÂÆÉ‰ª¨ÂîØ‰∏ÄÊúâÊïàÁöÑÊ†áÂøóÊòØVIRTQ_DESC_F_WRITEÔºåÂÖ∂‰ªñÁöÑÊòØ‰øùÁïôÁöÑÔºåË¢´ËÆæÂ§áÂøΩÁï•„ÄÇÂÉèÂæÄÂ∏∏‰∏ÄÊ†∑ÔºåÂ¶ÇÊûúÈÄöÁü•ÁöÑÊù°‰ª∂ÂæóÂà∞Êª°Ë∂≥ÔºåÈ©±Âä®Á®ãÂ∫èÂ∞ÜÈÄöÁü•ËÆæÂ§áÔºàÊ≠•È™§4Ôºâ„ÄÇ</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-3.png" class="">

<p><strong>Diagram: Driver makes available a descriptor using a packed queue</strong></p>
<p>For example, the driver would need to allocate this 48 bytes table for a 3 descriptors indirect table:</p>
<table>
<thead>
<tr>
<th></th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>‚Ä¶</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>‚Ä¶</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>‚Ä¶</td>
<td>W</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Three descriptor long indirect packed table</strong></p>
<p>And if it introduces the indirect table the first in the descriptor table, assuming it is allocated in <code>0x83000000</code> address:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>48</td>
<td>0</td>
<td>A|I</td>
<td>‚Üê</td>
</tr>
<tr>
<td>‚Üí</td>
<td>‚Ä¶</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Drivers makes an indirect table available</strong></p>
<p>After indirect buffer consumption, the device needs to return the indirect buffer id (0 in the example) in its used descriptor. The table looks like the return of the first buffer, except for the indirect (I) flag set:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>48</td>
<td>0</td>
<td>A|U|I</td>
<td></td>
</tr>
<tr>
<td>‚Üí</td>
<td>‚Ä¶</td>
<td></td>
<td></td>
<td></td>
<td>‚Üê</td>
</tr>
</tbody></table>
<p><strong>Figure: Device makes an indirect table used</strong></p>
<p>After that, the device cannot access the memory table anymore unless the driver makes it available again, so the latter can free or reuse it.</p>
<h3 id="Notifications-how-to-manage-interruptions"><a href="#Notifications-how-to-manage-interruptions" class="headerlink" title="Notifications: how to manage interruptions?"></a>Notifications: how to manage interruptions?</h3><blockquote>
<p>Like in the used queue, each side of the communication maintains two identical structures used for controlling notifications between the device and the driver. The driver‚Äôs one is read-only by the device, and the device‚Äôs one is read-only by the driver.</p>
<p>The struct layout is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct pvirtq_event_suppress &#123; </span><br><span class="line">        le16 desc;</span><br><span class="line">        le16 flags; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Event suppression struct notification</strong></p>
</blockquote>
<p>Â∞±ÂÉèÂú®Áî®ËøáÁöÑÈòüÂàó‰∏≠ÔºåÈÄö‰ø°ÁöÑÊØè‰∏ÄÊñπÈÉΩÁª¥Êä§ÁùÄ‰∏§‰∏™Áõ∏ÂêåÁöÑÁªìÊûÑÔºåÁî®‰∫éÊéßÂà∂ËÆæÂ§áÂíåÈ©±Âä®‰πãÈó¥ÁöÑÈÄöÁü•„ÄÇÈ©±Âä®Á®ãÂ∫èÁöÑÈÇ£‰∏™ÁªìÊûÑÊòØËÆæÂ§áÂè™ËØªÁöÑÔºåËÄåËÆæÂ§áÁöÑÈÇ£‰∏™ÁªìÊûÑÊòØÈ©±Âä®Á®ãÂ∫èÂè™ËØªÁöÑ„ÄÇ</p>
<blockquote>
<p>The member flags can take the values:</p>
<ul>
<li>0: Notifications are enabled</li>
<li>1: Notifications are disabled</li>
<li>2: Notifications are enabled for a specific descriptor, specified from the desc member.</li>
</ul>
<p>If flags value is 2, the other side will notify until the wrap counter matches the most significant bit of desc and the descriptor placed in the position desc discarding that bit is made used/available. For this mode to work, <code>VIRTIO_F_RING_EVENT_IDX</code> flag needs to be negotiated in Virtio device initialization: feature bits.</p>
<p>None of these mechanisms are 100% reliable, since the other side could have sent the notification already when we set the values, so expect it even when disable.</p>
<p>Note that, since the descriptor ring size is not being forced to be a power of two (comparing with the split version), the notification structure can fit in the same page as the descriptor table. This can be advantageous for some implementations.</p>
</blockquote>
<p>ÊàêÂëòÊ†áÂøóÂèØ‰ª•ÈááÂèñ‰ª•‰∏ãÂÄº„ÄÇ</p>
<ul>
<li>0: ÈÄöÁü•Ë¢´ÂêØÁî®</li>
<li>1: ÈÄöÁü•Ë¢´Á¶ÅÁî®</li>
<li>2: ÂØπ‰∏Ä‰∏™ÁâπÂÆöÁöÑÊèèËø∞Á¨¶ÂêØÁî®ÈÄöÁü•ÔºåÁî±descÊàêÂëòÊåáÂÆö„ÄÇ</li>
</ul>
<p>Â¶ÇÊûúÊ†áÂøóÂÄº‰∏∫2ÔºåÂè¶‰∏ÄÊñπÂ∞ÜËøõË°åÈÄöÁü•ÔºåÁõ¥Âà∞wrapËÆ°Êï∞Âô®‰∏édescÁöÑÊúÄÈáçË¶ÅÁöÑ‰ΩçÁõ∏ÂåπÈÖçÔºåÂπ∂‰∏îÊîæÁΩÆÂú®desc‰ΩçÁΩÆÁöÑÊèèËø∞Á¨¶ÊîæÂºÉËØ•‰ΩçËÄåË¢´‰ΩøÁî®/ÂèØÁî®„ÄÇ‰∏∫‰∫Ü‰ΩøËøôÁßçÊ®°ÂºèÂ∑•‰ΩúÔºåVIRTIO_F_RING_EVENT_IDXÊ†áÂøóÈúÄË¶ÅÂú®VirtioËÆæÂ§áÂàùÂßãÂåñ‰∏≠ÂçèÂïÜÔºöÁâπÂæÅ‰Ωç„ÄÇ</p>
<p>Ëøô‰∫õÊú∫Âà∂ÈÉΩ‰∏çÊòØ100%ÂèØÈù†ÁöÑÔºåÂõ†‰∏∫ÂΩìÊàë‰ª¨ËÆæÁΩÆËøô‰∫õÂÄºÊó∂ÔºåÂØπÊñπÂèØËÉΩÂ∑≤ÁªèÂèëÈÄÅ‰∫ÜÈÄöÁü•ÔºåÊâÄ‰ª•Âç≥‰ΩøÂú®Á¶ÅÁî®ÁöÑÊÉÖÂÜµ‰∏ã‰πüË¶ÅÊúüÂæÖÂÆÉ„ÄÇ</p>
<p>ËØ∑Ê≥®ÊÑèÔºåÁî±‰∫éÊèèËø∞Á¨¶ÁéØÁöÑÂ§ßÂ∞èÊ≤°ÊúâË¢´Âº∫Âà∂‰∏∫2ÁöÑÂπÇÔºà‰∏éÂàÜË£ÇÁâàÊú¨Áõ∏ÊØîÔºâÔºåÈÄöÁü•ÁªìÊûÑÂèØ‰ª•‰∏éÊèèËø∞Á¨¶Ë°®ÊîæÂú®Âêå‰∏ÄÈ°µÈù¢‰∏≠„ÄÇËøôÂØπÊüê‰∫õÂÆûÁé∞Êù•ËØ¥ÊòØÊúâÂà©ÁöÑ„ÄÇ</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><blockquote>
<p>In this series we have taken you through the different virtio data plane layouts and its virtqueues implementations. They are the means for virtio devices and virtio drivers to exchange information.</p>
<p>We start by covering the simpler and less optimized split virtqueue layout. This layout is relatively easy to implement and to debug thus it‚Äôs a good entry point for learning the virtio dataplane basics.</p>
<p>We then moved on to the packed virtqueue layout specified in virtio 1.1 which allows requests exchange using a more compact descriptor representation. This avoids all the overhead of scattering the data through memory, avoiding cache contention and reducing the PCI transactions in case of actual hardware.</p>
</blockquote>
<p>Âú®Ëøô‰∏™Á≥ªÂàó‰∏≠ÔºåÊàë‰ª¨Â∑≤ÁªèÂ∏¶‰Ω†‰∫ÜËß£‰∫Ü‰∏çÂêåÁöÑvirtioÊï∞ÊçÆÂπ≥Èù¢Â∏ÉÂ±ÄÂèäÂÖ∂virtqueuesÁöÑÂÆûÁé∞„ÄÇÂÆÉ‰ª¨ÊòØvirtioËÆæÂ§áÂíåvirtioÈ©±Âä®‰∫§Êç¢‰ø°ÊÅØÁöÑÊâãÊÆµ„ÄÇ</p>
<p>Êàë‰ª¨È¶ñÂÖà‰ªãÁªç‰∫ÜÊõ¥ÁÆÄÂçï„ÄÅÊõ¥‰∏ç‰ºòÂåñÁöÑÂàÜÁ¶ªÂºèvirtqueueÂ∏ÉÂ±Ä„ÄÇËøôÁßçÂ∏ÉÂ±ÄÁõ∏ÂØπÂÆπÊòìÂÆûÁé∞ÂíåË∞ÉËØïÔºåÂõ†Ê≠§ÂÆÉÊòØÂ≠¶‰π†virtioÊï∞ÊçÆÂπ≥Èù¢Âü∫Á°ÄÁü•ËØÜÁöÑ‰∏Ä‰∏™ÂæàÂ•ΩÁöÑÂàáÂÖ•ÁÇπ„ÄÇ</p>
<p>ÁÑ∂ÂêéÔºåÊàë‰ª¨ËΩ¨Âêëvirtio 1.1‰∏≠ËßÑÂÆöÁöÑÊâìÂåÖÂºèvirtqueueÂ∏ÉÂ±ÄÔºåÂÆÉÂÖÅËÆ∏‰ΩøÁî®Êõ¥Á¥ßÂáëÁöÑÊèèËø∞Á¨¶Êù•‰∫§Êç¢ËØ∑Ê±Ç„ÄÇËøôÈÅøÂÖç‰∫ÜÂú®ÂÜÖÂ≠ò‰∏≠ÂàÜÊï£Êï∞ÊçÆÁöÑÊâÄÊúâÂºÄÈîÄÔºåÈÅøÂÖç‰∫ÜÁºìÂ≠ò‰∫âÁî®ÔºåÂπ∂Âú®ÂÆûÈôÖÁ°¨‰ª∂ÁöÑÊÉÖÂÜµ‰∏ãÂáèÂ∞ë‰∫ÜPCI‰∫ãÂä°„ÄÇ</p>
<blockquote>
<p>We also covered a number of optimizations on top of both ring layouts which depends on the communication/device type or how each part is implemented. Mainly, they are oriented to reduce the communication overhead, both in notifications and in memory transactions. Virtio offers a simple protocol to communicate what features and optimizations support each side, so they can agree on how the data is going to be exchanged and is highly future-proof.</p>
</blockquote>
<p>Êàë‰ª¨ËøòÂú®Ëøô‰∏§‰∏™ÁéØÁä∂Â∏ÉÂ±ÄÁöÑÂü∫Á°Ä‰∏äËøõË°å‰∫Ü‰∏Ä‰∫õ‰ºòÂåñÔºåËøôÂèñÂÜ≥‰∫éÈÄö‰ø°/ËÆæÂ§áÁ±ªÂûãÊàñÊØè‰∏™ÈÉ®ÂàÜÁöÑÂÆûÁé∞ÊñπÂºè„ÄÇ‰∏ªË¶ÅÁöÑÊòØÔºåÂÆÉ‰ª¨ÁöÑÊñπÂêëÊòØÂáèÂ∞ëÈÄö‰ø°ÂºÄÈîÄÔºåÂåÖÊã¨ÈÄöÁü•ÂíåÂÜÖÂ≠ò‰∫ãÂä°„ÄÇVirtioÊèê‰æõ‰∫Ü‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂçèËÆÆÊù•Ê≤üÈÄöÊØè‰∏ÄÊñπÊîØÊåÅÂì™‰∫õÂäüËÉΩÂíå‰ºòÂåñÔºåÊâÄ‰ª•‰ªñ‰ª¨ÂèØ‰ª•Â∞±Êï∞ÊçÆÁöÑ‰∫§Êç¢ÊñπÂºèËææÊàê‰∏ÄËá¥ÔºåÂπ∂‰∏îÊòØÈ´òÂ∫¶Èù¢ÂêëÊú™Êù•ÁöÑ„ÄÇ</p>
<blockquote>
<p>This series covered the essence of the virtio data plane and provided you with the tool to analyze and develop your own virtio device and drivers. It should be noted that this series summarizes the relevant sections from the virtio spec thus you should refer to the spec for additional information and see it as the source of truth.</p>
<p>In the next posts we will return to vDPA including the kernel framework, hands on blogs and vDPA in Kubernetes.</p>
</blockquote>
<p>Ëøô‰∏™Á≥ªÂàóÊ∂µÁõñ‰∫ÜvirtioÊï∞ÊçÆÂπ≥Èù¢ÁöÑÊú¨Ë¥®ÔºåÂπ∂‰∏∫‰Ω†Êèê‰æõ‰∫ÜÂàÜÊûêÂíåÂºÄÂèëËá™Â∑±ÁöÑvirtioËÆæÂ§áÂíåÈ©±Âä®ÁöÑÂ∑•ÂÖ∑„ÄÇÂ∫îËØ•Ê≥®ÊÑèÁöÑÊòØÔºåËøô‰∏™Á≥ªÂàóÊÄªÁªì‰∫ÜvirtioËßÑËåÉ‰∏≠ÁöÑÁõ∏ÂÖ≥ÈÉ®ÂàÜÔºåÂõ†Ê≠§‰Ω†Â∫îËØ•ÂèÇËÄÉËßÑËåÉ‰ª•Ëé∑ÂæóÊõ¥Â§ö‰ø°ÊÅØÔºåÂπ∂Â∞ÜÂÖ∂ËßÜ‰∏∫ÁúüÁêÜÁöÑÊù•Ê∫ê„ÄÇ</p>
<p>Âú®Êé•‰∏ãÊù•ÁöÑÊñáÁ´†‰∏≠ÔºåÊàë‰ª¨Â∞ÜÂõûÂà∞vDPAÔºåÂåÖÊã¨ÂÜÖÊ†∏Ê°ÜÊû∂„ÄÅÂÆûË∑µÂçöÂÆ¢ÂíåKubernetes‰∏≠ÁöÑvDPA„ÄÇ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" data-id="cleh8xpaf0000urwb2g162srp" data-title="Packed virtqueue: How to reduce overhead with virtio" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-virtqueues-and-virtio-ring-how-the-data-travels" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/" class="article-date">
  <time class="dt-published" datetime="2023-02-22T15:48:33.000Z" itemprop="datePublished">2023-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/">Virtqueues and virtio ring: How the data travels</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>This post continues where the ‚Äú<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">Virtio devices and drivers overview</a>‚Äú leaves off. After we have explained the scenario in the previous post, we are reaching the main point: how does the data travel from the virtio-device to the driver and back?</p>
</blockquote>
<p>ËøôÁØáÊñáÁ´†ÁªßÁª≠ ‚ÄúVirtioËÆæÂ§áÂíåÈ©±Âä®Ê¶ÇËø∞ ‚ÄúÁöÑÂÜÖÂÆπ„ÄÇÂú®‰∏ä‰∏ÄÁØáÊñáÁ´†‰∏≠ÔºåÊàë‰ª¨Â∑≤ÁªèËß£Èáä‰∫ÜËøô‰∏™Âú∫ÊôØÔºåÊàë‰ª¨Âç≥Â∞ÜÂà∞ËææÈáçÁÇπÔºöÊï∞ÊçÆÂ¶Ç‰Ωï‰ªévirtioËÆæÂ§áÂà∞È©±Âä®ÔºåÁÑ∂ÂêéÂÜçËøîÂõûÔºü</p>
<h2 id="Buffers-and-notifications-The-work-routine"><a href="#Buffers-and-notifications-The-work-routine" class="headerlink" title="Buffers and notifications: The work routine"></a>Buffers and notifications: The work routine</h2><blockquote>
<p>As stated earlier, a virtqueue is just a queue of guest‚Äôs buffers that the host consumes, either reading them or writing to them. A buffer can be read-only or write-only from the device point of view, but never both.</p>
</blockquote>
<p>Â¶ÇÂâçÊâÄËø∞ÔºåvirtqueueÂè™ÊòØ‰∏Ä‰∏™guestÁöÑÁºìÂÜ≤Âå∫ÈòüÂàóÔºå‰∏ªÊú∫Ê∂àËÄóÂÆÉ‰ª¨ÔºåË¶Å‰πàËØªÂèñÂÆÉ‰ª¨ÔºåË¶Å‰πàÂÜôÂÖ•ÂÆÉ‰ª¨„ÄÇ‰ªéËÆæÂ§áÁöÑËßíÂ∫¶Êù•ÁúãÔºå‰∏Ä‰∏™ÁºìÂÜ≤Âå∫ÂèØ‰ª•ÊòØÂè™ËØªÁöÑÔºå‰πüÂèØ‰ª•ÊòØÂè™ÂÜôÁöÑÔºå‰ΩÜÁªù‰∏çÊòØ‰∏§ËÄÖÈÉΩÊòØ„ÄÇ</p>
<blockquote>
<p>The descriptors can be chained, and the framing of the message can be spread whatever way is more convenient. For example, to spread a 2000 byte message in one single buffer or to use two 1000 byte buffers should be the same. </p>
</blockquote>
<p>ÊèèËø∞Á¨¶ÂèØ‰ª•ÊòØÈìæÁä∂ÁöÑÔºåÊ∂àÊÅØÁöÑÊûÑÊû∂ÂèØ‰ª•‰ª•‰ªª‰ΩïÊõ¥Êñπ‰æøÁöÑÊñπÂºè‰º†Êí≠„ÄÇ‰æãÂ¶ÇÔºåÂ∞Ü2000Â≠óËäÇÁöÑ‰ø°ÊÅØÂàÜÊï£Âú®‰∏Ä‰∏™Âçï‰∏ÄÁöÑÁºìÂÜ≤Âå∫‰∏≠ÔºåÊàñ‰ΩøÁî®‰∏§‰∏™1000Â≠óËäÇÁöÑÁºìÂÜ≤Âå∫ÔºåÂ∫îËØ•ÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ</p>
<blockquote>
<p>Also, it provides driver to device notifications (doorbell) method, to signal that one or more buffers have been added to the queue, and vice-versa, devices can interrupt the driver to signal used buffers. It is up to the underlying driver to provide the right method to dispatch the actual notification, for example using PCI interruptions or memory writing: The virtqueue only standardizes the semantics of it.</p>
</blockquote>
<p>Âè¶Â§ñÔºåÂÆÉËøòÊèê‰æõ‰∫ÜÈ©±Âä®Á®ãÂ∫èÂà∞ËÆæÂ§áÁöÑÈÄöÁü•ÔºàÈó®ÈìÉÔºâÊñπÊ≥ïÔºå‰ª•‰ø°Âè∑ÊòæÁ§∫‰∏Ä‰∏™ÊàñÂ§ö‰∏™ÁºìÂÜ≤Âå∫Â∑≤Ë¢´Ê∑ªÂä†Âà∞ÈòüÂàó‰∏≠ÔºåÂèç‰πã‰∫¶ÁÑ∂ÔºåËÆæÂ§áÂèØ‰ª•‰∏≠Êñ≠È©±Âä®Á®ãÂ∫è‰ª•‰ø°Âè∑ÊòæÁ§∫Â∑≤‰ΩøÁî®ÁöÑÁºìÂÜ≤Âå∫„ÄÇËøôÂèñÂÜ≥‰∫éÂ∫ïÂ±ÇÈ©±Âä®Á®ãÂ∫èÊèê‰æõÊ≠£Á°ÆÁöÑÊñπÊ≥ïÊù•Ë∞ÉÂ∫¶ÂÆûÈôÖÁöÑÈÄöÁü•Ôºå‰æãÂ¶Ç‰ΩøÁî®PCI‰∏≠Êñ≠ÊàñÂÜÖÂ≠òÂÜôÂÖ•„ÄÇvirtqueueÂè™ÊòØÂØπÂÆÉÁöÑËØ≠‰πâËøõË°å‰∫ÜÊ†áÂáÜÂåñ„ÄÇ</p>
<blockquote>
<p>As stated before, the driver and the device can advise the other to not to emit notifications to reduce its dispatching overhead. Since this operation is asynchronous we will describe how to do so in further sections.</p>
</blockquote>
<p>Â¶ÇÂâçÊâÄËø∞ÔºåÈ©±Âä®ÂíåËÆæÂ§áÂèØ‰ª•Âª∫ËÆÆÂØπÊñπ‰∏çË¶ÅÂèëÂá∫ÈÄöÁü•Ôºå‰ª•ÂáèÂ∞ëÂÖ∂Ë∞ÉÂ∫¶ÂºÄÈîÄ„ÄÇÁî±‰∫éËøô‰∏™Êìç‰ΩúÊòØÂºÇÊ≠•ÁöÑÔºåÊàë‰ª¨Â∞ÜÂú®ÂêéÁª≠Á´†ËäÇ‰∏≠ÊèèËø∞Â¶Ç‰ΩïÂÅöÂà∞Ëøô‰∏ÄÁÇπ„ÄÇ</p>
<h2 id="Split-virtqueue-the-beauty-of-simplicity"><a href="#Split-virtqueue-the-beauty-of-simplicity" class="headerlink" title="Split virtqueue: the beauty of simplicity"></a>Split virtqueue: the beauty of simplicity</h2><blockquote>
<p>The split virtqueue format separates the virtqueue into three areas, where each area is writable by either the driver or the device, but not both:</p>
<ul>
<li>Descriptor Area: used for describing buffers.</li>
<li>Driver Area: data supplied by driver to the device. Also called avail virtqueue.</li>
<li>Device Area: data supplied by device to driver. Also called used virtqueue.</li>
</ul>
</blockquote>
<p>split virtqueueÊ†ºÂºèÂ∞ÜvirtqueueÂàÜÊàê‰∏â‰∏™Âå∫ÂüüÔºåÊØè‰∏™Âå∫ÂüüÈÉΩÂèØ‰ª•Ë¢´È©±Âä®ÊàñËÆæÂ§áÂÜôÂÖ•Ôºå‰ΩÜ‰∏çËÉΩÂêåÊó∂ÂÜôÂÖ•„ÄÇ</p>
<ul>
<li>ÊèèËø∞Á¨¶Âå∫ÔºöÁî®‰∫éÊèèËø∞ÁºìÂÜ≤Âå∫„ÄÇ</li>
<li>È©±Âä®Âå∫ÔºöÁî±È©±Âä®Êèê‰æõÁªôËÆæÂ§áÁöÑÊï∞ÊçÆ„ÄÇ‰πüÁß∞‰∏∫Âà©Áî®ËôöÊãüÈòüÂàó„ÄÇ</li>
<li>ËÆæÂ§áÂå∫ÔºöÁî±ËÆæÂ§áÊèê‰æõÁªôÈ©±Âä®ÁöÑÊï∞ÊçÆ„ÄÇ‰πüÁß∞‰∏∫used virtqueue„ÄÇ</li>
</ul>
<blockquote>
<p>They need to be allocated in the driver‚Äôs memory for it to be able to access them in a straightforward way. Buffer addresses are stored from the driver‚Äôs point of view, and the device needs to perform an address translation. There are many ways for the device to access it depending on the latter nature:</p>
<ul>
<li>For an emulated device in the hypervisor (like qemu), the guest‚Äôs address is in its own process memory.</li>
<li>For other emulated devices like vhost-net or vhost-user, a memory mapping needs to be done, like POSIX shared memory. A file descriptor to that memory is shared through vhost protocol.</li>
<li>For a real device a hardware-level translation needs to be done, usually via IOMMU.</li>
</ul>
</blockquote>
<p>ÂÆÉ‰ª¨ÈúÄË¶ÅË¢´ÂàÜÈÖçÂà∞È©±Âä®Á®ãÂ∫èÁöÑÂÜÖÂ≠ò‰∏≠Ôºå‰ª•‰æøÂÆÉËÉΩÂ§üÁõ¥Êé•ËÆøÈóÆÂÆÉ‰ª¨„ÄÇÁºìÂÜ≤Âå∫Âú∞ÂùÄ‰ªéÈ©±Âä®Á®ãÂ∫èÁöÑËßíÂ∫¶Â≠òÂÇ®ÔºåËÆæÂ§áÈúÄË¶ÅËøõË°åÂú∞ÂùÄËΩ¨Êç¢„ÄÇÊ†πÊçÆÂêéËÄÖÁöÑÊÄßË¥®ÔºåËÆæÂ§áÊúâÂæàÂ§öÊñπÊ≥ïÂèØ‰ª•ËÆøÈóÆÂÆÉ„ÄÇ</p>
<ul>
<li>ÂØπ‰∫éÁÆ°ÁêÜÁ®ãÂ∫è‰∏≠ÁöÑ‰ªøÁúüËÆæÂ§áÔºàÂ¶ÇqemuÔºâÔºåÂÆ¢Êà∑ÁöÑÂú∞ÂùÄÂú®ÂÆÉËá™Â∑±ÁöÑËøõÁ®ãÂÜÖÂ≠ò‰∏≠„ÄÇ</li>
<li>ÂØπ‰∫éÂÖ∂‰ªñ‰ªøÁúüËÆæÂ§áÔºåÂ¶Çvhost-netÊàñvhost-userÔºåÈúÄË¶ÅÂÅö‰∏Ä‰∏™ÂÜÖÂ≠òÊò†Â∞ÑÔºåÂÉèPOSIXÂÖ±‰∫´ÂÜÖÂ≠ò‰∏ÄÊ†∑„ÄÇËØ•ÂÜÖÂ≠òÁöÑÊñá‰ª∂ÊèèËø∞Á¨¶ÊòØÈÄöËøávhostÂçèËÆÆÂÖ±‰∫´ÁöÑ„ÄÇ</li>
<li>ÂØπ‰∫é‰∏Ä‰∏™ÁúüÂÆûÁöÑËÆæÂ§áÔºåÈúÄË¶ÅÂÅö‰∏Ä‰∏™Á°¨‰ª∂Á∫ßÁöÑËΩ¨Êç¢ÔºåÈÄöÂ∏∏ÊòØÈÄöËøáIOMMU„ÄÇ</li>
</ul>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig1.png" class="">

<p><strong>Shared memory with split ring elements</strong></p>
<h3 id="Descriptor-ring-Where-is-my-data"><a href="#Descriptor-ring-Where-is-my-data" class="headerlink" title="Descriptor ring: Where is my data?"></a>Descriptor ring: Where is my data?</h3><blockquote>
<p>The descriptor area (or descriptor ring) is the first one that needs to be understood. It contains an array of a number of guest addressed buffers and its length. Each descriptor also contains a set of flags indicating more information about it. For example, the buffer continues in another descriptor buffer if the 0x1 bit is set, and the buffer is write-only for the device if the bit 0x2 is set, and is read-only if it is clear.</p>
</blockquote>
<p>ÊèèËø∞Á¨¶Âå∫ÔºàÊàñÊèèËø∞Á¨¶ÁéØÔºâÊòØÁ¨¨‰∏Ä‰∏™ÈúÄË¶ÅË¢´ÁêÜËß£ÁöÑ„ÄÇÂÆÉÂåÖÂê´‰∏Ä‰∏™Áî±Ëã•Âπ≤ÂÆ¢‰ΩìÂØªÂùÄÁöÑÁºìÂÜ≤Âå∫ÂíåÂÖ∂ÈïøÂ∫¶ÁªÑÊàêÁöÑÊï∞ÁªÑ„ÄÇÊØè‰∏™ÊèèËø∞Á¨¶ËøòÂåÖÂê´‰∏ÄÁªÑÊ†áÂøóÔºåË°®Á§∫ÂÖ≥‰∫éÂÆÉÁöÑÊõ¥Â§ö‰ø°ÊÅØ„ÄÇ‰æãÂ¶ÇÔºåÂ¶ÇÊûú0x1‰ΩçË¢´ËÆæÁΩÆÔºåÁºìÂÜ≤Âå∫Âú®Âè¶‰∏Ä‰∏™ÊèèËø∞Á¨¶ÁºìÂÜ≤Âå∫‰∏≠ÁªßÁª≠ÔºåÂ¶ÇÊûú0x2‰ΩçË¢´ËÆæÁΩÆÔºåÁºìÂÜ≤Âå∫ÂØπËÆæÂ§áÊù•ËØ¥ÊòØÂè™ÂÜôÁöÑÔºåÂ¶ÇÊûúÂÆÉË¢´Ê∏ÖÈô§ÔºåÂàôÊòØÂè™ËØªÁöÑ„ÄÇ</p>
<blockquote>
<p>This is the layout of a single descriptor. We will call leN for N bits in little endian format.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_desc</span> &#123;</span> </span><br><span class="line">        le64 addr;</span><br><span class="line">        le32 len;</span><br><span class="line">        le16 flags;</span><br><span class="line">        le16 next; <span class="comment">// Will explain this one later in the section &quot;Chained descriptors&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Split Virtqueue descriptor layout</strong></p>
</blockquote>
<p>ËøôÊòØ‰∏Ä‰∏™Âçï‰∏ÄÊèèËø∞Á¨¶ÁöÑÂ∏ÉÂ±Ä„ÄÇÊàë‰ª¨Â∞ÜË∞ÉÁî®leNÊù•Ë°®Á§∫little endianÊ†ºÂºèÁöÑN‰Ωç„ÄÇ</p>
<h3 id="Avail-ring-Supplying-data-to-the-device"><a href="#Avail-ring-Supplying-data-to-the-device" class="headerlink" title="Avail ring: Supplying data to the device"></a>Avail ring: Supplying data to the device</h3><blockquote>
<p>The next interesting structure is the driver area, or avail ring. Is the room where the driver places the descriptor (indexes) the device is going to consume. Note that placing a buffer here doesn‚Äôt mean that the device needs to consume immediately: virtio-net, for example, provides a bunch of descriptors for packet receiving that are only used by the device when a packet arrives, and are ‚Äúready to consume‚Äù until that moment.</p>
</blockquote>
<p>‰∏ã‰∏Ä‰∏™ÊúâË∂£ÁöÑÁªìÊûÑÊòØÈ©±Âä®Âå∫ÔºåÊàñËÄÖËØ¥AvailÁéØ„ÄÇÊòØÈ©±Âä®Á®ãÂ∫èÊîæÁΩÆËÆæÂ§áË¶ÅÊ∂àËÄóÁöÑÊèèËø∞Á¨¶ÔºàÁ¥¢ÂºïÔºâÁöÑÁ©∫Èó¥„ÄÇÊ≥®ÊÑèÔºåÂú®ËøôÈáåÊîæÁΩÆÁºìÂÜ≤Âå∫Âπ∂‰∏çÊÑèÂë≥ÁùÄËÆæÂ§áÈúÄË¶ÅÁ´ãÂç≥Ê∂àË¥πÔºö‰æãÂ¶ÇÔºåvirtio-net‰∏∫Êï∞ÊçÆÂåÖÊé•Êî∂Êèê‰æõ‰∫Ü‰∏ÄÂ†ÜÊèèËø∞Á¨¶ÔºåËøô‰∫õÊèèËø∞Á¨¶Âè™ÊúâÂú®Êï∞ÊçÆÂåÖÂà∞ËææÊó∂Êâç‰ºöË¢´ËÆæÂ§á‰ΩøÁî®ÔºåÁõ¥Âà∞ÈÇ£‰∏ÄÂàªÊâç‰ºö ‚ÄúÂáÜÂ§áÊ∂àË¥π‚Äù„ÄÇ</p>
<blockquote>
<p>The avail ring has two important fields that only the driver can write and the device only can read them: idx and flags. The idx field indicates where the driver would put the next descriptor entry in the avail ring (modulo the queue size). On the other hand, the least significant bit of flags indicates if the driver wants to be notified or not (called <code>VIRTQ_AVAIL_F_NO_INTERRUPT</code>).</p>
</blockquote>
<p>availÁéØÊúâ‰∏§‰∏™ÈáçË¶ÅÁöÑÂ≠óÊÆµÔºåÂè™ÊúâÈ©±Âä®Á®ãÂ∫èÂèØ‰ª•ÂÜôÂÖ•ÔºåËÆæÂ§áÂè™ËÉΩËØªÂèñÂÆÉ‰ª¨ÔºöidxÂíåflags„ÄÇidxÂ≠óÊÆµÊåáÂá∫‰∫ÜÈ©±Âä®Á®ãÂ∫èÂ∞ÜÊää‰∏ã‰∏Ä‰∏™ÊèèËø∞Á¨¶Êù°ÁõÆÊîæÂú®avail ring‰∏≠ÁöÑ‰ΩçÁΩÆÔºàmodulo the queue sizeÔºâ„ÄÇÂè¶‰∏ÄÊñπÈù¢ÔºåflagsÁöÑÊúÄÂ∞èÊúâÊïà‰ΩçË°®Á§∫È©±Âä®ÊòØÂê¶Ë¶ÅË¢´ÈÄöÁü•ÔºàÁß∞‰∏∫<code>VIRTQ_AVAIL_F_NO_INTERRUPT</code>Ôºâ„ÄÇ</p>
<blockquote>
<p>After these two fields, an array of integers of the same length as the descriptors ring. So the avail virtqueue layout is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_avail</span> &#123;</span></span><br><span class="line">        le16 flags;</span><br><span class="line">        le16 idx;</span><br><span class="line">        le16 ring[ <span class="comment">/* Queue Size */</span> ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Avail virtqueue layout</strong></p>
</blockquote>
<p>Âú®Ëøô‰∏§‰∏™Â≠óÊÆµ‰πãÂêéÔºåÊòØ‰∏Ä‰∏™‰∏éÊèèËø∞Á¨¶ÁéØÁõ∏ÂêåÈïøÂ∫¶ÁöÑÊï¥Êï∞ÈòµÂàó„ÄÇÂõ†Ê≠§Ôºåavail virtqueue layout:</p>
<blockquote>
<p><strong>Figure 1</strong> shows a descriptor table with a 2000 bytes long buffer that starts in position 0x8000, and an avail ring that still does not have any entry. After all the steps, a components diagram highlighting the descriptor area update. The first step for the driver is to allocate the buffer with the memory and fill it (this is the step 1 in the ‚ÄúProcess to make a buffer available‚Äù diagram), and to make available on the descriptor area after that (step 2).</p>
</blockquote>
<p>Âõæ1ÊòæÁ§∫‰∫Ü‰∏Ä‰∏™ÂÖ∑Êúâ2000Â≠óËäÇÈïøÁöÑÁºìÂÜ≤Âå∫ÁöÑÊèèËø∞Á¨¶Ë°®ÔºåÂÆÉ‰ªé‰ΩçÁΩÆ0x8000ÂºÄÂßãÔºåËÄå‰∏Ä‰∏™Âà©Áî®ÁéØ‰ªçÁÑ∂Ê≤°Êúâ‰ªª‰ΩïÊù°ÁõÆ„ÄÇÂú®ÊâÄÊúâÁöÑÊ≠•È™§‰πãÂêéÔºå‰∏Ä‰∏™ÁªÑ‰ª∂ÂõæÁ™ÅÂá∫‰∫ÜÊèèËø∞Á¨¶Ë¢´Êõ¥Êñ∞ÁöÑÈÉ®ÂàÜ„ÄÇÈ©±Âä®Á®ãÂ∫èÁöÑÁ¨¨‰∏ÄÊ≠•ÊòØÂàÜÈÖçÁºìÂÜ≤Âå∫ÁöÑÂÜÖÂ≠òÂπ∂Â∞ÜÂÖ∂Â°´Êª°ÔºàËøôÊòØ ‚Äú‰ΩøÁºìÂÜ≤Âå∫ÂèØÁî®ÁöÑËøáÁ®ã ‚ÄúÂõæ‰∏≠ÁöÑÁ¨¨1Ê≠•ÔºâÔºåÁÑ∂ÂêéÂú®ÊèèËø∞Á¨¶Âå∫‰∏ä‰ΩøÂÖ∂ÂèØÁî®ÔºàÁ¨¨2Ê≠•Ôºâ„ÄÇ</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig2.png" class="">

<p><strong>Figure 1: Driver writes a buffer in descriptor ring</strong></p>
<blockquote>
<p>After populating descriptor entry, driver advises of it using the avail ring: It writes the descriptor index #0 in the first entry of the avail ring, and updates idx entry accordly. The result of this is shown in Figure 2. In the case that supply chained buffers, only the descriptor head index should be added this way, and avail idx would increase only by 1. This is the step 3 in the diagram.</p>
</blockquote>
<p>Âú®Â°´ÂÖÖÂÆåÊèèËø∞Á¨¶Êù°ÁõÆÂêéÔºåÈ©±Âä®ÈÄöÁü•ÂÆÉ‰ΩøÁî®Á©∫Èó≤ÁéØ„ÄÇÂÆÉÂ∞ÜÊèèËø∞Á¨¶ÁöÑÁ¥¢Âºï#0ÂÜôÂú®avail ringÁöÑÁ¨¨‰∏Ä‰∏™Êù°ÁõÆ‰∏≠ÔºåÂπ∂Áõ∏Â∫îÂú∞Êõ¥Êñ∞idxÊù°ÁõÆ„ÄÇÂÖ∂ÁªìÊûúÂ¶ÇÂõæ2ÊâÄÁ§∫„ÄÇÂú®Êèê‰æõÈìæÂºèÁºìÂÜ≤Âå∫ÁöÑÊÉÖÂÜµ‰∏ãÔºåÂè™ÊúâÊèèËø∞Á¨¶Â§¥ÈÉ®ÁöÑÁ¥¢ÂºïÂ∫îËØ•ËøôÊ†∑Ê∑ªÂä†ÔºåËÄåavail idxÂè™Â¢ûÂä†1„ÄÇËøôÂ∞±ÊòØÂõæ‰∏≠ÁöÑÁ¨¨‰∏âÊ≠•„ÄÇ</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig3.png" class="">

<p><strong>Figure 2: Driver offers the buffer with avail ring</strong></p>
<blockquote>
<p>From now on, the driver should not modify the available descriptor or the exposed buffer at any moment: It is under the device‚Äôs control. Now the driver needs to notify the device if the latter has enabled notifications at that moment (more on how the device manages this later). This is the last step 4 in the diagram.</p>
</blockquote>
<p>‰ªéÁé∞Âú®ÂºÄÂßãÔºåÈ©±Âä®Á®ãÂ∫è‰∏çÂ∫îËØ•Âú®‰ªª‰ΩïÊó∂ÂÄô‰øÆÊîπÂèØÁî®ÁöÑÊèèËø∞Á¨¶ÊàñÊö¥Èú≤ÁöÑÁºìÂÜ≤Âå∫„ÄÇËøôÊòØÁî±ËÆæÂ§áÊéßÂà∂ÁöÑ„ÄÇÁé∞Âú®ÔºåÈ©±Âä®Á®ãÂ∫èÈúÄË¶ÅÈÄöÁü•ËÆæÂ§áÔºåÂ¶ÇÊûúÂêéËÄÖÂú®ÂΩìÊó∂ÂêØÁî®‰∫ÜÈÄöÁü•ÂäüËÉΩÔºàÂêéÈù¢‰ºöÊúâÊõ¥Â§öÂÖ≥‰∫éËÆæÂ§áÂ¶Ç‰ΩïÁÆ°ÁêÜÁöÑÂÜÖÂÆπÔºâ„ÄÇËøôÂ∞±ÊòØÂõæ‰∏≠ÁöÑÊúÄÂêé‰∏ÄÊ≠•4„ÄÇ</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig4.png" class="">

<p><strong>Diagram: Process to make a buffer available</strong></p>
<blockquote>
<p>The avail ring must be able to hold the same number of descriptors as the descriptor area, and the descriptor area must have a size power of two, so idx wraps naturally at some point. For example, if the ring size is 256 entries, idx 1 references the same descriptor as idx 257, 513‚Ä¶ And it will wrap at a 16 bit boundary. This way, neither side needs to worry about processing an invalid idx: They are all valid.</p>
</blockquote>
<p>AvailÁéØÂøÖÈ°ªËÉΩÂ§üÂÆπÁ∫≥‰∏éÊèèËø∞Á¨¶Âå∫Áõ∏ÂêåÊï∞ÈáèÁöÑÊèèËø∞Á¨¶ÔºåÊèèËø∞Á¨¶Âå∫ÁöÑÂ§ßÂ∞èÂøÖÈ°ªÊòØ2ÁöÑÂπÇÔºåÊâÄ‰ª•idxÂú®Êüê‰∏ÄÁÇπ‰∏äËá™ÁÑ∂‰ºöË¢´ÂåÖË£πËµ∑Êù•„ÄÇ‰æãÂ¶ÇÔºåÂ¶ÇÊûúÁéØÁöÑÂ§ßÂ∞èÊòØ256‰∏™Êù°ÁõÆÔºåidx 1ÂºïÁî®ÁöÑÊèèËø∞Á¨¶‰∏éidx 257„ÄÅ513‚Ä¶Áõ∏Âêå„ÄÇËÄåÂÆÉÂ∞ÜÂú®16‰ΩçËæπÁïåÂ§ÑË¢´ÂåÖË£πËµ∑Êù•„ÄÇËøôÊ†∑‰∏ÄÊù•ÔºåÂèåÊñπÈÉΩ‰∏çÈúÄË¶ÅÊãÖÂøÉÂ§ÑÁêÜÊó†ÊïàÁöÑidx„ÄÇÂÆÉ‰ª¨ÈÉΩÊòØÊúâÊïàÁöÑ„ÄÇ</p>
<blockquote>
<p>Note that descriptors can be added in any order to the avail ring, one does not need to start from descriptor table entry 0 nor continue by the next descriptor.</p>
</blockquote>
<p>ËØ∑Ê≥®ÊÑèÔºåÊèèËø∞Á¨¶ÂèØ‰ª•‰ª•‰ªª‰ΩïÈ°∫Â∫èÊ∑ªÂä†Âà∞Âà©Áî®ÁéØ‰∏≠Ôºå‰∏çÈúÄË¶Å‰ªéÊèèËø∞Á¨¶Ë°®ÁöÑÁ¨¨0Êù°ÂºÄÂßãÔºå‰πü‰∏çÈúÄË¶Å‰ªé‰∏ã‰∏Ä‰∏™ÊèèËø∞Á¨¶ÁªßÁª≠„ÄÇ</p>
<h3 id="Chained-descriptors-Supplying-large-data-to-the-device"><a href="#Chained-descriptors-Supplying-large-data-to-the-device" class="headerlink" title="Chained descriptors: Supplying large data to the device"></a>Chained descriptors: Supplying large data to the device</h3><blockquote>
<p>The driver can also chain more than one descriptor using its next member. If the NEXT (0x1) flag of a descriptor is set, the data continue in another buffer, making a chain of descriptors. Note that the descriptors in a chain do not share flags: Some descriptors can be read-only, and the others can be write-only. In this case, write-only descriptors must come after all write-only ones.</p>
</blockquote>
<p>È©±Âä®Á®ãÂ∫è‰πüÂèØ‰ª•‰ΩøÁî®ÂÖ∂‰∏ã‰∏Ä‰∏™ÊàêÂëòÊù•ËøûÈîÅ‰∏Ä‰∏™‰ª•‰∏äÁöÑÊèèËø∞Á¨¶„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™ÊèèËø∞Á¨¶ÁöÑNEXT(0x1)Ê†áÂøóË¢´ËÆæÁΩÆÔºåÊï∞ÊçÆÂú®Âè¶‰∏Ä‰∏™ÁºìÂÜ≤Âå∫‰∏≠ÁªßÁª≠ÔºåÂΩ¢Êàê‰∏Ä‰∏™ÊèèËø∞Á¨¶Èìæ„ÄÇÊ≥®ÊÑèÔºå‰∏Ä‰∏™Èìæ‰∏≠ÁöÑÊèèËø∞Á¨¶‰∏çÂÖ±‰∫´Ê†áÂøó„ÄÇÊúâ‰∫õÊèèËø∞Á¨¶ÂèØ‰ª•ÊòØÂè™ËØªÁöÑÔºåËÄåÂÖ∂‰ªñÊèèËø∞Á¨¶ÂèØ‰ª•ÊòØÂè™ÂÜôÁöÑ„ÄÇÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÂè™ÂÜôÁöÑÊèèËø∞Á¨¶ÂøÖÈ°ªÊéíÂú®ÊâÄÊúâÂè™ÂÜôÁöÑÊèèËø∞Á¨¶‰πãÂêé„ÄÇ</p>
<blockquote>
<p>For example, if the driver has sent us two buffers in a chain with descriptor table indexes 0 and 1 as first operation, the device would see the scenario in Figure 3, and it would be the step 2 again.</p>
</blockquote>
<p>‰æãÂ¶ÇÔºåÂ¶ÇÊûúÈ©±Âä®Á®ãÂ∫èÂú®ÊèèËø∞Á¨¶Ë°®Á¥¢Âºï‰∏∫0Âíå1ÁöÑÈìæ‰∏≠ÂêëÊàë‰ª¨ÂèëÈÄÅ‰∫Ü‰∏§‰∏™ÁºìÂÜ≤Âå∫Ôºå‰Ωú‰∏∫Á¨¨‰∏ÄÊ¨°Êìç‰ΩúÔºåËÆæÂ§á‰ºöÁúãÂà∞Âõæ3‰∏≠ÁöÑÊÉÖÊôØÔºåÂÆÉÂ∞ÜÂÜçÊ¨°Êàê‰∏∫Ê≠•È™§2„ÄÇ</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig5.png" class="">

<p><strong>Figure 3: Device sees chained buffers</strong></p>
<h3 id="Used-ring-When-the-device-is-done-with-the-data"><a href="#Used-ring-When-the-device-is-done-with-the-data" class="headerlink" title="Used ring: When the device is done with the data"></a>Used ring: When the device is done with the data</h3><blockquote>
<p>The device employs the used ring to return the used (read or written) buffers to the driver. As the avail ring, it has the flags and idx members. They have the same layout and serve the same purpose, although the notification flag is now called <code>VIRTQ_USED_F_NO_NOTIFY</code>.</p>
</blockquote>
<p>ËÆæÂ§á‰ΩøÁî®‰ΩøÁî®ËøáÁöÑÁéØÂ∞Ü‰ΩøÁî®ËøáÁöÑÔºàËØªÊàñÂÜôÔºâÁºìÂÜ≤Âå∫ËøîÂõûÁªôÈ©±Âä®„ÄÇ‰∏éavailÁéØ‰∏ÄÊ†∑ÔºåÂÆÉ‰πüÊúâflagsÂíåidxÊàêÂëò„ÄÇÂÆÉ‰ª¨ÂÖ∑ÊúâÁõ∏ÂêåÁöÑÂ∏ÉÂ±ÄÂíåÁõ∏ÂêåÁöÑÁõÆÁöÑÔºåÂ∞ΩÁÆ°ÈÄöÁü•Ê†áÂøóÁé∞Âú®Ë¢´Áß∞‰∏∫<code>VIRTQ_USED_F_NO_NOTIFY</code>„ÄÇ</p>
<blockquote>
<p>After them, it maintains an array of used descriptors. In this array, the device returns not only the descriptor index but also the used length in case of writing.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_used</span> &#123;</span></span><br><span class="line">        le16 flags;</span><br><span class="line">        le16 idx;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtq_used_elem</span> <span class="title">ring</span>[ /* <span class="title">Queue</span> <span class="title">Size</span> */];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_used_elem</span> &#123;</span></span><br><span class="line">        <span class="comment">/* Index of start of used descriptor chain. */</span></span><br><span class="line">        le32 id;</span><br><span class="line">        <span class="comment">/* Total length of the descriptor chain which was used (written to) */</span></span><br><span class="line">        le32 len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Used virtqueue layout</strong></p>
</blockquote>
<p>Âú®ÂÆÉ‰ª¨‰πãÂêéÔºåÂÆÉÁª¥Êä§‰∏Ä‰∏™Â∑≤‰ΩøÁî®ÁöÑÊèèËø∞Á¨¶Êï∞ÁªÑ„ÄÇÂú®Ëøô‰∏™Êï∞ÁªÑ‰∏≠ÔºåËÆæÂ§á‰∏ç‰ªÖËøîÂõûÊèèËø∞Á¨¶ÁöÑÁ¥¢ÂºïÔºåËÄå‰∏îÂú®ÂÜôÂÖ•ÁöÑÊÉÖÂÜµ‰∏ãËøîÂõûÂ∑≤‰ΩøÁî®ÁöÑÈïøÂ∫¶„ÄÇ</p>
<blockquote>
<p>In case of returning a chain of descriptors, only the id of the head of the chain is returned, and the total written length through all descriptors, not increasing it when data is read. The descriptor table is not touched at all, it is read-only for the device. This is step 5 in the ‚ÄúProcess to make a buffer as used‚Äù diagram.</p>
</blockquote>
<p>Âú®ËøîÂõûÊèèËø∞Á¨¶ÈìæÁöÑÊÉÖÂÜµ‰∏ãÔºåÂè™ËøîÂõûÈìæÂ§¥ÁöÑidÔºå‰ª•ÂèäÈÄöËøáÊâÄÊúâÊèèËø∞Á¨¶ÁöÑÊÄªÂÜôÂÖ•ÈïøÂ∫¶ÔºåÂú®ËØªÂèñÊï∞ÊçÆÊó∂‰∏çÂ¢ûÂä†ÂÆÉ„ÄÇÊèèËø∞Á¨¶Ë°®ÂÆåÂÖ®‰∏çË¢´Ëß¶ÂèäÔºåÂÆÉÂØπËÆæÂ§áÊù•ËØ¥ÊòØÂè™ËØªÁöÑ„ÄÇËøôÊòØ ‚ÄúÂà∂‰Ωú‰ΩøÁî®ÁöÑÁºìÂÜ≤Âå∫ÁöÑËøáÁ®ã ‚ÄúÂõæ‰∏≠ÁöÑÁ¨¨5Ê≠•„ÄÇ</p>
<blockquote>
<p>For example, if the device uses the chain of descriptors exposed in the Chained descriptors version:</p>
</blockquote>
<p>‰æãÂ¶ÇÔºåÂ¶ÇÊûúËÆæÂ§á‰ΩøÁî®ÈìæÂºèÊèèËø∞Á¨¶ÁâàÊú¨‰∏≠Êö¥Èú≤ÁöÑÈìæÂºèÊèèËø∞Á¨¶:</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig6.png" class="">

<p><strong>Figure 4: Device returns buffer chain</strong></p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig7.png" class="">

<p><strong>Diagram: Process to mark a buffer as used</strong></p>
<blockquote>
<p>Lastly, the device will notify the driver if it sees that the driver wants to be notified, using the used queue flags to know it (step 6).</p>
</blockquote>
<p>ÊúÄÂêéÔºåÂ¶ÇÊûúËÆæÂ§áÁúãÂà∞È©±Âä®ÊÉ≥Ë¢´ÈÄöÁü•ÔºåÂÆÉÂ∞ÜÈÄöÁü•È©±Âä®Ôºå‰ΩøÁî®‰ΩøÁî®ÁöÑÈòüÂàóÊ†áÂøóÊù•Áü•ÈÅìÂÆÉÔºàÊ≠•È™§6Ôºâ„ÄÇ</p>
<h3 id="Indirect-descriptors-supplying-a-lot-of-data-to-the-device"><a href="#Indirect-descriptors-supplying-a-lot-of-data-to-the-device" class="headerlink" title="Indirect descriptors: supplying a lot of data to the device"></a>Indirect descriptors: supplying a lot of data to the device</h3><blockquote>
<p>Indirect descriptors are a way to dispatch a larger number of descriptors in a batch, increasing the ring capacity. The driver stores a table of indirect descriptors (the same layout as the regular descriptors) anywhere in memory, and inserts a descriptor in the virtqueue with the flag <code>VIRTQ_DESC_F_INDIRECT (0x4)</code> set. The descriptor‚Äôs address and length correspond to the indirect table‚Äôs ones.</p>
</blockquote>
<p>Èó¥Êé•ÊèèËø∞Á¨¶ÊòØ‰∏ÄÁßçÂú®‰∏Ä‰∏™ÊâπÊ¨°‰∏≠Ë∞ÉÂ∫¶Êõ¥Â§öÊèèËø∞Á¨¶ÁöÑÊñπÊ≥ïÔºåÂ¢ûÂä†‰∫ÜÁéØÁöÑÂÆπÈáè„ÄÇÈ©±Âä®Á®ãÂ∫èÂú®ÂÜÖÂ≠òÁöÑ‰ªª‰ΩïÂú∞ÊñπÂ≠òÂÇ®‰∏Ä‰∏™Èó¥Êé•ÊèèËø∞Á¨¶Ë°®Ôºà‰∏éÊôÆÈÄöÊèèËø∞Á¨¶ÁöÑÂ∏ÉÂ±ÄÁõ∏ÂêåÔºâÔºåÂπ∂Âú®virtqueue‰∏≠ÊèíÂÖ•‰∏Ä‰∏™ÊèèËø∞Á¨¶ÔºåÂπ∂ËÆæÁΩÆÊ†áÂøó<code>VIRTQ_DESC_F_INDIRECTÔºà0x4Ôºâ</code>„ÄÇËØ•ÊèèËø∞Á¨¶ÁöÑÂú∞ÂùÄÂíåÈïøÂ∫¶ÂØπÂ∫î‰∫éÈó¥Êé•Ë°®ÁöÑÈïøÂ∫¶„ÄÇ</p>
<blockquote>
<p>If we want to add the chain described in section Chained descriptors to an indirect table, the driver first allocates the memory region of 2 entries (32 bytes) to hold the latter (step 2 in the diagram after allocate the buffers in the step 1):</p>
<table>
<thead>
<tr>
<th>Buffer</th>
<th>Len</th>
<th>Flags</th>
<th>Next</th>
</tr>
</thead>
<tbody><tr>
<td>0x8000</td>
<td>0x2000</td>
<td>W|N</td>
<td>1</td>
</tr>
<tr>
<td>0xD000</td>
<td>0x2000</td>
<td>W</td>
<td>‚Ä¶</td>
</tr>
</tbody></table>
<p><strong>Figure 4: Indirect table for indirect descriptors</strong></p>
</blockquote>
<p>Â¶ÇÊûúÊàë‰ª¨ÊÉ≥Âú®‰∏Ä‰∏™Èó¥Êé•Ë°®‰∏äÊ∑ªÂä†ÈìæÂºèÊèèËø∞Á¨¶ÔºåÈ©±Âä®Á®ãÂ∫èÈ¶ñÂÖàÂàÜÈÖç2‰∏™Êù°ÁõÆÔºà32Â≠óËäÇÔºâÁöÑÂÜÖÂ≠òÂå∫ÂüüÊù•ÂÆπÁ∫≥ÂêéËÄÖÔºàÂõæ‰∏≠ÁöÑÁ¨¨2Ê≠•ÔºåÂú®Á¨¨1Ê≠•‰∏≠ÂàÜÈÖç‰∫ÜÁºìÂÜ≤Âå∫‰πãÂêéÔºâ„ÄÇ</p>
<blockquote>
<p>Let‚Äôs suppose it has been allocated on memory position <code>0x2000</code>, and it is the first descriptor made available. As usual, the first step is to include it in the Descriptor area (step 3 in the diagram), so it would look like:</p>
<table>
<thead>
<tr>
<th>Descriptor Area</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Buffer</td>
<td>Len</td>
<td>Flags</td>
<td>Next</td>
</tr>
<tr>
<td>0x2000</td>
<td>32</td>
<td>I</td>
<td>‚Ä¶</td>
</tr>
</tbody></table>
<p><strong>Figure 5: Add indirect table to Descriptor area</strong></p>
</blockquote>
<p>ËÆ©Êàë‰ª¨ÂÅáËÆæÂÆÉË¢´ÂàÜÈÖçÂú®ÂÜÖÂ≠ò‰ΩçÁΩÆ<code>0x2000</code>ÔºåÂπ∂‰∏îÊòØÁ¨¨‰∏Ä‰∏™ÂèØÁî®ÁöÑÊèèËø∞Á¨¶„ÄÇÂÉèÂæÄÂ∏∏‰∏ÄÊ†∑ÔºåÁ¨¨‰∏ÄÊ≠•ÊòØÊääÂÆÉÁ∫≥ÂÖ•ÊèèËø∞Á¨¶Âå∫ÂüüÔºàÂõæ‰∏≠ÁöÑÁ¨¨3Ê≠•ÔºâÔºåÊâÄ‰ª•ÂÆÉÁúãËµ∑Êù•ÂÉè„ÄÇ</p>
<blockquote>
<p>After that, the steps are the same as with regular descriptors: The driver adds the index of the descriptor marked with the flag in the descriptor area to the avail ring (#0 in this case, step 4 in the diagram), and notify the device as usual (step 5).</p>
</blockquote>
<p>‰πãÂêéÔºåÊ≠•È™§‰∏éÊôÆÈÄöÊèèËø∞Á¨¶Áõ∏Âêå„ÄÇÈ©±Âä®Á®ãÂ∫èÂ∞ÜÊèèËø∞Á¨¶Âå∫Âüü‰∏≠Ê†áÊúâÊ†áÂøóÁöÑÊèèËø∞Á¨¶ÁöÑÁ¥¢ÂºïÊ∑ªÂä†Âà∞Âà©Áî®ÁéØ‰∏≠ÔºàÊú¨‰æã‰∏≠‰∏∫#0ÔºåÂõæ‰∏≠Á¨¨4Ê≠•ÔºâÔºåÂπ∂ÂÉèÂæÄÂ∏∏‰∏ÄÊ†∑ÈÄöÁü•ËÆæÂ§áÔºàÁ¨¨5Ê≠•Ôºâ„ÄÇ</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig8.png" class="">

<p><strong>Diagram: Driver make available indirect descriptors</strong></p>
<blockquote>
<p>For the device to use its data, and would use the same memory addresses to return its <code>0x3000</code> bytes (all <code>0x8000-0x9FFF</code> and <code>0xD000-0xDFFF</code>) (Step 6 and 7, same as with regular descriptors). Once used by the device, the driver can release the indirect memory or do whatever it wants with it, as it could do with any regular buffer.</p>
</blockquote>
<p>ÂØπ‰∫éËÆæÂ§á‰ΩøÁî®ÂÖ∂Êï∞ÊçÆÔºåÂπ∂Â∞Ü‰ΩøÁî®Áõ∏ÂêåÁöÑÂÜÖÂ≠òÂú∞ÂùÄÊù•ËøîÂõûÂÖ∂0x3000Â≠óËäÇÔºàÊâÄÊúâ0x8000-0x9FFFÂíå0xD000-0xDFFFÔºâÔºàÊ≠•È™§6Âíå7Ôºå‰∏éÂ∏∏ËßÑÊèèËø∞Á¨¶Áõ∏ÂêåÔºâ„ÄÇ‰∏ÄÊó¶Ë¢´ËÆæÂ§á‰ΩøÁî®ÔºåÈ©±Âä®Á®ãÂ∫èÂèØ‰ª•ÈáäÊîæÈó¥Êé•ÂÜÖÂ≠òÊàñÂØπÂÖ∂ÂÅö‰ªª‰Ωï‰∫ãÊÉÖÔºåÂ∞±ÂÉèÂÆÉÂèØ‰ª•ÂØπ‰ªª‰ΩïÂ∏∏ËßÑÁºìÂÜ≤Âå∫ÂÅöÁöÑÈÇ£Ê†∑„ÄÇ</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig9.png" class="">

<p><strong>Diagram: Device mark the indirect descriptor as used</strong></p>
<blockquote>
<p>Descriptors with <code>INDIRECT</code> flag cannot have <code>NEXT</code> or <code>WRITE</code> flags set, so you cannot chain indirect descriptors in the descriptor table, and the indirect table can contain at maximum the same number of descriptors as the descriptor table.</p>
</blockquote>
<p>Â∏¶ÊúâINDIRECTÊ†áÂøóÁöÑÊèèËø∞Á¨¶‰∏çËÉΩËÆæÁΩÆNEXTÊàñWRITEÊ†áÂøóÔºåÊâÄ‰ª•‰∏çËÉΩÂú®ÊèèËø∞Á¨¶Ë°®‰∏≠ËøûÈîÅÈó¥Êé•ÊèèËø∞Á¨¶ÔºåÈó¥Êé•Ë°®ÊúÄÂ§öÂèØ‰ª•ÂåÖÂê´‰∏éÊèèËø∞Á¨¶Ë°®Áõ∏ÂêåÊï∞ÈáèÁöÑÊèèËø∞Á¨¶„ÄÇ</p>
<h3 id="Notifications-Learning-the-‚Äúdo-not-disturb‚Äù-mode"><a href="#Notifications-Learning-the-‚Äúdo-not-disturb‚Äù-mode" class="headerlink" title="Notifications. Learning the ‚Äúdo not disturb‚Äù mode"></a>Notifications. Learning the ‚Äúdo not disturb‚Äù mode</h3><blockquote>
<p>In many systems used and available buffer notifications involve significant overhead. To mitigate it, each virtring maintains a flag to indicate when it wants to be notified. Remember that the driver‚Äôs one is read-only by the device, and the device‚Äôs one is read-only by the driver.</p>
</blockquote>
<p>Âú®ËÆ∏Â§öÁ≥ªÁªü‰∏≠Ôºå‰ΩøÁî®ÁöÑÂíåÂèØÁî®ÁöÑÁºìÂÜ≤Âå∫ÈÄöÁü•Ê∂âÂèäÂ§ßÈáèÁöÑÂºÄÈîÄ„ÄÇ‰∏∫‰∫ÜÂáèËΩªÂÆÉÔºåÊØè‰∏™virtringÈÉΩÁª¥Êä§ÁùÄ‰∏Ä‰∏™Ê†áÂøóÔºå‰ª•Ë°®ÊòéÂÆÉ‰ªÄ‰πàÊó∂ÂÄôÊÉ≥Ë¢´ÈÄöÁü•„ÄÇËÆ∞‰ΩèÔºåÈ©±Âä®ÁöÑÈÇ£‰∏™ÊòØËÆæÂ§áÂè™ËØªÁöÑÔºåËÄåËÆæÂ§áÁöÑÈÇ£‰∏™ÊòØÈ©±Âä®Âè™ËØªÁöÑ„ÄÇ</p>
<blockquote>
<p>We already know all of this, and its use is pretty straightforward. The only thing you need to take care of is the asynchronous nature of this method: The side of the communication that disables or enables it can‚Äôt be sure that the other end is going to know the change, so you can miss notifications or to have more than expected.</p>
</blockquote>
<p>Êàë‰ª¨Â∑≤ÁªèÁü•ÈÅì‰∫ÜËøô‰∫õÔºåÂÆÉÁöÑ‰ΩøÁî®ÊòØÈùûÂ∏∏Áõ¥Êé•ÁöÑ„ÄÇ‰Ω†ÂîØ‰∏ÄÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØËøô‰∏™ÊñπÊ≥ïÁöÑÂºÇÊ≠•ÊÄß„ÄÇÈÄö‰ø°‰∏≠Á¶ÅÁî®ÊàñÂêØÁî®ÂÆÉÁöÑ‰∏ÄÊñπ‰∏çËÉΩÁ°ÆÂÆöÂè¶‰∏ÄÁ´ØÊòØÂê¶‰ºöÁü•ÈÅìËøô‰∏™ÂèòÂåñÔºåÊâÄ‰ª•‰Ω†ÂèØËÉΩ‰ºöÈîôËøáÈÄöÁü•ÊàñË¶ÅÊØîÈ¢ÑÊúüÁöÑÂ§ö„ÄÇ</p>
<blockquote>
<p>A more effective way of notifications toggle is enabled if the <code>VIRTIO_F_EVENT_IDX</code> feature bit is negotiated by device and driver: Instead of disable them in a binary fashion, driver and device can specify how far the other can progress before a notification is required using an specific descriptor id. This id is advertised using a extra le16 member at the end of the structure, so they grow like this:</p>
</blockquote>
<p>Â¶ÇÊûúËÆæÂ§áÂíåÈ©±Âä®ÂçèÂïÜ<code>VIRTIO_F_EVENT_IDX</code>ÁâπÊÄß‰ΩçÔºåÂ∞±ÂèØ‰ª•ÂêØÁî®‰∏ÄÁßçÊõ¥ÊúâÊïàÁöÑÈÄöÁü•ÂàáÊç¢ÊñπÂºè„ÄÇËÄå‰∏çÊòØ‰ª•‰∫åËøõÂà∂ÁöÑÊñπÂºèÁ¶ÅÁî®ÂÆÉ‰ª¨ÔºåÈ©±Âä®ÂíåËÆæÂ§áÂèØ‰ª•‰ΩøÁî®‰∏Ä‰∏™ÁâπÂÆöÁöÑÊèèËø∞Á¨¶idÊù•ÊåáÂÆöÂØπÊñπÂú®ÈúÄË¶ÅÈÄöÁü•‰πãÂâçÂèØ‰ª•ËøõÂ±ïÂà∞‰ªÄ‰πàÁ®ãÂ∫¶„ÄÇËøô‰∏™idÂú®ÁªìÊûÑÁöÑÊú´Â∞æ‰ΩøÁî®‰∏Ä‰∏™È¢ùÂ§ñÁöÑle16ÊàêÂëòËøõË°åÂÆ£‰º†ÔºåÊâÄ‰ª•ÂÆÉ‰ª¨ÁöÑÂ¢ûÈïøÊñπÂºèÊòØËøôÊ†∑ÁöÑ„ÄÇ</p>
<blockquote>
<p>The struct layout is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct virtq_avail &#123;              struct virtq_used &#123;</span><br><span class="line">  le16 flags;                       le16 flags;</span><br><span class="line">  le16 idx;                         le16 idx;</span><br><span class="line">  le16 ring[ &#x2F;* Queue Size *&#x2F; ];    struct virtq_used_elem ring[Q. size];</span><br><span class="line">  le16 used_event;                  le16 avail_event;</span><br><span class="line">&#125;;                                &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing 3: Event suppression struct notification</strong></p>
</blockquote>
<blockquote>
<p>This way, every time the driver wants to make available a buffer it needs to check the avail_event on the used ring: If driver‚Äôs idx field was equal to avail_event, it‚Äôs time to send a notification, ignoring the lower bit of used ring flags member (<code>VIRTQ_USED_F_NO_NOTIFY</code>).</p>
</blockquote>
<p>ËøôÊ†∑‰∏ÄÊù•ÔºåÊØèÊ¨°È©±Âä®Á®ãÂ∫èÊÉ≥Ë¶ÅÊèê‰æõ‰∏Ä‰∏™ÁºìÂÜ≤Âå∫Êó∂ÔºåÂÆÉÈúÄË¶ÅÊ£ÄÊü•Â∑≤Áî®ÁéØ‰∏äÁöÑavail_event„ÄÇÂ¶ÇÊûúÈ©±Âä®ÁöÑidxÂ≠óÊÆµÁ≠â‰∫éavail_eventÔºåÈÇ£‰πàÂ∞±ÊòØÂèëÈÄÅÈÄöÁü•ÁöÑÊó∂ÂÄô‰∫ÜÔºåÂøΩÁï•Â∑≤Áî®ÁéØÊ†áÂøóÊàêÂëòÁöÑ‰Ωé‰ΩçÔºà<code>VIRTQ_USED_F_NO_NOTIFY</code>Ôºâ„ÄÇ</p>
<blockquote>
<p>Similarly, if <code>VIRTIO_F_EVENT_IDX</code> has been negotiated, the device will check used_event to know if it needs to send a notification or not. This can be very effective for maintaining a virtqueue of buffers for the device to write, like in the virtio-net device receive queue.</p>
</blockquote>
<p>ÂêåÊ†∑ÔºåÂ¶ÇÊûú<code>VIRTIO_F_EVENT_IDX</code>Â∑≤ÁªèÂçèÂïÜÂ•Ω‰∫ÜÔºåËÆæÂ§áÂ∞ÜÊ£ÄÊü•used_event‰ª•Áü•ÈÅìÂÆÉÊòØÂê¶ÈúÄË¶ÅÂèëÈÄÅÈÄöÁü•„ÄÇËøôÂØπ‰∫éÁª¥Êä§‰∏Ä‰∏™‰æõËÆæÂ§áÂÜôÂÖ•ÁöÑÁºìÂÜ≤Âå∫ÁöÑËôöÊãüÈòüÂàóÈùûÂ∏∏ÊúâÊïàÔºåÂ∞±ÂÉèÂú®virtio-netËÆæÂ§áÊé•Êî∂ÈòüÂàó‰∏≠‰∏ÄÊ†∑„ÄÇ</p>
<blockquote>
<p>In our next post, we‚Äôre going to wrap up and take a look at a number of optimizations on top of both ring layouts which depend on the communication/device type or how each part is implemented.</p>
</blockquote>
<p>Âú®Êàë‰ª¨ÁöÑ‰∏ã‰∏ÄÁØáÊñáÁ´†‰∏≠ÔºåÊàë‰ª¨Â∞ÜÊÄªÁªìÂπ∂ÁúãÁúãÂú®Ëøô‰∏§‰∏™ÁéØÂΩ¢Â∏ÉÂ±Ä‰πã‰∏äÁöÑ‰∏Ä‰∫õ‰ºòÂåñÔºåËøô‰∫õ‰ºòÂåñÂèñÂÜ≥‰∫éÈÄö‰ø°/ËÆæÂ§áÁ±ªÂûãÊàñÊØè‰∏™ÈÉ®ÂàÜÁöÑÂÆûÁé∞ÊñπÂºè„ÄÇ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/" data-id="clefunqbh0000l2wb9oyqhw88" data-title="Virtqueues and virtio ring: How the data travels" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-virtio-devices-and-drivers-overview-the-headjack-and-the-phone" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/" class="article-date">
  <time class="dt-published" datetime="2023-02-22T14:12:09.000Z" itemprop="datePublished">2023-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>‚ñ∫<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/">Virtio devices and drivers overview: The headjack and the phone</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>This three-part series will take you through the main virtio data plane layouts: the split virtqueue and the packed virtqueue. This is the basis for the communication between hosts and virtual environments like guests or containers.</p>
</blockquote>
<p>Ëøô‰∏™Áî±‰∏âÈÉ®ÂàÜÁªÑÊàêÁöÑÁ≥ªÂàóÔºåÂ∞Ü‰ºöÂ∏¶‰Ω†‰∫ÜËß£virtioÊï∞ÊçÆÂπ≥Èù¢ÁöÑÂ∏ÉÂ±ÄÔºåsplit virtuqueue Âíå packed virtqueue„ÄÇËøôÊòØÁâ©ÁêÜÊú∫‰∏éËôöÊãüÁéØÂ¢ÉÊØîÂ¶ÇËôöÊãüÊú∫ÊàñÂÆπÂô®‰∫§ÊµÅÁöÑÂü∫Á°Ä„ÄÇ</p>
<blockquote>
<p>One of the challenges when coming to explain these approaches is the lack of documentation and the many terms involved. This set of posts attempts to demystify the virtio data plane and provide you with a clear down to earth explanation of what is what.</p>
</blockquote>
<p>Âú®Ëß£ÈáäËøô‰∫õÊñπÊ≥ïÊó∂ÔºåÈù¢‰∏¥ÁöÑÊåëÊàò‰πã‰∏ÄÊòØÁº∫‰πèÊñáÊ°£ÂíåÊ∂âÂèäÁöÑËÆ∏Â§öÊúØËØ≠„ÄÇËøôÁªÑÊñáÁ´†ËØïÂõæÊè≠ÂºÄvirtioÊï∞ÊçÆÂπ≥Èù¢ÁöÑÁ•ûÁßòÈù¢Á∫±ÔºåÂπ∂‰∏∫‰Ω†Êèê‰æõ‰∏Ä‰∏™Ê∏ÖÊô∞ÁöÑËß£ÈáäÔºåËØ¥Êòé‰ªÄ‰πàÊòØ‰ªÄ‰πà„ÄÇ</p>
<blockquote>
<p>This is a technical deep dive and is relevant for those who are interested in the bits and bytes of things. It details the communication format between the different virtio parts and data plane protocols.</p>
</blockquote>
<p>ËøôÊòØ‰∏Ä‰∏™ÊäÄÊúØ‰∏äÁöÑÊ∑±ÂÖ•Á†îÁ©∂Ôºå‰∏éÈÇ£‰∫õÂØπ‰∫ãÁâ©ÁöÑÊØîÁâπÂíåÂ≠óËäÇÊÑüÂÖ¥Ë∂£ÁöÑ‰∫∫ÊúâÂÖ≥„ÄÇÂÆÉËØ¶ÁªÜ‰ªãÁªç‰∫Ü‰∏çÂêåvirtioÈÉ®‰ª∂ÂíåÊï∞ÊçÆÂπ≥Èù¢ÂçèËÆÆ‰πãÈó¥ÁöÑÈÄö‰ø°Ê†ºÂºè„ÄÇ</p>
<blockquote>
<p>While further extensions, optimizations and features are being added to both virtqueue versions, to improve performance and to simplify implementation, the core of the virtqueue operations remains the same. This is because it has been designed with extensibility in mind. </p>
</blockquote>
<p>ËôΩÁÑ∂‰∏§‰∏™ÁâàÊú¨ÁöÑvirtqueueÈÉΩÂä†ÂÖ•‰∫ÜËøõ‰∏ÄÊ≠•ÁöÑÊâ©Â±ï„ÄÅ‰ºòÂåñÂíåÂäüËÉΩÔºå‰ª•ÊèêÈ´òÊÄßËÉΩÂíåÁÆÄÂåñÂÆûÁé∞Ôºå‰ΩÜvirtqueueÊìç‰ΩúÁöÑÊ†∏ÂøÉ‰ªçÁÑ∂‰øùÊåÅ‰∏çÂèò„ÄÇËøôÊòØÂõ†‰∏∫ÂÆÉÂú®ËÆæËÆ°Êó∂Â∞±ËÄÉËôëÂà∞‰∫ÜÂèØÊâ©Â±ïÊÄß„ÄÇ</p>
<blockquote>
<p>Packed virtqueue, which complements the split virtqueue has been merged in the virtio 1.1 spec, and successfully implemented in both emulated devices (qemu, virtio_net, dpdk) and physical devices.</p>
</blockquote>
<p>‰Ωú‰∏∫split virtqueueÁöÑË°•ÂÖÖÔºåpacked virtqueueÂ∑≤Ë¢´ÂêàÂπ∂Âà∞virtio 1.1ËßÑËåÉ‰∏≠ÔºåÂπ∂Âú®Ê®°ÊãüËÆæÂ§áÔºàqemu„ÄÅvirtio_net„ÄÅdpdkÔºâÂíåÁâ©ÁêÜËÆæÂ§á‰∏≠ÊàêÂäüÂÆûÁé∞„ÄÇ</p>
<blockquote>
<p>We‚Äôll start with an overview of the virtio device, drivers and their data plane interaction. Then we‚Äôll move on to explain the details of the split virtqueue ring layout. This is followed by an overview of the packed ring layout and the advantages it brings over the split virtqueue approach.</p>
</blockquote>
<p>Êàë‰ª¨Â∞ÜÈ¶ñÂÖàÊ¶ÇËø∞virtioËÆæÂ§á„ÄÅÈ©±Âä®Á®ãÂ∫èÂíåÂÆÉ‰ª¨ÁöÑÊï∞ÊçÆÂπ≥Èù¢‰∫íÂä®„ÄÇÁÑ∂ÂêéÔºåÊàë‰ª¨Â∞ÜÁªßÁª≠Ëß£Èáäsplit virtqueue ring layoutÁöÑÁªÜËäÇ„ÄÇÈöèÂêéÔºåÊàë‰ª¨Â∞ÜÊ¶ÇËø∞packed ring layout‰ª•ÂèäÂÆÉÊØîsplit virtqueueÊñπÊ≥ïÂ∏¶Êù•ÁöÑ‰ºòÂäø„ÄÇ</p>
<h2 id="Virtio-devices-and-drivers-overview-who-is-who"><a href="#Virtio-devices-and-drivers-overview-who-is-who" class="headerlink" title="Virtio devices and drivers overview: who is who"></a>Virtio devices and drivers overview: who is who</h2><blockquote>
<p>This section provides a brief overview of the virtio devices, virtio drivers, examples of the different architectures you can use and the different components. If you‚Äôre already familiar with these topics or you have already followed the virtio networking series you can jump directly to the next section focusing on the virtio rings.</p>
</blockquote>
<p>Êú¨ËäÇÁÆÄË¶Å‰ªãÁªç‰∫ÜvirtioËÆæÂ§á„ÄÅvirtioÈ©±Âä®„ÄÅ‰Ω†ÂèØ‰ª•‰ΩøÁî®ÁöÑ‰∏çÂêåÊû∂ÊûÑÁöÑ‰æãÂ≠ê‰ª•Âèä‰∏çÂêåÁöÑÁªÑ‰ª∂„ÄÇÂ¶ÇÊûú‰Ω†Â∑≤ÁªèÁÜüÊÇâ‰∫ÜËøô‰∫õ‰∏ªÈ¢òÔºåÊàñËÄÖ‰Ω†Â∑≤ÁªèÂÖ≥Ê≥®‰∫ÜvirtioÁΩëÁªúÁ≥ªÂàóÔºå‰Ω†ÂèØ‰ª•Áõ¥Êé•Ë∑≥Âà∞‰∏ã‰∏ÄËäÇÔºåÈáçÁÇπ‰ªãÁªçvirtio rings„ÄÇ</p>
<h3 id="Virtio-devices-In-and-out-the-virtual-world"><a href="#Virtio-devices-In-and-out-the-virtual-world" class="headerlink" title="Virtio devices: In and out the virtual world"></a>Virtio devices: In and out the virtual world</h3><blockquote>
<p>A virtio device is a device that exposes a virtio interface for the software to manage and exchange information. It can be exposed to the emulated environment using PCI, Memory Mapping I/O (Just to expose the device in a region of memory) and S/390 Channel I/O. Part of the communication needs to be delegated to theses, like device discovery.</p>
</blockquote>
<p>VirtioËÆæÂ§áÊòØ‰∏Ä‰∏™Êö¥Èú≤Âá∫virtioÊé•Âè£ÁöÑËÆæÂ§áÔºå‰æõËΩØ‰ª∂ÁÆ°ÁêÜÂíå‰∫§Êç¢‰ø°ÊÅØ„ÄÇÂÆÉÂèØ‰ª•‰ΩøÁî®PCI„ÄÅÂÜÖÂ≠òÊò†Â∞ÑI/OÔºàÂè™ÊòØÂú®ÂÜÖÂ≠òÁöÑ‰∏Ä‰∏™Âå∫ÂüüÊö¥Èú≤ËÆæÂ§áÔºâÂíåS/390ÈÄöÈÅìI/OÊö¥Èú≤Âú®‰ªøÁúüÁéØÂ¢É‰∏≠„ÄÇÈÉ®ÂàÜÈÄö‰ø°ÈúÄË¶ÅÂßîÊâòÁªôËøô‰∫õËÆæÂ§áÔºåÂ¶ÇËÆæÂ§áÂèëÁé∞„ÄÇ</p>
<blockquote>
<p>Its main task is to convert the signal from the format they have outside of the virtual environment (the VM, the container, etc) to the format they need to be exchanged through the virtio dataplane and vice-versa. This signal could be real (for example the electricity or the light from a NIC) or already virtual (like the representation the host has from a network packet).</p>
</blockquote>
<p>ÂÆÉÁöÑ‰∏ªË¶Å‰ªªÂä°ÊòØÂ∞Ü‰ø°Âè∑‰ªéÂÆÉ‰ª¨Âú®ËôöÊãüÁéØÂ¢ÉÔºàËôöÊãüÊú∫„ÄÅÂÆπÂô®Á≠âÔºâ‰πãÂ§ñÁöÑÊ†ºÂºèËΩ¨Êç¢ÊàêÂÆÉ‰ª¨ÈúÄË¶ÅÈÄöËøávirtioÊï∞ÊçÆÁ∫ø‰∫§Êç¢ÁöÑÊ†ºÂºèÔºåÂèç‰πã‰∫¶ÁÑ∂„ÄÇËøô‰∏™‰ø°Âè∑ÂèØ‰ª•ÊòØÁúüÂÆûÁöÑÔºà‰æãÂ¶ÇÊù•Ëá™ÁΩëÂç°ÁöÑÁîµÊàñÂÖâÔºâÔºåÊàñËÄÖÂ∑≤ÁªèÊòØËôöÊãüÁöÑÔºàÂ¶Ç‰∏ªÊú∫‰ªéÁΩëÁªúÂåÖ‰∏≠ÂæóÂà∞ÁöÑË°®Á§∫Ôºâ„ÄÇ</p>
<blockquote>
<p>The virtio interface consist of the following mandatory parts (<a target="_blank" rel="noopener" href="https://docs.oasis-open.org/virtio/virtio/v1.1/cs01/virtio-v1.1-cs01.html#x1-90002">virtio1.1 spec</a>): </p>
<ul>
<li>Device status field</li>
<li>Feature bits</li>
<li>Notifications</li>
<li>One or more virtqueues</li>
</ul>
<p>Now we‚Äôll provide additional details to each of these parts and how the device and driver starts communicating using these.</p>
</blockquote>
<p>virtioÊé•Âè£Áî±‰ª•‰∏ãÂº∫Âà∂ÊÄßÈÉ®ÂàÜÁªÑÊàêÔºàvirtio1.1ËßÑËåÉÔºâ:</p>
<ul>
<li>ËÆæÂ§áÁä∂ÊÄÅÂ≠óÊÆµ</li>
<li>ÁâπÂæÅ‰Ωç</li>
<li>ÈÄöÁü•</li>
<li>‰∏Ä‰∏™ÊàñÂ§ö‰∏™ËôöÊãüÈòüÂàó</li>
</ul>
<p>Áé∞Âú®Êàë‰ª¨Â∞ÜÊèê‰æõËøô‰∫õÈÉ®ÂàÜÁöÑÈ¢ùÂ§ñÁªÜËäÇÔºå‰ª•ÂèäËÆæÂ§áÂíåÈ©±Âä®Â¶Ç‰Ωï‰ΩøÁî®Ëøô‰∫õÈÉ®ÂàÜÂºÄÂßãÈÄö‰ø°„ÄÇ</p>
<h3 id="Device-status-field-Is-everything-ok"><a href="#Device-status-field-Is-everything-ok" class="headerlink" title="Device status field: Is everything ok?"></a>Device status field: Is everything ok?</h3><blockquote>
<p>The device status field is a sequence of bits the device and the driver use to perform their initialization. We can imagine it as traffic lights on a console, each part set and clear each bit indicating their status.</p>
</blockquote>
<p>ËÆæÂ§áÁä∂ÊÄÅÂ≠óÊÆµÊòØËÆæÂ§áÂíåÈ©±Âä®Á®ãÂ∫èÁî®Êù•ÊâßË°åÂÖ∂ÂàùÂßãÂåñÁöÑ‰∏Ä‰∏™ÊØîÁâπÂ∫èÂàó„ÄÇÊàë‰ª¨ÂèØ‰ª•ÊääÂÆÉÊÉ≥Ë±°ÊàêÊéßÂà∂Âè∞‰∏äÁöÑ‰∫§ÈÄöÁÅØÔºåÊØè‰∏™ÈÉ®ÂàÜËÆæÁΩÆÂíåÊ∏ÖÈô§ÊØè‰∏™‰ΩçÔºåË°®Á§∫ÂÆÉ‰ª¨ÁöÑÁä∂ÊÄÅ„ÄÇ</p>
<blockquote>
<p>The guest or the driver set the bit <code>ACKNOWLEDGE</code> (0x1) in the device status field to indicate that it acknowledges the device, and the bit <code>DRIVER</code> (0x2) to indicate an initialization in progress. After that, it starts a feature negotiation using the feature bits (more on this later), and sets bit <code>DRIVER_OK</code> (0x4) and <code>FEATURES_OK</code> (0x8) to acknowledge the features, so communication can start. If the device wants to indicate a fatal failure, it can set bit <code>DEVICE_NEEDS_RESET</code> (0x40), and the driver can do the same with bit <code>FAILED</code> (0x80).</p>
</blockquote>
<p>ËÆøÂÆ¢ÊàñÈ©±Âä®Á®ãÂ∫èÂú®ËÆæÂ§áÁä∂ÊÄÅÂ≠óÊÆµ‰∏≠ËÆæÁΩÆ‰Ωç<code>ACKNOWLEDGE</code>Ôºà0x1Ôºâ‰ª•Ë°®Á§∫ÂÆÉÁ°ÆËÆ§‰∫ÜËÆæÂ§áÔºåÂπ∂ËÆæÁΩÆ‰Ωç<code>DRIVER</code>Ôºà0x2Ôºâ‰ª•Ë°®Á§∫ÂàùÂßãÂåñÊ≠£Âú®ËøõË°å„ÄÇ‰πãÂêéÔºåÂÆÉÂºÄÂßã‰ΩøÁî®ÂäüËÉΩ‰ΩçËøõË°åÂäüËÉΩÂçèÂïÜÔºàÂêéÈù¢‰ºöËØ¶ÁªÜ‰ªãÁªçÔºâÔºåÂπ∂ËÆæÁΩÆ‰Ωç<code>DRIVER_OK</code>Ôºà0x4ÔºâÂíå<code>FEATURES_OK</code>Ôºà0x8ÔºâÊù•Á°ÆËÆ§ÂäüËÉΩÔºåËøôÊ†∑Â∞±ÂèØ‰ª•ÂºÄÂßãÈÄö‰ø°‰∫Ü„ÄÇÂ¶ÇÊûúËÆæÂ§áÊÉ≥ÊåáÁ§∫‰∏Ä‰∏™Ëá¥ÂëΩÁöÑÊïÖÈöúÔºåÂÆÉÂèØ‰ª•ËÆæÁΩÆ‰Ωç<code>DEVICE_NEEDS_RESET</code> (0x40)ÔºåËÄåÈ©±Âä®Á®ãÂ∫èÂèØ‰ª•Áî®‰Ωç<code>FAILED</code> (0x80)ÂÅöÂêåÊ†∑ÁöÑ‰∫ãÊÉÖ„ÄÇ</p>
<blockquote>
<p>The device communicates the location of these bits using transport specific methods, like PCI scanning or knowing the address for MMIO.</p>
</blockquote>
<p>ËÆæÂ§á‰ΩøÁî®‰º†ËæìÁöÑÁâπÂÆöÊñπÊ≥ïÊù•‰º†ËææËøô‰∫õ‰ΩçÁöÑ‰ΩçÁΩÆÔºåÂ¶ÇPCIÊâ´ÊèèÊàñÁü•ÈÅìMMIOÁöÑÂú∞ÂùÄ„ÄÇ</p>
<h3 id="Feature-bits-Setting-the-communication-agreement-points"><a href="#Feature-bits-Setting-the-communication-agreement-points" class="headerlink" title="Feature bits: Setting the communication agreement points"></a>Feature bits: Setting the communication agreement points</h3><blockquote>
<p>Device‚Äôs feature bits are used to communicate what features it supports, and to agree with the drivers about what of them will be used. These can be device-generic or device-specific. As an example of the first case, a bit can acknowledge if the device supports SR-IOV or what memory mode can be used. An example of the second case can be the different offloads it can perform, like checksumming or scatter-gather If the device is a network interface.</p>
</blockquote>
<p>ËÆæÂ§áÁöÑÂäüËÉΩ‰ΩçÁî®‰∫é‰∫§ÊµÅÂÆÉÊîØÊåÅÂì™‰∫õÂäüËÉΩÔºåÂπ∂‰∏éÈ©±Âä®Á®ãÂ∫èÂïÜÂÆöÂ∞Ü‰ΩøÁî®ÂÖ∂‰∏≠Âì™‰∫õÂäüËÉΩ„ÄÇËøô‰∫õ‰ΩçÂèØ‰ª•ÊòØËÆæÂ§áÈÄöÁî®ÁöÑÔºå‰πüÂèØ‰ª•ÊòØËÆæÂ§áÁâπÂÆöÁöÑ„ÄÇ‰Ωú‰∏∫Á¨¨‰∏ÄÁßçÊÉÖÂÜµÁöÑ‰∏Ä‰∏™‰æãÂ≠êÔºå‰∏Ä‰∏™ÊØîÁâπÂèØ‰ª•Á°ÆËÆ§ËÆæÂ§áÊòØÂê¶ÊîØÊåÅSR-IOVÊàñËÄÖÂèØ‰ª•‰ΩøÁî®‰ªÄ‰πàÂÜÖÂ≠òÊ®°Âºè„ÄÇÁ¨¨‰∫åÁßçÊÉÖÂÜµÁöÑ‰∏Ä‰∏™‰æãÂ≠êÊòØÔºåÂ¶ÇÊûúËÆæÂ§áÊòØ‰∏Ä‰∏™ÁΩëÁªúÊé•Âè£ÔºåÂÆÉÂèØ‰ª•ÊâßË°å‰∏çÂêåÁöÑÂç∏ËΩΩÔºåÂ¶ÇÊ†°È™åÂíåÊàñÊï£ÁÇπÊî∂ÈõÜ„ÄÇ</p>
<blockquote>
<p>After the device initialization exposed in the previous section, the former reads the feature bits the device offers, and sends back the subset that it can handle. If they agree on them, the driver will allocate and inform about the virtqueues to the device, and all other configuration needed.</p>
</blockquote>
<p>Âú®‰∏ä‰∏ÄËäÇÊö¥Èú≤ÁöÑËÆæÂ§áÂàùÂßãÂåñ‰πãÂêéÔºåÂâçËÄÖ‰ºöËØªÂèñËÆæÂ§áÊèê‰æõÁöÑÂäüËÉΩ‰ΩçÔºåÂπ∂ÂèëÂõûÂÆÉËÉΩÂ§ÑÁêÜÁöÑÂ≠êÈõÜ„ÄÇÂ¶ÇÊûú‰ªñ‰ª¨ËææÊàê‰∏ÄËá¥ÔºåÈ©±Âä®Á®ãÂ∫èÂ∞ÜÂàÜÈÖçÂíåÈÄöÁü•ËÆæÂ§áÁöÑËôöÊãüÈòüÂàóÔºå‰ª•ÂèäÊâÄÊúâÂÖ∂‰ªñÈúÄË¶ÅÁöÑÈÖçÁΩÆ„ÄÇ</p>
<h3 id="Notifications-You-have-work-to-do"><a href="#Notifications-You-have-work-to-do" class="headerlink" title="Notifications: You have work to do"></a>Notifications: You have work to do</h3><blockquote>
<p>Devices and drivers must notify that they have information to communicate using a notification. While the semantic of these is specified in the standard, the implementation of these are transport specific, like a PCI interruption or to write to a specific memory location. The device and the driver needs to expose at least one notification method. We will expand on this later in future sections.</p>
</blockquote>
<p>ËÆæÂ§áÂíåÈ©±Âä®Á®ãÂ∫èÂøÖÈ°ªÈÄöÁü•‰ªñ‰ª¨Êúâ‰ΩøÁî®ÈÄöÁü•ÁöÑ‰ø°ÊÅØËøõË°åÈÄö‰ø°„ÄÇËôΩÁÑ∂Ëøô‰∫õÁöÑËØ≠‰πâÊòØÂú®Ê†áÂáÜ‰∏≠ËßÑÂÆöÁöÑÔºå‰ΩÜËøô‰∫õÁöÑÂÆûÁé∞ÊòØÁâπÂÆö‰∫é‰º†ËæìÁöÑÔºåÊØîÂ¶ÇPCI‰∏≠Êñ≠ÊàñÂÜôÂà∞‰∏Ä‰∏™ÁâπÂÆöÁöÑÂÜÖÂ≠ò‰ΩçÁΩÆ„ÄÇËÆæÂ§áÂíåÈ©±Âä®Á®ãÂ∫èÈúÄË¶ÅÂÖ¨ÂºÄËá≥Â∞ë‰∏Ä‰∏™ÈÄöÁü•ÊñπÊ≥ï„ÄÇÊàë‰ª¨Â∞ÜÂú®‰ª•ÂêéÁöÑÁ´†ËäÇ‰∏≠ÂØπÊ≠§ËøõË°åÈòêËø∞„ÄÇ</p>
<h3 id="One-or-more-virtqueues-The-communication-vehicles"><a href="#One-or-more-virtqueues-The-communication-vehicles" class="headerlink" title="One or more virtqueues: The communication vehicles"></a>One or more virtqueues: The communication vehicles</h3><blockquote>
<p>A virtqueue is just a queue of guest‚Äôs buffers that the host consumes, either reading them or writing to them, and returns to the guest. The current memory layout of a virtqueue implementation is a circular ring, so it is often called the virtring or vring.</p>
<p>They will be the main topic of the next section, Virtqueues and virtio ring, so at this moment is enough with that definition.</p>
</blockquote>
<p>virtqueueÂè™ÊòØ‰∏Ä‰∏™guestÁºìÂÜ≤Âå∫ÁöÑÈòüÂàóÔºå‰∏ªÊú∫Ê∂àËÄóËøô‰∫õÁºìÂÜ≤Âå∫ÔºåË¶Å‰πàËØªÂèñÂÆÉ‰ª¨ÔºåË¶Å‰πàÂÜôÂÖ•ÂÆÉ‰ª¨ÔºåÁÑ∂ÂêéËøîÂõûÁªôÂÆ¢‰Ωì„ÄÇÁõÆÂâçvirtqueueÂÆûÁé∞ÁöÑÂÜÖÂ≠òÂ∏ÉÂ±ÄÊòØ‰∏Ä‰∏™ÂúÜÂΩ¢ÁöÑÁéØÔºåÊâÄ‰ª•ÂÆÉÈÄöÂ∏∏Ë¢´Áß∞‰∏∫virtringÊàñvring„ÄÇ</p>
<p>ÂÆÉ‰ª¨Â∞ÜÊòØ‰∏ã‰∏ÄËäÇÁöÑ‰∏ªË¶ÅËØùÈ¢òÔºåÂç≥virtqueuesÂíåvirtio ringÔºåÊâÄ‰ª•Ê≠§ÂàªÊúâ‰∫ÜËøô‰∏™ÂÆö‰πâÂ∞±Ë∂≥Â§ü‰∫Ü„ÄÇ</p>
<h2 id="Virtio-drivers-The-software-avatar"><a href="#Virtio-drivers-The-software-avatar" class="headerlink" title="Virtio drivers: The software avatar"></a>Virtio drivers: The software avatar</h2><blockquote>
<p>The virtio driver is the software part in the virtual environment that talks with the virtio device using the relevant parts of the virtio spec.</p>
<p>Generally speaking, its virtio control plane tasks are:</p>
<ul>
<li>Look for the device</li>
<li>To allocate shared memory in the guest for the communication</li>
</ul>
<p>Start it using the protocol in Virtio devices.</p>
</blockquote>
<p>virtioÈ©±Âä®ÊòØËôöÊãüÁéØÂ¢É‰∏≠ÁöÑËΩØ‰ª∂ÈÉ®ÂàÜÔºåÂÆÉ‰ΩøÁî®virtioËßÑËåÉÁöÑÁõ∏ÂÖ≥ÈÉ®ÂàÜ‰∏évirtioËÆæÂ§áÂØπËØù„ÄÇ</p>
<p>‰∏ÄËà¨Êù•ËØ¥ÔºåÂÖ∂virtioÊéßÂà∂Èù¢ÁöÑ‰ªªÂä°ÊòØ„ÄÇ</p>
<ul>
<li>ÂØªÊâæËÆæÂ§á</li>
<li>Âú®ÂÆ¢Êà∑‰∏≠‰∏∫ÈÄö‰ø°ÂàÜÈÖçÂÖ±‰∫´ÂÜÖÂ≠ò</li>
</ul>
<p>‰ΩøÁî®virtioËÆæÂ§á‰∏≠ÁöÑÂçèËÆÆÂêØÂä®ÂÆÉ„ÄÇ</p>
<h3 id="Devices-and-drivers-interaction-The-scenarios"><a href="#Devices-and-drivers-interaction-The-scenarios" class="headerlink" title="Devices and drivers interaction: The scenarios"></a>Devices and drivers interaction: The scenarios</h3><blockquote>
<p>In this section we are going to locate each virtio networking element (device, driver, and how the communication works) in three different architectures, to provide both a common frame to start explaining the virtio data plane and to show how adaptive it is. We have already presented these elements in past posts, so you can skip this section if you are a virtio-net series reader. On the other hand, if you have not read them, you can use them as a reference to understand this part better.</p>
</blockquote>
<p>Âú®Ëøô‰∏ÄËäÇ‰∏≠ÔºåÊàë‰ª¨Â∞ÜÊääÊØè‰∏™virtioÁΩëÁªúÂÖÉÁ¥†ÔºàËÆæÂ§á„ÄÅÈ©±Âä®ÂíåÈÄö‰ø°Â¶Ç‰ΩïÂ∑•‰ΩúÔºâÊîæÂú®‰∏â‰∏™‰∏çÂêåÁöÑÊû∂ÊûÑ‰∏≠Ôºå‰ª•Êèê‰æõ‰∏Ä‰∏™ÂÖ±ÂêåÁöÑÊ°ÜÊû∂Êù•ÂºÄÂßãËß£ÈáävirtioÊï∞ÊçÆÂπ≥Èù¢ÔºåÂπ∂Â±ïÁ§∫ÂÆÉÁöÑÈÄÇÂ∫îÊÄß„ÄÇÊàë‰ª¨Â∑≤ÁªèÂú®ËøáÂéªÁöÑÊñáÁ´†‰∏≠‰ªãÁªç‰∫ÜËøô‰∫õÂÖÉÁ¥†ÔºåÊâÄ‰ª•Â¶ÇÊûú‰Ω†ÊòØvirtio-netÁ≥ªÂàóÁöÑËØªËÄÖÔºå‰Ω†ÂèØ‰ª•Ë∑≥ËøáËøô‰∏ÄÈÉ®ÂàÜ„ÄÇÂè¶‰∏ÄÊñπÈù¢ÔºåÂ¶ÇÊûú‰Ω†Ê≤°ÊúâËØªËøáËøô‰∫õÊñáÁ´†Ôºå‰Ω†ÂèØ‰ª•ÊääÂÆÉ‰ª¨‰Ωú‰∏∫ÂèÇËÄÉÊù•Êõ¥Â•ΩÂú∞ÁêÜËß£Ëøô‰∏ÄÈÉ®ÂàÜ„ÄÇ</p>
<blockquote>
<p>In Introduction to virtio-networking and vhost-net we showed the environment in which qemu created an emulated net device and offered it to the guest‚Äôs virtio-net driver. In this environment, the driver notifications are routed from whatever method is exposed to guests (usually, PCI) to KVM interruptions that stop the guest‚Äôs processor and return the control to the host (vmexit). Similarly, the device notifications are a special ioctl the host can send to the KVM device (vCPU IRQ). QEMU can access virtqueue information using the shared memory.</p>
</blockquote>
<p>Âú®‰ªãÁªçvirtio-networkingÂíåvhost-netÊó∂ÔºåÊàë‰ª¨Â±ïÁ§∫‰∫ÜqemuÂàõÂª∫‰∏Ä‰∏™Ê®°ÊãüÁöÑnetËÆæÂ§áÂπ∂Â∞ÜÂÖ∂Êèê‰æõÁªôÂÆ¢Êà∑ÁöÑvirtio-netÈ©±Âä®Á®ãÂ∫èÁöÑÁéØÂ¢É„ÄÇÂú®Ëøô‰∏™ÁéØÂ¢É‰∏≠ÔºåÈ©±Âä®Á®ãÂ∫èÁöÑÈÄöÁü•‰ªé‰ªª‰ΩïÊö¥Èú≤ÁªôÂÆ¢‰ΩìÁöÑÊñπÊ≥ïÔºàÈÄöÂ∏∏ÊòØPCIÔºâË¢´Ë∑ØÁî±Âà∞KVM‰∏≠Êñ≠ÔºåÂÅúÊ≠¢ÂÆ¢‰ΩìÁöÑÂ§ÑÁêÜÂô®Âπ∂Â∞ÜÊéßÂà∂ÊùÉËøîÂõûÁªô‰∏ªÊú∫ÔºàvmexitÔºâ„ÄÇÂêåÊ†∑Âú∞ÔºåËÆæÂ§áÈÄöÁü•ÊòØ‰∏ªÊú∫ÂèØ‰ª•ÂêëKVMËÆæÂ§áÂèëÈÄÅÁöÑÁâπÊÆäioctlÔºàvCPU IRQÔºâ„ÄÇQEMUÂèØ‰ª•‰ΩøÁî®ÂÖ±‰∫´ÂÜÖÂ≠òËÆøÈóÆvirtqueue‰ø°ÊÅØ„ÄÇ</p>
<blockquote>
<p>Please note the implications of the virtio rings shared memory concept: The memory the driver and the device access is the same page in RAM, they are not two different regions that follow a protocol to synchronize.</p>
</blockquote>
<p>ËØ∑Ê≥®ÊÑèvirtioÁéØÁöÑÂÖ±‰∫´ÂÜÖÂ≠òÊ¶ÇÂøµÁöÑÂê´‰πâ„ÄÇÈ©±Âä®Á®ãÂ∫èÂíåËÆæÂ§áËÆøÈóÆÁöÑÂÜÖÂ≠òÊòØRAM‰∏≠ÁöÑÂêå‰∏Ä‰∏™È°µÈù¢ÔºåÂÆÉ‰ª¨‰∏çÊòØ‰∏§‰∏™‰∏çÂêåÁöÑÂå∫ÂüüÔºåÂÆÉ‰ª¨ÈÅµÂæ™‰∏Ä‰∏™ÂçèËÆÆÊù•ËøõË°åÂêåÊ≠•„ÄÇ</p>


<p><em>Figure 1: Qemu emulated device component diagram</em></p>
<blockquote>
<p>Since the notification now needs to travel from the guest (KVM), to QEMU, and then to the kernel for the latter to forward the network frame, we can spawn a thread in the kernel with access to the guest‚Äôs shared memory mapping and then let it handle the virtio dataplane.</p>
</blockquote>
<p>Áî±‰∫éÈÄöÁü•Áé∞Âú®ÈúÄË¶Å‰ªéguestÔºàKVMÔºâÂà∞QEMUÔºåÂÜçÂà∞ÂÜÖÊ†∏Ôºå‰ª•‰æøÂêéËÄÖËΩ¨ÂèëÁΩëÁªúÂ∏ßÔºåÊàë‰ª¨ÂèØ‰ª•Âú®ÂÜÖÊ†∏‰∏≠ÁîüÊàê‰∏Ä‰∏™Á∫øÁ®ãÔºåËÆøÈóÆÂÆ¢‰ΩìÁöÑÂÖ±‰∫´ÂÜÖÂ≠òÊò†Â∞ÑÔºåÁÑ∂ÂêéËÆ©ÂÆÉÂ§ÑÁêÜvirtioÊï∞ÊçÆÂπ≥Èù¢„ÄÇ</p>
<blockquote>
<p>In that context, QEMU initiates the device using the virtio dataplane, and then forwards the virtio device status to vhost-net, delegating the data plane to it. In this scenario, KVM will use an event file descriptor (eventfd) to communicate the device interruptions, and expose another one to receive CPU interruptions. The guest does not need to be aware of this change, it will operate as the previous scenario.</p>
</blockquote>
<p>Âú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåQEMU‰ΩøÁî®virtioÊï∞ÊçÆÂπ≥Èù¢ÂêØÂä®ËÆæÂ§áÔºåÁÑ∂ÂêéÂ∞ÜvirtioËÆæÂ§áÁä∂ÊÄÅËΩ¨ÂèëÁªôvhost-netÔºåÂ∞ÜÊï∞ÊçÆÂπ≥Èù¢ÂßîÊâòÁªôÂÆÉ„ÄÇÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåKVMÂ∞Ü‰ΩøÁî®‰∏Ä‰∏™‰∫ã‰ª∂Êñá‰ª∂ÊèèËø∞Á¨¶ÔºàeventfdÔºâÊù•‰º†ËææËÆæÂ§á‰∏≠Êñ≠ÔºåÂπ∂ÂÖ¨ÂºÄÂè¶‰∏Ä‰∏™Êñá‰ª∂ÊèèËø∞Á¨¶Êù•Êé•Êî∂CPU‰∏≠Êñ≠„ÄÇguest‰∏çÈúÄË¶ÅÊÑèËØÜÂà∞ËøôÁßçÂèòÂåñÔºåÂÆÉÂ∞ÜÂÉè‰πãÂâçÁöÑÊñπÊ°à‰∏ÄÊ†∑Êìç‰Ωú„ÄÇ</p>
<blockquote>
<p>Also, in order to increase the performance, we created an in-kernel virtio-net device (called vhost-net) to offload the data plane directly to the kernel, where packet forwarding takes place:</p>
</blockquote>
<p>Âè¶Â§ñÔºå‰∏∫‰∫ÜÊèêÈ´òÊÄßËÉΩÔºåÊàë‰ª¨ÂàõÂª∫‰∫Ü‰∏Ä‰∏™ÂÜÖÊ†∏ÂÜÖÁöÑvirtio-netËÆæÂ§áÔºàÁß∞‰∏∫vhost-netÔºâÔºåÂ∞ÜÊï∞ÊçÆÂπ≥Èù¢Áõ¥Êé•Âç∏ËΩΩÂà∞ÂÜÖÊ†∏ÔºåÂú®ÈÇ£ÈáåËøõË°åÊï∞ÊçÆÂåÖËΩ¨Âèë„ÄÇ</p>
<img src="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/2020-06-18-virtio-fig2.png" class="">

<p><em>Figure 2: Virtio-net components diagram</em></p>
<blockquote>
<p>Later on, we moved the virtio device from the kernel to an userspace process in the host (covered in the post ‚ÄúA journey to the vhost-users realm‚Äù) that can run a packet forwarding framework like DPDK. The protocol to set all this up is called virtio-user.</p>
</blockquote>
<p>ÂêéÊù•ÔºåÊàë‰ª¨ÊäävirtioËÆæÂ§á‰ªéÂÜÖÊ†∏ÁßªÂà∞‰∫Ü‰∏ªÊú∫ÁöÑÁî®Êà∑Á©∫Èó¥ËøõÁ®ã‰∏≠ÔºàÂú® ‚ÄúÈÄöÂæÄvhost-usersÈ¢ÜÂüüÁöÑÊóÖÁ®ã ‚Äú‰∏ÄÊñá‰∏≠ÊúâÊâÄÊ∂âÂèäÔºâÔºåËØ•ËøõÁ®ãÂèØ‰ª•ËøêË°åÂÉèDPDKËøôÊ†∑ÁöÑÂåÖËΩ¨ÂèëÊ°ÜÊû∂„ÄÇËÆæÁΩÆËøô‰∏ÄÂàáÁöÑÂçèËÆÆË¢´Áß∞‰∏∫virtio-user„ÄÇ</p>
<img src="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/2020-06-18-virtio-fig3.png" class="">

<p><em>Figure 3: Virtio-user components diagram</em></p>
<blockquote>
<p>It even allows guests to run virtio drivers in guest‚Äôs userland, instead of the kernel! In this case, virtio names driver the process that is managing the memory and the virtqueues, not the kernel code that runs in the guest.</p>
</blockquote>
<p>ÂÆÉÁîöËá≥ÂÖÅËÆ∏ÂÆ¢Êà∑Âú®ÂÆ¢Êà∑ÁöÑÁî®Êà∑Âå∫ËøêË°åvirtioÈ©±Âä®ÔºåËÄå‰∏çÊòØÂú®ÂÜÖÊ†∏‰∏≠ËøêË°å Âú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåvirtioÂ∞ÜÈ©±Âä®Á®ãÂ∫èÂëΩÂêç‰∏∫ÁÆ°ÁêÜÂÜÖÂ≠òÂíåvirtqueuesÁöÑËøõÁ®ãÔºåËÄå‰∏çÊòØÂú®guest‰∏≠ËøêË°åÁöÑÂÜÖÊ†∏‰ª£Á†Å</p>
<img src="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/2020-06-18-virtio-fig4.png" class="">

<p><em>Figure 4: Virtio-user with userland driver in guest</em></p>
<blockquote>
<p>Lastly, we can directly do a virtio device passthrough with the proper hardware. If the NIC supports the virtio data plane, we can expose it directly to the guest with proper hardware (IOMMU device, able to translate between the guest‚Äôs and device‚Äôs memory addresses) and software (for example, VFIO linux driver, that enables the host to directly give the control of a PCI device to the guest). The device uses the typical hardware signals for notifications infrastructure, like PCI and CPU interruptions (IRQ).</p>
</blockquote>
<p>ÊúÄÂêéÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøáÈÄÇÂΩìÁöÑÁ°¨‰ª∂Áõ¥Êé•ËøõË°åvirtioËÆæÂ§áÈÄè‰º†„ÄÇÂ¶ÇÊûúÁΩëÂç°ÊîØÊåÅvirtioÊï∞ÊçÆÂπ≥Èù¢ÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøáÈÄÇÂΩìÁöÑÁ°¨‰ª∂ÔºàIOMMUËÆæÂ§áÔºåËÉΩÂ§üÂú®guestÂíåËÆæÂ§áÁöÑÂÜÖÂ≠òÂú∞ÂùÄ‰πãÈó¥ËøõË°åËΩ¨Êç¢ÔºâÂíåËΩØ‰ª∂Ôºà‰æãÂ¶ÇÔºåVFIO linuxÈ©±Âä®Ôºå‰Ωø‰∏ªÊú∫ËÉΩÂ§üÁõ¥Êé•Â∞ÜPCIËÆæÂ§áÁöÑÊéßÂà∂ÊùÉ‰∫§ÁªôguestÔºâÂ∞ÜÂÖ∂Áõ¥Êé•Êö¥Èú≤Áªôguest„ÄÇËØ•ËÆæÂ§á‰ΩøÁî®ÂÖ∏ÂûãÁöÑÁ°¨‰ª∂‰ø°Âè∑Êù•ÈÄöÁü•Âü∫Á°ÄËÆæÊñΩÔºåÂ¶ÇPCIÂíåCPU‰∏≠Êñ≠ÔºàIRQÔºâ„ÄÇ</p>
<blockquote>
<p>If a hardware NIC wants to go this way, the easiest approach is to build its driver on top of <a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/achieving-network-wirespeed-open-standard-manner-introducing-vdpa">vDPA</a>, also explained in earlier posts of this series.</p>
</blockquote>
<p>Â¶ÇÊûúÁ°¨‰ª∂ÁΩëÂç°ÊÉ≥Ëµ∞ËøôÊù°Ë∑ØÔºåÊúÄÁÆÄÂçïÁöÑÊñπÊ≥ïÊòØÂú®vDPAÁöÑÂü∫Á°Ä‰∏äÊûÑÂª∫ÂÆÉÁöÑÈ©±Âä®Á®ãÂ∫èÔºåÂú®Êú¨Á≥ªÂàóÁöÑÊó©ÊúüÊñáÁ´†‰∏≠‰πüÊúâËß£Èáä.</p>
<img src="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/2020-06-18-virtio-fig5.png" class="">

<p><em>Figure 5: Virtio hardware passthrough components diagram</em></p>
<blockquote>
<p>We will explain what happens inside of the dataplane communication in the rest of the posts.</p>
</blockquote>
<p>Êàë‰ª¨Â∞ÜÂú®Êé•‰∏ãÊù•ÁöÑÊñáÁ´†‰∏≠Ëß£ÈáäÊï∞ÊçÆÂπ≥Èù¢ÈÄö‰ø°ÂÜÖÈÉ®ÂèëÁîü‰∫Ü‰ªÄ‰πà„ÄÇ</p>
<blockquote>
<p>Thanks to the deep investment in standardization, the virtio data plane is the same in whatever way we use across these scenarios, and whatever transport protocol we use. The format of the exchanged messages are the same, and different devices or drivers can negotiate different capabilities or features based on its characteristics using the feature bits, previously mentioned. This way, the virtqueues only act as a common thin layer of device-driver communication that allows to reduce the investment of development and deployment.</p>
</blockquote>
<p>Áî±‰∫éÂØπÊ†áÂáÜÂåñÁöÑÊ∑±ÂÖ•ÊäïËµÑÔºåvirtioÊï∞ÊçÆÂπ≥Èù¢Âú®Ëøô‰∫õÂú∫ÊôØ‰∏≠ÔºåÊó†ËÆ∫Êàë‰ª¨‰ΩøÁî®‰ªÄ‰πàÊñπÂºèÔºåÊó†ËÆ∫Êàë‰ª¨‰ΩøÁî®‰ªÄ‰πà‰º†ËæìÂçèËÆÆÔºåÈÉΩÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ‰∫§Êç¢ÁöÑÊ∂àÊÅØÁöÑÊ†ºÂºèÊòØÁõ∏ÂêåÁöÑÔºå‰∏çÂêåÁöÑËÆæÂ§áÊàñÈ©±Âä®Á®ãÂ∫èÂèØ‰ª•Ê†πÊçÆÂÆÉÁöÑÁâπÁÇπÔºå‰ΩøÁî®ÂâçÈù¢ÊèêÂà∞ÁöÑÁâπÂæÅ‰ΩçÔºåÂçèÂïÜ‰∏çÂêåÁöÑËÉΩÂäõÊàñÁâπÂæÅ„ÄÇËøôÊ†∑‰∏ÄÊù•ÔºåËôöÊãüÈòüÂàóÂè™ÊòØ‰Ωú‰∏∫ËÆæÂ§á-È©±Âä®Á®ãÂ∫èÈÄö‰ø°ÁöÑ‰∏Ä‰∏™ÊôÆÈÄöËñÑÂ±ÇÔºåÂèØ‰ª•ÂáèÂ∞ëÂºÄÂèëÂíåÈÉ®ÁΩ≤ÁöÑÊäïËµÑ„ÄÇ</p>
<blockquote>
<p>As stated on <a target="_blank" rel="noopener" href="https://www.redhat.com/en/virtio-networking-series">previous blogs on this series</a>, the interest of this standardization is to achieve a slim layer of communication with the virtual environment (instead of emulating a complete piece of hardware), that makes it easier to verify for correctness across different virtualization technologies or hardware.</p>
</blockquote>
<p>Ê≠£Â¶ÇÊú¨Á≥ªÂàóÁöÑÂâçÂá†ÁØáÂçöÂÆ¢ÊâÄËø∞ÔºåËøôÁßçÊ†áÂáÜÂåñÁöÑÂÖ¥Ë∂£Âú®‰∫éÂÆûÁé∞‰∏éËôöÊãüÁéØÂ¢ÉÁöÑËñÑÂ±ÇÈÄö‰ø°ÔºàËÄå‰∏çÊòØÊ®°Êãü‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÁ°¨‰ª∂ÔºâÔºåËøô‰ΩøÂæóÂú®‰∏çÂêåÁöÑËôöÊãüÂåñÊäÄÊúØÊàñÁ°¨‰ª∂‰πãÈó¥È™åËØÅÊ≠£Á°ÆÊÄßÊõ¥Âä†ÂÆπÊòì„ÄÇ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/" data-id="clefret8n0000t1wbey3l78ev" data-title="Virtio devices and drivers overview: The headjack and the phone" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-windows-install-virtio-then-reboot-met-BSOD" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/" class="article-date">
  <time class="dt-published" datetime="2023-02-03T02:05:19.000Z" itemprop="datePublished">2023-02-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/">Windows install virtio then reboot met BSOD</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>This blog is a practice search about windows virtio driver installation.</p>
<h2 id="Backgroud"><a href="#Backgroud" class="headerlink" title="Backgroud"></a>Backgroud</h2><p>For virtualization software, normally guest will install virtio related drivers to get better virtualization performance. But instll virtio driver to windows guest sometimes became complex, so many softwares offer a practice guide about virtio dirver installation</p>
<table>
<thead>
<tr>
<th>Software</th>
<th>practice guide</th>
</tr>
</thead>
<tbody><tr>
<td>Proxmox</td>
<td><a target="_blank" rel="noopener" href="https://pve.proxmox.com/wiki/Windows_VirtIO_Drivers">https://pve.proxmox.com/wiki/Windows_VirtIO_Drivers</a> <br /><a target="_blank" rel="noopener" href="https://pve.proxmox.com/wiki/Windows_10_guest_best_practices">https://pve.proxmox.com/wiki/Windows_10_guest_best_practices</a></td>
</tr>
<tr>
<td>IBM Cloud orchestrator</td>
<td><a target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/cloud-orchestrator/2.5.0.3?topic=images-installing-virtio-driver-kvm-hypervisor-only">https://www.ibm.com/docs/en/cloud-orchestrator/2.5.0.3?topic=images-installing-virtio-driver-kvm-hypervisor-only</a></td>
</tr>
</tbody></table>
<p>the guide introduce that how to install virtio driver from win-virtio.iso while lauch windows install.</p>
<p>But in practice, if user want install driver to exists guest, windows still get BSOD after virtio driver installed.</p>
<p>So I write this blog to solve related problems.</p>
<h3 id="Newly-virtio-driver-installation"><a href="#Newly-virtio-driver-installation" class="headerlink" title="Newly virtio driver installation"></a>Newly virtio driver installation</h3><p>Windows running root disk attached to ide controller and install virtio driver. Then stop guest and move the disk from ide controller to virtio-serial controller, start guest will meet BSOD (no accessible boot device).</p>
<p>This is because windows do not load the virtio controller when install virtio driver to running vm.</p>
<p>According to P2V practice, how to inject virtio driver to a guest <a target="_blank" rel="noopener" href="https://portal.nutanix.com/page/documents/kbs/details?targetId=kA00e000000kAWeCAM">https://portal.nutanix.com/page/documents/kbs/details?targetId=kA00e000000kAWeCAM</a> </p>
<p>we need manually load driver</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drvload vioser.inf</span><br></pre></td></tr></table></figure>

<p>then install the driver to disk where windows installed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism &#x2F;image:c:\ &#x2F;add-driver &#x2F;driver:vioscsi.inf</span><br></pre></td></tr></table></figure>

<p>but if you try to do this on a running windows vm, dism will tell you that this operation is not allowed on a running windows. So the kv tell user to do the operation through cmd prompt when windows failed to boot not convinence if there are many guest need do this.</p>
<p>from superuser <a target="_blank" rel="noopener" href="https://superuser.com/questions/1057959/windows-10-in-kvm-change-boot-disk-to-virtio/1253728#1253728">https://superuser.com/questions/1057959/windows-10-in-kvm-change-boot-disk-to-virtio/1253728#1253728</a></p>
<p>other solution is raised, the best one is by setting guest into safeboot mode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;set &quot;&#123;current&#125;&quot; safeboot minimal</span><br></pre></td></tr></table></figure>

<p>windows will load all drivers then change the disk controller seems make sense, but still manually operation is required.</p>
<p>A tricky way is noticed by adding a dummy virtio disk to windows and then install virtio driver, the controller will be loaded at first.</p>
<p>the following steps I followed:</p>
<ol>
<li>Install the virtio driver in windows</li>
<li>Add a additional ‚Äúdummy‚Äù virtio disk. Reboot and check if the ‚Äúdummy‚Äù works.</li>
<li>If Step 2 works, then switch the boot disk to virtio.</li>
<li>Reboot</li>
<li>Remove the additional ‚Äúdummy‚Äù virtio disk</li>
</ol>
<p>because we do not need to do more operation inside guest, so this solution can be changed to a automatic way.</p>
<p>And more discussion can be found on reddit:</p>
<blockquote>
<p>Looks like you‚Äôre having the issue of windows refusing to load the virtio storage drivers at boot.</p>
<p>The only thing I found that works for me is using this method - <a target="_blank" rel="noopener" href="https://superuser.com/a/1200899">https://superuser.com/a/1200899</a>. You can also try this method of adding another disk and installing the driver but I personally found that to be very hit and miss.</p>
<p>For the first method you need to use diskpart to assign drive letters to your windows drive and virtio iso this tutorial should help if you don‚Äôt know how to do it.</p>
</blockquote>
<p>but luckily, </p>
<blockquote>
<p>You need to install the virtio drivers on a per storage device basis.</p>
<p>I suggest swapping back to sata and add a empty virtio device to your guest. Then boot and install the virtio driver for the new the device. Last step is to delete the old sata device and mount the device image at the virtio device and boot your guest.</p>
<p>Make sure that libvirt didn‚Äôt changed the pcie address of your virtio device as windows registers the driver on a per device basis.</p>
</blockquote>
<p>the dummy disk work around can be used because the pci address acutally reused (as the virtio device will be removed and reboot)</p>
<p>This method works well when virtio drivers are newly added, but if you have booted guest with virtio driver installed, change the controller from ide to virtio is complex.</p>
<p>We prefer user to install virtio driver during first windows intallation and make it as a image to avoid controller change.</p>
<h2 id="Virtio-driver-already-installed"><a href="#Virtio-driver-already-installed" class="headerlink" title="Virtio driver already installed"></a>Virtio driver already installed</h2><p>While virtio already installed and reboot windows and the disk controller not changed. After reboot the boot disk is still ide. </p>
<p>If you attach virtio-blk disk to guest, it will be recognized and loaded right now. </p>
<p>But if follow the steps below to attach a dummy disk (in this case you attached a virtio-blk disk actually), change the ide controller to virtio will not work, windows kept report BSOD after changed.</p>
<p>Work around is uninstall the virtio driver and reinstall with the steps than reboot every will works.</p>
<p>I think maybe windows only load all drivers which are newly installed. But for existing driver, it only works per disk basis.</p>
<h2 id="Virtio-scsi-always-works"><a href="#Virtio-scsi-always-works" class="headerlink" title="Virtio-scsi always works"></a>Virtio-scsi always works</h2><p>Cheerfully, if you change the ide/sata controller to virtio-scsi controller after virtio driver installed, windows works well.</p>
<p>More performance test is needed because we kept use virtio-blk for root disk due to some version of virtio driver offered virtio-scsi has bad performance.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/" data-id="cldnw2sji0000r2cabzpp6s00" data-title="Windows install virtio then reboot met BSOD" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BSOD/" rel="tag">BSOD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/windows/" rel="tag">windows</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arch-notes/">arch-notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/devops/">devops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/languages/">languages</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/languages/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/languages/python/">python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/memory-management/">memory management</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/management/">management</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-related-works/">project-related-works</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/">virtualization</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/edk2-ovmf/">edk2-ovmf</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/kvm/">kvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/">translation</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/virtio/">virtio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/virtio-networking/">virtio-networking</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/v2v/">v2v</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/virtio-balloon/">virtio-balloon</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BSOD/" rel="tag">BSOD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPDK/" rel="tag">DPDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElementTree/" rel="tag">ElementTree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDP/" rel="tag">TDP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TLB/" rel="tag">TLB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code-reading/" rel="tag">code-reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/colo/" rel="tag">colo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/edk2-ovmf/" rel="tag">edk2-ovmf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ft/" rel="tag">ft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kvm/" rel="tag">kvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/live-migration/" rel="tag">live-migration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-balloon/" rel="tag">memory balloon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nessus/" rel="tag">nessus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nexus/" rel="tag">nexus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/others/" rel="tag">others</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/paper-reading/" rel="tag">paper-reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perf/" rel="tag">perf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/performance/" rel="tag">performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes/" rel="tag">reading notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software-arch/" rel="tag">software-arch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sysstat/" rel="tag">sysstat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/system-design/" rel="tag">system-design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/v2v/" rel="tag">v2v</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vDPA/" rel="tag">vDPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vhost-net/" rel="tag">vhost-net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virt/" rel="tag">virt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virt-top/" rel="tag">virt-top</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-balloon/" rel="tag">virtio-balloon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-net/" rel="tag">virtio-net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-networking/" rel="tag">virtio-networking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BSOD/" style="font-size: 10px;">BSOD</a> <a href="/tags/DPDK/" style="font-size: 12.86px;">DPDK</a> <a href="/tags/ElementTree/" style="font-size: 10px;">ElementTree</a> <a href="/tags/TDP/" style="font-size: 11.43px;">TDP</a> <a href="/tags/TLB/" style="font-size: 10px;">TLB</a> <a href="/tags/architecture/" style="font-size: 18.57px;">architecture</a> <a href="/tags/code-reading/" style="font-size: 10px;">code-reading</a> <a href="/tags/colo/" style="font-size: 10px;">colo</a> <a href="/tags/cpu/" style="font-size: 11.43px;">cpu</a> <a href="/tags/edk2-ovmf/" style="font-size: 10px;">edk2-ovmf</a> <a href="/tags/ft/" style="font-size: 11.43px;">ft</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 12.86px;">java</a> <a href="/tags/kernel/" style="font-size: 14.29px;">kernel</a> <a href="/tags/kvm/" style="font-size: 15.71px;">kvm</a> <a href="/tags/libvirt/" style="font-size: 12.86px;">libvirt</a> <a href="/tags/linux/" style="font-size: 17.14px;">linux</a> <a href="/tags/live-migration/" style="font-size: 10px;">live-migration</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/memory-balloon/" style="font-size: 10px;">memory balloon</a> <a href="/tags/nessus/" style="font-size: 10px;">nessus</a> <a href="/tags/nexus/" style="font-size: 10px;">nexus</a> <a href="/tags/others/" style="font-size: 10px;">others</a> <a href="/tags/paper-reading/" style="font-size: 10px;">paper-reading</a> <a href="/tags/perf/" style="font-size: 10px;">perf</a> <a href="/tags/performance/" style="font-size: 10px;">performance</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/qemu/" style="font-size: 20px;">qemu</a> <a href="/tags/reading-notes/" style="font-size: 10px;">reading notes</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/software-arch/" style="font-size: 12.86px;">software-arch</a> <a href="/tags/sysstat/" style="font-size: 10px;">sysstat</a> <a href="/tags/system-design/" style="font-size: 12.86px;">system-design</a> <a href="/tags/v2v/" style="font-size: 10px;">v2v</a> <a href="/tags/vDPA/" style="font-size: 10px;">vDPA</a> <a href="/tags/vhost-net/" style="font-size: 17.14px;">vhost-net</a> <a href="/tags/virt/" style="font-size: 14.29px;">virt</a> <a href="/tags/virt-top/" style="font-size: 10px;">virt-top</a> <a href="/tags/virtio/" style="font-size: 17.14px;">virtio</a> <a href="/tags/virtio-balloon/" style="font-size: 10px;">virtio-balloon</a> <a href="/tags/virtio-net/" style="font-size: 17.14px;">virtio-net</a> <a href="/tags/virtio-networking/" style="font-size: 17.14px;">virtio-networking</a> <a href="/tags/windows/" style="font-size: 10px;">windows</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/27/virtio-memory-balloon/">Understand virtio memory balloon</a>
          </li>
        
          <li>
            <a href="/2023/04/13/qemu-colo-details/">Qemu Colo Details</a>
          </li>
        
          <li>
            <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">KVMËôöÊãüÂåñÊÄßËÉΩÂàÜÊûê</a>
          </li>
        
          <li>
            <a href="/2023/03/09/cpu-features-about-kvm-hidden/">Cpu features about kvm hidden</a>
          </li>
        
          <li>
            <a href="/2023/03/03/virtio-on-linux/">Virtio on Linux</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a></br>
      
      &copy; 2023 Alan Jager<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = '' == true;
    var verify = 'false' == true;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "r30r51B3r5JFqlxR88Jua6So-gzGzoHsz",
        appKey: "wnL9j38siXbLqBHGnWpzmVxv",
        placeholder: "Just go go",
        pageSize:'10',
        avatar:'mm',
        lang:'zh-cn'
    });
</script>

  </div>
</body>
</html>