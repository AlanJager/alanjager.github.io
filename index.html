<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>花の様に</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="花の様に">
<meta property="og:url" content="http://hanayo.cn/index.html">
<meta property="og:site_name" content="花の様に">
<meta property="og:locale">
<meta property="article:author" content="Alan Jager">
<meta property="article:tag" content="ブログ">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="花の様に" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">花の様に</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanayo.cn"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-qemu-colo-details" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/13/qemu-colo-details/" class="article-date">
  <time class="dt-published" datetime="2023-04-13T15:49:38.000Z" itemprop="datePublished">2023-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/13/qemu-colo-details/">Qemu Colo Details</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="qemu-quorum-block-filter"><a href="#qemu-quorum-block-filter" class="headerlink" title="qemu quorum block filter"></a>qemu quorum block filter</h2><p>Based on the code design of blkverify.c and blkmirror.c, the main purpose is to mirror write requests to all the qcow images hanging in the quorum, and the read operation is to check whether the number of occurrences of the qiov version meets the value set by the threshold through the parameters set by the threshold. Then it returns the &gt; value of the result with the highest number of occurrences, if the number of occurrences i is less than the threshold then it returns the quourm exception and the read operation returns -EIO.</p>
<p>The main use of this feature is for people who use NFS devices affected by bitflip errors.</p>
<p>If you set the read-pattern to FIFO and set the threshold to 1, you can construct a read-only first disk scenario.</p>
<h2 id="block-replication"><a href="#block-replication" class="headerlink" title="block-replication"></a>block-replication</h2><p>The micro checkpoint and COLO mentioned in the introduction to the QEMU FT solution will continuously create checkpoints, and the state of the pvm and svm will be the same at the moment the checkpoint is completed. But it will not be consistent until the next checkpoint.</p>
<p>To ensure consistency, the SVM changes need to be cached and discarded at the next checkpoint. To reduce the stress of network transfers between checkpoints, changes on the PVM disk are synchronized asynchronously to the SVM node.</p>
<p>For example, the first time VM1 does a checkpoint, it is recorded as state C1, then VM2’s state is also C1, at this time VM2’s disk changes start to cache, VM1’s changes are written to VM2’s node through this mechanism, if an error occurs at this time how should it be handled?</p>
<p>Suppose we discuss the simplest case of VM1 hanging, then because the next checkpoint has not yet been executed, VM2 continues to run the state of C1 for a period of time and the disk changes are cached, at this time it is only necessary to flush the cached data to VM2’s disk single point to continue to run or wait for FT reconstruction, which is the reason for the need to do SVM disk changes caching (here the data (including two copies, one is to restore to VM2 last checkpoint cache, the other is to VM2 in C1 after the cache of changes)</p>
<p>The following is the structure of block-replication:</p>
<img src="/2023/04/13/qemu-colo-details/fig1.png" class="">

<ol>
<li>The block device on the primary node mounts two sub-devices via quorum, providing backup from the primary node to the secondary host. The read pattern (FIFO) is extended to meet the situation where the primary node will only read the local disk (the threshold needs to be set to 1 so that read operations will only be performed locally)</li>
<li>A newly implemented filter called replication is responsible for controlling block replication</li>
<li>The secondary node receives disk write requests from the primary node through the embedded nbd server</li>
<li>The device on the secondary node is a custom block device, we call it an active disk. it should be an empty device at the beginning, but the block device needs to support bdrv_make_empty() and backing_file</li>
<li>The hidden-disk is created automatically, and this file caches the contents modified by what is written from the primary node. It should also be an empty device at the beginning and support bdrv_make_empty() and backing_file</li>
<li>The blockdev-backup job (sync=none) will synchronize all the contents of the hidden-disk cache that should have been overwritten by nbd-induced writes, so the primary and secondary nodes should have the same disk contents before the replication starts</li>
<li>The secondary node also has a quorum node, so that the secondary can become the new primary after the failover and continue to perform the replication</li>
</ol>
<p>There are seven types of internal errors that can exist when block replication runs:</p>
<ol>
<li>Primary disk I/O errors</li>
<li>Primary disk forwarding errors</li>
<li>blockdev-backup error</li>
<li>secondary disk I/O errors</li>
<li>active disk I/O error</li>
<li>Error clearing hidden disk and active disk</li>
<li>failover failure</li>
</ol>
<p>For error 1 and error 5, just report block level errors directly upwards.</p>
<p>For 2, 3, 4, and 6 need to be reported to the control plane of FT for failover process control.</p>
<p>In the case of 7, if the active commit fails, it will prompt a secondary node write operation error and let the person performing the failover decide how to handle it.</p>
<h2 id="colo-checkpoint"><a href="#colo-checkpoint" class="headerlink" title="colo checkpoint "></a>colo checkpoint </h2><p>colo uses vm’s live migration to achieve the checkpoint function</p>
<p>Based on the above block-replication to achieve disk synchronization, the other part is how to synchronize the running state data of virtual machines, here directly using the existing live migration, that is, cloud host hot migration, so that after each checkpoint can be considered pvm and svm disk/memory are consistent, so need to be in This event depends on the time of live migration.</p>
<p>First, let’s organize the checkpoint process, which is divided into two major parts</p>
<h3 id="Configuration-phase"><a href="#Configuration-phase" class="headerlink" title="Configuration phase"></a>Configuration phase</h3><p>This part will be executed mainly when the colo is first set up, we know that by default at the beginning we will configure the disk synchronization of pvm and svm, but the memory is not actually synchronized yet, so at the beginning we will ask the svm to be pused at first after the startup, and then submit two synchronization operations from the pvm side</p>
<ol>
<li>Submit the drive-mirror task to mirror the contents of the disk from the pvm to the remote svm’s disk (embedded nbd is used here, which is also the target disk of the block replicaton later) to ensure that the pvm’s contents are consistent with the svm’s</li>
<li>Submit a migration task to synchronize memory from pvm to svm, and since both pvm and svm are required to be paired at this point, you actually wait until both pvm and svm are synchronized, then you need to cancel the drive-mirror task, start block replication, and continue running vm<br>Of course, the paused state mentioned in 2 has been changed to be similar to hot migration after the improvements made by intel. After the drive-mirror task is submitted, the id of the task and the information of the block replication disks are used as parameters for the colo migration, which will actually be automatically changed when migrating in the line of online migration. After the migration is completed, the drive-mirror task is automatically cancelled and block-replication is automatically started before running vm, which simplifies the steps a lot.</li>
</ol>
<p>After the configuration, you need to manually issue a migrate command to the colo pvm, and the checkpoint will enter the cycle of monitoring after the first migrate.</p>
<img src="/2023/04/13/qemu-colo-details/fig2.png" class="">

<h3 id="Start-the-checkpoint"><a href="#Start-the-checkpoint" class="headerlink" title="Start the checkpoint"></a>Start the checkpoint</h3><p>The checkpoint mechanism consists mainly of a loop, and the code flow of qemu is as follows:</p>
<img src="/2023/04/13/qemu-colo-details/fig3.png" class="">

<p>Combined with this picture we explain the more important parts inside</p>
<h4 id="Process-phase"><a href="#Process-phase" class="headerlink" title="Process phase"></a>Process phase</h4><p>COLO-FT initializes some key variables such as migration status, FAILOVER status and listens to the internal checkpoint notify (triggered from COLO compare)</p>
<p>After the first successful migrate, the discount state is initialized and the migration state is changed to COLO</p>
<p>After receiving a request for a checkpoint, a series of checkpoint creation processes are performed</p>
<h4 id="Colo-Status"><a href="#Colo-Status" class="headerlink" title="Colo Status"></a>Colo Status</h4><p>For the COLO-FT virtual machine, there are two important states</p>
<p>One is the MigrationState, which on the COLO-FT virtual machine is MIGRATION_STATUS_COLO corresponding to the string “COLO”, which is a prerequisite state to allow checkpointing, and the cloud host must have established the COLO-FT mechanism. FT mechanism, that is, through the above configuration phase to complete the configuration and the first checkpoint, will enter this state and the main loop</p>
<p>Another state is failover_state, which is a global variable defined in colo_failover.c, which is accessed by colo.c through failover_get_state(), and this parameter is set to FAILOVER_STATUS at the start of the checkpoint loop _NONE, which means that failover is not needed. The bottom half of qemu mounts the mechanism for modifying this state, so it can be triggered by user state commands, so you need to pay attention to whether failover is triggered or not when actually doing checkpoint</p>
<h4 id="Communitaion"><a href="#Communitaion" class="headerlink" title="Communitaion"></a>Communitaion</h4><p>COLO communicates through messages to get the status of the SVM, as well as to send and confirm the start and completion of the checkpoint, and the message process inside has the following main steps</p>
<ol>
<li>Sending COLO_MESSAGE_CHECKPOINT_REQUEST</li>
<li>After the SVM receives the message, pause the SVM and send COLO_MESSAGE_CHECKPOINT_READY</li>
<li>PVM starts saving and live migration of VMSTATE</li>
<li>SVM gets the migrated information and does the CPU synchronization and VM state LOAD locally.</li>
<li>SVM will wait for a check message from PVM after the migration is completed, and PVM will send a message after the live migration is completed.</li>
<li>PVM sends COLO_MESSAGE_VMSTATE_SIZE with the size of VMSTATE sent via QIOChannelBuffer</li>
<li>SVM receives the message and checks if the size received locally is the same as the size sent, if it is, it replies COLO_MESSAGE_VMSTATE_RECEIVED</li>
<li>After confirming the VMSTATE transfer, the SVM will do some migration and subsequent synchronization and cleanup.</li>
<li>After completion, the SVM executes vm_start() and sends COLO_MESSAGE_VMSTATE_LOADED.</li>
<li>After the PVM receives the message that the SVM has successfully loaded, the PVM will also execute vm_start().</li>
</ol>
<p>The logic of suspend, migrate and resume the operation of PVM SVM is realized through the message collaboration between PVM and SVM</p>
<img src="/2023/04/13/qemu-colo-details/fig4.png" class="">

<p>Existing problems, because the current checkpoint are notified to each other through the message, once the corresponding packet is sent and not returned, the next wait may always exist, can not be closed, assuming that at this time from the bottom half (bottom half) to send a request also did not do to clean up the wait state.</p>
<p>It should be noted that: the default checkpoint once the failure occurs, the vm will be a direct exit, requiring the rebuilding of COLO-FT, so the establishment of COLO-FT failure needs to be analyzed from two parts</p>
<p>Whether the configuration phase migration has failed<br>Whether the configuration is complete (migration has become colo state) but the checkpoint failed (the above process failed) resulting in COLO-FT exit</p>
<h3 id="colo-proxy"><a href="#colo-proxy" class="headerlink" title="colo proxy"></a>colo proxy</h3><p>colo proxy as the core component of COLO-FT, this article mainly focuses on the functionality of colo proxy in QEMU</p>
<p>When QEMU implements the net module, it actually treats the actual device in the guest as a receiver, so the corresponding relationship is as follows</p>
<p>TX RX</p>
<p>qemu side network device (sender) ——————-→ guest inside driver (receiver)</p>
<p>Combined with the code, the filter will be executed before actually doing transimission, and then go to sender processing.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NetQueue *queue;</span><br><span class="line">size_t size &#x3D; iov_size(iov, iovcnt);</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">if (size &gt; NET_BUFSIZE) &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (sender-&gt;link_down || !sender-&gt;peer) &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Let filters handle the packet first *&#x2F;</span><br><span class="line">ret &#x3D; filter_receive_iov(sender, NET_FILTER_DIRECTION_TX, sender,</span><br><span class="line">                         QEMU_NET_PACKET_FLAG_NONE, iov, iovcnt, sent_cb);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret &#x3D; filter_receive_iov(sender-&gt;peer, NET_FILTER_DIRECTION_RX, sender,</span><br><span class="line">                         QEMU_NET_PACKET_FLAG_NONE, iov, iovcnt, sent_cb);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &#x3D; sender-&gt;peer-&gt;incoming_queue;</span><br><span class="line"></span><br><span class="line">return qemu_net_queue_send_iov(queue, sender,</span><br><span class="line">                               QEMU_NET_PACKET_FLAG_NONE,</span><br><span class="line">                               iov, iovcnt, sent_cb);</span><br></pre></td></tr></table></figure>

<p>The filter-mirror and filter-redirect in the network-filter implemented by colo act as the forwarding function of the proxy</p>
<p>The classic process for a network card is as follows:</p>
<img src="/2023/04/13/qemu-colo-details/fig5.png" class="">

<p>The host device receives the network packet and sends it to the guest</p>
<ol>
<li>First execute the first filter-mirror, for qemu is transimission, so execute mirror action, the network packet mirror a copy sent off through outdev (chardev), and then call the next filter (because it is TX, so other filters will not be executed, so pvm on (the packet is sent directly to the guest)</li>
<li>SVM’s indev connects to PVM’s mirror’s outdev (via socket), so it receives the packet sent by 1. The filter does not specify an outdev after receiving the packet, so it calls the next filter directly</li>
<li>SVM calls filter-rewrite, the direction of this filter is ALL, so the packets to and from SVM will be processed by this filter, if the target is sent, because it is sent to VM so the first direction is TX, COLO will record the various states of this TCP packet</li>
<li>Because there is no next filter so it is sent to the qemu network device, and then take the process of sending to the guest</li>
<li>From the guest to the qemu network packet, the direction is RX so the filter processing order will be reversed and sent to the rewrite first</li>
<li>SVM calls filter-rewrite this time in the direction of RX, so when processing, it will process the tcp packets returned by SVM, compare the input and output of tcp packets through the tcp packets table, and if the processing fails, it will put the packet in the queue and resend it again (note: need to continue deeper analysis), and then the filter- redirector</li>
<li>Also in the PVM mirror filter, because there is no subsequent TX filter, the packet is sent directly to the qemu net device and then to the PVM guest.</li>
<li>The packets coming out of the PVM guest will be sent to the primary in interface of the colo-compare thing by filter-redirector because it is in the RX direction, so some filters will be performed in the reverse direction</li>
<li>SVM will send the return of SVM to the secondary in interface of colo-compare of PVM via redirector’s outdev<br>colo-compare receives the packet and starts to do the relevant analysis to decide whether checkpoint is needed</li>
<li>The filter-redirector’s indev receives the return from colo-compare after comparison and forwards it to the host net device via outdev</li>
</ol>
<p>This is the end of a complete packet processing process.</p>
<p>Since colo-compare is responsible for comparing pvm and svm packets, there are some metrics that need to be understood</p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>payload_size = total size - header_size i.e. the size of the whole packet minus the length of the header</p>
<p>packet data offset packet header size after the distance and payload_size comparison is consistent</p>
<p>The following is a summary of what needs to be done here</p>
<p>The logic of colo-compare comparison is organized:</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>Compare whether the payloads are the same. If it is the same and the ack is the same then it is over. If it is the same but the ack of pvm is larger than the ack of svm, the packet sent to svm is dropped and the packet of pvm will not be sent (meaning sent back to the host NIC). So we will record the maximum ack in the current queue (both pvm and svm queues) until the ack exceeds the smaller of the two maximum ack values, and we can ensure that the packet payload is confirmed by both sides</td>
</tr>
<tr>
<td>UDP</td>
<td>only palyload checked</td>
</tr>
<tr>
<td>ICMP</td>
<td>only palyload checked</td>
</tr>
<tr>
<td>Other</td>
<td>only packet size checked</td>
</tr>
</tbody></table>
<p>Possible reasons for network packet loss are therefore:</p>
<ol>
<li>colo-compare did not receive the packet correctly</li>
<li>svm’s redirector did not successfully forward packets to rewrite</li>
<li>mirror did not replicate the packet successfully</li>
<li>pvm’s redirector did not successfully send pvm’s return to colo-compare</li>
<li>svm’s rewrite did not send/receive packets successfully</li>
<li>colo-compare is not sending packets correctly</li>
<li>svm’s redirector did not successfully forward packets to colo-compare</li>
</ol>
<p>Problem processing</p>
<p>The processing of 1 mainly relies on the colo compare mechanism itself, for tcp packets will determine whether there are subsequent packets returned by ack, if there are subsequent packets, it means that the previous is missed</p>
<p>2 If the packet is not successfully sent to rewrite, it will not be processed by svm, so finally colo compare will encounter the situation where pvm has a packet but svm does not have a packet, and the processing is similar to 1</p>
<p>3 If mirror does not successfully copy the package, then there will also be a situation similar to 1, pvm exists package, svm no package</p>
<p>4 if pvm redirector did not successfully send the packet, then it seems from colo compare is pvm lost packets, but the same 1 processing, will wait for the pvm and svm minimum ack is exceeded, that is, both pvm or svm even if packet loss occurs, colo compare will wait for the updated packet to appear before returning the packet otherwise will always card does not reverse the current packet</p>
<p>5 If rewritte’s send-receive fails, this situation will cause the svm to not receive the packet and not return, similar to 1, but if failover occurs at this time, the svm packet is lost</p>
<p>6 this exception will lead to colo send and receive packet exceptions, network anomalies, not very well handled because itself colo compare is the core component</p>
<p>7 similar situation svm seems to have replied or actively sent the packet, but because colo compare did not receive, resulting in the svm within the data that did not reply, the benefit is that if the subsequent failover can occur, rewrite because the packet was recorded, will send the packet again, then it seems to be working again (need to test)</p>
<h3 id="Trigger-checkpoint"><a href="#Trigger-checkpoint" class="headerlink" title="Trigger checkpoint"></a>Trigger checkpoint</h3><p>There are two conditions for triggering from colo-comare, because COLO-FT will establish a notification mechanism when it is established, and colo compare will trigger checkpoint from inside actively through this mechanism</p>
<ol>
<li>Checkpoint will be triggered if the payload of the compare tcp packet is inconsistent</li>
<li>Timed to check if there is a certain period of time but has not received the same return packet (i.e., pvm, svm packet chain table content is inconsistent) trigger checkpoint</li>
<li>If there is a packet in the pvm list but not in the secondary packet, then it means that the packet reply is late, this situation is handled by 2, if the comparison finds that the non-tcp packet comparison is inconsistent will trigger a checkpoint</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/04/13/qemu-colo-details/" data-id="clgfbjhl80000e7wb9imx6mfo" data-title="Qemu Colo Details" class="article-share-link">Share</a>
      
      
        <a href="/2023/04/13/qemu-colo-details/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/04/13/qemu-colo-details/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/colo/" rel="tag">colo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ft/" rel="tag">ft</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-KVM虚拟化性能分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2023-03-13T14:36:38.000Z" itemprop="datePublished">2023-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/kvm/">kvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">KVM虚拟化性能分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>KVM虚拟化是一种常用的虚拟化技术，它可以将一台物理服务器划分为多个虚拟机，从而提高服务器的利用率和灵活性。然而，由于虚拟化带来的额外开销，KVM虚拟化的性能问题是一个常见的挑战。为了解决这些问题，我们需要使用一些性能诊断工具来分析和优化KVM虚拟化的性能。</p>
<p>以下是一些常用的KVM虚拟化性能诊断工具：</p>
<h2 id="Perf"><a href="#Perf" class="headerlink" title="Perf"></a>Perf</h2><p>Perf是一种Linux性能分析工具，可以用于监视系统性能和调试性能问题。它基于Linux内核提供的性能事件接口，并提供了一个命令行界面，可以用于监视CPU使用率、内存使用情况、磁盘I/O等性能指标。</p>
<p>以下是使用Perf进行KVM虚拟化性能分析的最佳实践：</p>
<ol>
<li>安装Perf</li>
</ol>
<p>要安装Perf，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-tools-common linux-tools-generic linux-tools-&#96;uname -r&#96;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>收集Perf数据</li>
</ol>
<p>要使用Perf收集性能数据，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -g -p &#96;pidof qemu-system-x86_64&#96; -F 99</span><br></pre></td></tr></table></figure>

<p>在这个例子中，-g选项表示收集函数调用图（用于生成Flame Graph），-p选项表示监视qemu-system-x86_64进程，-F选项表示使用99Hz的采样频率来收集性能数据。</p>
<ol start="3">
<li>生成Flame Graph</li>
</ol>
<p>要生成Flame Graph，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf script | stackcollapse-perf.pl | flamegraph.pl &gt; output.svg</span><br></pre></td></tr></table></figure>

<p>在这个例子中，perf script命令将Perf数据转换为脚本输出，stackcollapse-perf.pl命令将脚本输出转换为折叠栈，flamegraph.pl命令将折叠栈转换为Flame Graph。最终的Flame Graph将保存在output.svg文件中。</p>
<h2 id="Sysstat"><a href="#Sysstat" class="headerlink" title="Sysstat"></a>Sysstat</h2><p>Sysstat是一个Linux系统性能监控工具，可以用于监视CPU、内存、磁盘I/O等性能指标。在KVM虚拟化中，您可以使用Sysstat来监视虚拟机的性能。以下是使用Sysstat进行KVM虚拟化性能分析的最佳实践：</p>
<ol>
<li>安装Sysstat</li>
</ol>
<p>要安装Sysstat，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install sysstat</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置Sysstat</li>
</ol>
<p>要配置Sysstat，请编辑/etc/default/sysstat文件，并更改以下变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HISTORY&#x3D;7</span><br><span class="line">INTERVAL&#x3D;60</span><br></pre></td></tr></table></figure>

<p>在这个例子中，Sysstat将每1分钟收集一次性能数据，并将数据保存最近7天。</p>
<ol start="3">
<li>分析Sysstat数据</li>
</ol>
<p>Sysstat收集的数据保存在/var/log/sysstat目录下。您可以使用以下命令来查看Sysstat数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sar -u</span><br><span class="line">sar -r</span><br><span class="line">sar -b</span><br><span class="line">sar -d</span><br></pre></td></tr></table></figure>

<p>这些命令将分别显示CPU使用率、内存使用情况、磁盘I/O等性能数据。</p>
<ol start="4">
<li>使用Sysstat报告</li>
</ol>
<p>Sysstat还提供了一个报告生成工具，可以根据Sysstat数据生成报告。要生成报告，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sar -A -o &lt;outfile&gt;</span><br><span class="line">sadf -dh &lt;outfile&gt; &gt; &lt;reportfile&gt;</span><br></pre></td></tr></table></figure>

<p>这将生成一个包含所有性能数据的输出文件<outfile>，然后使用sadf命令将输出文件转换为HTML格式的报告文件<reportfile>。</p>
<p>希望这些最佳实践可以帮助您更好地使用Sysstat进行KVM虚拟化性能分析。</p>
<p>如果您希望通过Sysstat数据进行趋势分析，可以使用一个名为<code>ksar</code>的工具。</p>
<p><code>ksar</code>是一个Java应用程序，可以将Sysstat数据转换为图表，从而更方便地进行趋势分析。</p>
<p>要使用<code>ksar</code>，请按照以下步骤操作：</p>
<ol>
<li>安装Java</li>
</ol>
<p><code>ksar</code>是一个Java应用程序，因此您需要安装Java才能运行它。您可以从Oracle官方网站下载Java。</p>
<ol start="2">
<li>下载和安装<code>ksar</code></li>
</ol>
<p>您可以从<code>ksar</code>的官方网站下载最新的版本。下载完成后，将压缩文件解压缩到您选择的目录中。</p>
<ol start="3">
<li>运行<code>ksar</code></li>
</ol>
<p>要运行<code>ksar</code>，请打开终端并导航到<code>ksar</code>目录。然后，运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ksar.jar</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>加载Sysstat数据文件</li>
</ol>
<p>在<code>ksar</code>窗口中，单击“File”菜单，然后选择“Open”选项。选择您要加载的Sysstat数据文件。</p>
<ol start="5">
<li>生成图表</li>
</ol>
<p>在<code>ksar</code>窗口中，单击“Graphs”菜单，然后选择要生成的图表类型。<code>ksar</code>将生成一个图表，显示Sysstat数据的趋势。</p>
<p>如果您在KVM虚拟化中遇到了网络性能问题，可以使用以下工具来进行诊断：</p>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>tcpdump是一种常用的网络抓包工具。在KVM虚拟化中，您可以在宿主机上使用tcpdump来监视虚拟机的网络流量。以下是一个示例命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i &lt;interface&gt; -w &lt;output-file&gt;</span><br></pre></td></tr></table></figure>

<p>在这个命令中，<interface>是您要监视的网络接口，<output-file>是保存抓包数据的输出文件。运行此命令后，tcpdump将开始监视指定的网络接口上的流量，并将所有数据保存到输出文件中。</p>
<h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p>Wireshark是一种网络协议分析工具，可以用于分析网络流量。在KVM虚拟化中，您可以在宿主机上使用Wireshark来分析虚拟机的网络流量。以下是一个示例命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tshark -i &lt;interface&gt; -w &lt;output-file&gt;</span><br></pre></td></tr></table></figure>

<h2 id="virt-top"><a href="#virt-top" class="headerlink" title="virt-top"></a>virt-top</h2><p>一个整合KVM虚拟化性能诊断工具的项目是<code>virt-top</code>。<code>virt-top</code>是一个基于ncurses的交互式监视器，可以用于监视KVM虚拟机的性能。以下是使用<code>virt-top</code>进行KVM虚拟化性能分析的最佳实践：</p>
<ol>
<li>安装<code>virt-top</code></li>
</ol>
<p>要安装<code>virt-top</code>，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install virt-top</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行<code>virt-top</code></li>
</ol>
<p>要运行<code>virt-top</code>，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virt-top</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>监视虚拟机性能</li>
</ol>
<p>在<code>virt-top</code>窗口中，您可以使用上下方向键选择要监视的虚拟机。然后，您可以查看虚拟机的CPU使用率、内存使用情况、磁盘I/O等性能指标。</p>
<p>希望这些最佳实践可以帮助您更好地使用KVM虚拟化性能诊断工具。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" data-id="clf6xlaht0000cqwbf3o8cy3v" data-title="KVM虚拟化性能分析" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kvm/" rel="tag">kvm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/performance/" rel="tag">performance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sysstat/" rel="tag">sysstat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virt-top/" rel="tag">virt-top</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cpu-features-about-kvm-hidden" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/09/cpu-features-about-kvm-hidden/" class="article-date">
  <time class="dt-published" datetime="2023-03-09T13:48:22.000Z" itemprop="datePublished">2023-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/kvm/">kvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/09/cpu-features-about-kvm-hidden/">Cpu features about kvm hidden</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="What-kvm-hidden-did-to-qemu"><a href="#What-kvm-hidden-did-to-qemu" class="headerlink" title="What kvm hidden did to qemu"></a>What kvm hidden did to qemu</h2><p>Based on last blog, we can see how libvirt cpu feature configuration changes qemu cpuid. And we figure out hypervisor disable configuration have what kind of influence.</p>
<p>Then another recommanded feature from libvirt is kvm hidden. In the same way with last blog, we can find libvirt will configure <code>kvm=off</code> to <code>-cpu</code> and according to qemu:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-relaxed&quot;</span>, X86CPU, hyperv_relaxed_timing, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-vapic&quot;</span>, X86CPU, hyperv_vapic, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-time&quot;</span>, X86CPU, hyperv_time, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-crash&quot;</span>, X86CPU, hyperv_crash, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-reset&quot;</span>, X86CPU, hyperv_reset, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-vpindex&quot;</span>, X86CPU, hyperv_vpindex, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-runtime&quot;</span>, X86CPU, hyperv_runtime, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-synic&quot;</span>, X86CPU, hyperv_synic, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-stimer&quot;</span>, X86CPU, hyperv_stimer, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;hv-frequencies&quot;</span>, X86CPU, hyperv_frequencies, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;check&quot;</span>, X86CPU, check_cpuid, <span class="literal">true</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;enforce&quot;</span>, X86CPU, enforce_cpuid, <span class="literal">false</span>),</span><br><span class="line">DEFINE_PROP_BOOL(<span class="string">&quot;kvm&quot;</span>, X86CPU, expose_kvm, <span class="literal">true</span>),</span><br></pre></td></tr></table></figure>

<p>those configures are defined by <code>target/i386/cpu.c</code> in variable <code>x86_cpu_properties</code>.</p>
<p><code>kvm=off</code> will be treated as “kvm” is false and the local variable of this cpu changes <code>expose_kvm</code> to false.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x86_cpu_realizefn</code> will invoke <code>x86_cpu_expand_features</code> to expand features from configuration, as a result FEAT_KVM will disable all features after realize features.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[FEAT_KVM] = &#123;</span><br><span class="line">    .feat_names = &#123;</span><br><span class="line">        <span class="string">&quot;kvmclock&quot;</span>, <span class="string">&quot;kvm-nopiodelay&quot;</span>, <span class="string">&quot;kvm-mmu&quot;</span>, <span class="string">&quot;kvmclock&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kvm-asyncpf&quot;</span>, <span class="string">&quot;kvm-steal-time&quot;</span>, <span class="string">&quot;kvm-pv-eoi&quot;</span>, <span class="string">&quot;kvm-pv-unhalt&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">&quot;kvm-pv-tlb-flush&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="string">&quot;kvmclock-stable-bit&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .cpuid_eax = KVM_CPUID_FEATURES, .cpuid_reg = R_EAX,</span><br><span class="line">    .tcg_features = TCG_KVM_FEATURES,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>check its definition, almost all kvm related features is disabled.</p>
<p>Then go ahead to linux kernel <code>arch/x86/include/uapi/asm/kvm_para.h</code> defines those features from cpuid:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This CPUID returns a feature bitmap in eax.  Before enabling a particular</span></span><br><span class="line"><span class="comment"> * paravirtualization, the appropriate feature bit should be checked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_CPUID_FEATURES	0x40000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_NOP_IO_DELAY	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_MMU_OP		2</span></span><br><span class="line"><span class="comment">/* This indicates that the new set of kvmclock msrs</span></span><br><span class="line"><span class="comment"> * are available. The use of 0x11 and 0x12 is deprecated</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE2        3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_ASYNC_PF		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_STEAL_TIME		5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_PV_EOI		6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_PV_UNHALT		7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The last 8 bits are used to indicate how to interpret the flags field</span></span><br><span class="line"><span class="comment"> * in pvclock structure. If no bits are set, all flags are ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEATURE_CLOCKSOURCE_STABLE_BIT	24</span></span><br></pre></td></tr></table></figure>

<p>And before we check all features details let’s check how linux figure kvm feature at first.</p>
<p>For kernel, check kvm by <code>kvm_para_available</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kvm_para_available</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> kvm_cpuid_base() != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which will return a kvm based hypervisor by check <code>cpu_has_hypervisor</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> noinline <span class="keyword">uint32_t</span> __kvm_cpuid_base(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (boot_cpu_data.cpuid_level &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">/* So we don&#x27;t blow up on old processors */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu_has_hypervisor)</span><br><span class="line">		<span class="keyword">return</span> hypervisor_cpuid_base(<span class="string">&quot;KVMKVMKVM\0\0\0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and <code>cpu_has_hypervisor</code>  is defined from the hypervisor feature we mentioned in last post:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpu_has_hypervisor	boot_cpu_has(X86_FEATURE_HYPERVISOR)</span></span><br></pre></td></tr></table></figure>

<p>So we combine those two part together to check the influence introduced by kvm hidden.</p>
<p>Note: here is the brief description about those features in cpuid:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function: define KVM_CPUID_FEATURES (0x40000001)</span><br><span class="line">returns : ebx, ecx, edx = 0</span><br><span class="line">          eax = and OR&#x27;ed group of (1 &lt;&lt; flag), where each flags is:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag                               || value || meaning</span><br><span class="line">=============================================================================</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE            ||     0 || kvmclock available at msrs</span><br><span class="line">                                   ||       || 0x11 and 0x12.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_NOP_IO_DELAY           ||     1 || not necessary to perform delays</span><br><span class="line">                                   ||       || on PIO operations.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_MMU_OP                 ||     2 || deprecated.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE2           ||     3 || kvmclock available at msrs</span><br><span class="line">                                   ||       || 0x4b564d00 and 0x4b564d01</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_ASYNC_PF               ||     4 || async pf can be enabled by</span><br><span class="line">                                   ||       || writing to msr 0x4b564d02</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_STEAL_TIME             ||     5 || steal time can be enabled by</span><br><span class="line">                                   ||       || writing to msr 0x4b564d03.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_PV_EOI                 ||     6 || paravirtualized end of interrupt</span><br><span class="line">                                   ||       || handler can be enabled by writing</span><br><span class="line">                                   ||       || to msr 0x4b564d04.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_PV_UNHALT              ||     7 || guest checks this feature bit</span><br><span class="line">                                   ||       || before enabling paravirtualized</span><br><span class="line">                                   ||       || spinlock support.</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">KVM_FEATURE_CLOCKSOURCE_STABLE_BIT ||    24 || host will warn if no guest-side</span><br><span class="line">                                   ||       || per-cpu warps are expected in</span><br><span class="line">                                   ||       || kvmclock.</span><br><span class="line">------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-CLOCKSOURCE-amp-KVM-FEATURE-CLOCKSOURCE2"><a href="#KVM-FEATURE-CLOCKSOURCE-amp-KVM-FEATURE-CLOCKSOURCE2" class="headerlink" title="KVM_FEATURE_CLOCKSOURCE &amp; KVM_FEATURE_CLOCKSOURCE2"></a>KVM_FEATURE_CLOCKSOURCE &amp; KVM_FEATURE_CLOCKSOURCE2</h3><p>This feature is used directly when implement <code>kvmclock_init</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvmclock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pvclock_vcpu_time_info</span> *<span class="title">vcpu_time</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mem, mem_wall_clock;</span><br><span class="line">	<span class="keyword">int</span> size, cpu, wall_clock_size;</span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	size = PAGE_ALIGN(<span class="keyword">sizeof</span>(struct pvclock_vsyscall_time_info)*NR_CPUS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvmclock &amp;&amp; kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) &#123;</span><br><span class="line">		msr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;</span><br><span class="line">		msr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(kvmclock &amp;&amp; kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-NOP-IO-DELAY"><a href="#KVM-FEATURE-NOP-IO-DELAY" class="headerlink" title="KVM_FEATURE_NOP_IO_DELAY"></a>KVM_FEATURE_NOP_IO_DELAY</h3><p>During guest init, paravirt_ops_setup will use this feature:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_guest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	paravirt_ops_setup();</span><br></pre></td></tr></table></figure>

<p>which changes <code>io_delay</code> of paravirt cpu ops to <code>kvm_io_delay</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">paravirt_ops_setup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pv_info.name = <span class="string">&quot;KVM&quot;</span>;</span><br><span class="line">	pv_info.paravirt_enabled = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_NOP_IO_DELAY))</span><br><span class="line">		pv_cpu_ops.io_delay = kvm_io_delay;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_IO_APIC</span></span><br><span class="line">	no_timer_check = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which just means without any io delay:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * No need for any &quot;IO delay&quot; on KVM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_io_delay</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-MMU-OP"><a href="#KVM-FEATURE-MMU-OP" class="headerlink" title="KVM_FEATURE_MMU_OP"></a>KVM_FEATURE_MMU_OP</h3><p>Deprecated.</p>
<h3 id="KVM-FEATURE-ASYNC-PF"><a href="#KVM-FEATURE-ASYNC-PF" class="headerlink" title="KVM_FEATURE_ASYNC_PF"></a>KVM_FEATURE_ASYNC_PF</h3><p>When init kvm guest:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_guest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF))</span><br><span class="line">		x86_init.irqs.trap_init = kvm_apf_trap_init;</span><br></pre></td></tr></table></figure>

<p><code>kvm_apf_trap_init</code> will be set to <code>x86_init.irqs.trap_init</code> which will set <code>async_page_fault</code> when interrupt request for trap operations:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">kvm_apf_trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_intr_gate(<span class="number">14</span>, async_page_fault);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then when init kvm guest cpu, will manually enable cpu to allow to write async page fault:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_guest_cpu_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF) &amp;&amp; kvmapf) &#123;</span><br><span class="line">		u64 pa = slow_virt_to_phys(this_cpu_ptr(&amp;apf_reason));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">		pa |= KVM_ASYNC_PF_SEND_ALWAYS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		wrmsrl(MSR_KVM_ASYNC_PF_EN, pa | KVM_ASYNC_PF_ENABLED);</span><br><span class="line">		__this_cpu_write(apf_reason.enabled, <span class="number">1</span>);</span><br><span class="line">		printk(KERN_INFO<span class="string">&quot;KVM setup async PF for cpu %d\n&quot;</span>,</span><br><span class="line">		       smp_processor_id());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Then feature will enable async PF for this cpu.</p>
<p>Note: trap initialize will be done by <code>arch/x86/kernel/traps.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EISA</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *p = early_ioremap(<span class="number">0x0FFFD9</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (readl(p) == <span class="string">&#x27;E&#x27;</span> + (<span class="string">&#x27;I&#x27;</span>&lt;&lt;<span class="number">8</span>) + (<span class="string">&#x27;S&#x27;</span>&lt;&lt;<span class="number">16</span>) + (<span class="string">&#x27;A&#x27;</span>&lt;&lt;<span class="number">24</span>))</span><br><span class="line">		EISA_bus = <span class="number">1</span>;</span><br><span class="line">	early_iounmap(p, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	set_intr_gate(X86_TRAP_DE, divide_error);</span><br><span class="line">	set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);</span><br><span class="line">	<span class="comment">/* int4 can be called from all */</span></span><br><span class="line">	set_system_intr_gate(X86_TRAP_OF, &amp;overflow);</span><br><span class="line">	set_intr_gate(X86_TRAP_BR, bounds);</span><br><span class="line">	set_intr_gate(X86_TRAP_UD, invalid_op);</span><br><span class="line">	set_intr_gate(X86_TRAP_NM, device_not_available);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	set_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);</span><br><span class="line">	set_intr_gate(X86_TRAP_TS, invalid_TSS);</span><br><span class="line">	set_intr_gate(X86_TRAP_NP, segment_not_present);</span><br><span class="line">	set_intr_gate(X86_TRAP_SS, stack_segment);</span><br><span class="line">	set_intr_gate(X86_TRAP_GP, general_protection);</span><br><span class="line">	set_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);</span><br><span class="line">	set_intr_gate(X86_TRAP_MF, coprocessor_error);</span><br><span class="line">	set_intr_gate(X86_TRAP_AC, alignment_check);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_MCE</span></span><br><span class="line">	set_intr_gate_ist(X86_TRAP_MC, &amp;machine_check, MCE_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_intr_gate(X86_TRAP_XF, simd_coprocessor_error);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reserve all the builtin and the syscall vector: */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FIRST_EXTERNAL_VECTOR; i++)</span><br><span class="line">		set_bit(i, used_vectors);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IA32_EMULATION</span></span><br><span class="line">	set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);</span><br><span class="line">	set_bit(IA32_SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</span><br><span class="line">	set_bit(SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set the IDT descriptor to a fixed read-only location, so that the</span></span><br><span class="line"><span class="comment">	 * &quot;sidt&quot; instruction will not leak the location of the kernel, and</span></span><br><span class="line"><span class="comment">	 * to defend the IDT against arbitrary memory write vulnerabilities.</span></span><br><span class="line"><span class="comment">	 * It will be reloaded in cpu_init() */</span></span><br><span class="line">	__set_fixmap(FIX_RO_IDT, __pa_symbol(idt_table), PAGE_KERNEL_RO);</span><br><span class="line">	idt_descr.address = fix_to_virt(FIX_RO_IDT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Should be a barrier for any external CPU state:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu_init();</span><br><span class="line"></span><br><span class="line">	x86_init.irqs.trap_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;debug_idt_table, &amp;idt_table, IDT_ENTRIES * <span class="number">16</span>);</span><br><span class="line">	set_nmi_gate(X86_TRAP_DB, &amp;debug);</span><br><span class="line">	set_nmi_gate(X86_TRAP_BP, &amp;int3);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and <code>x86_init.irqs.trap_init();</code> will be used post other features.    </p>
<h3 id="KVM-FEATURE-STEAL-TIME"><a href="#KVM-FEATURE-STEAL-TIME" class="headerlink" title="KVM_FEATURE_STEAL_TIME"></a>KVM_FEATURE_STEAL_TIME</h3><p>when do kvm guest init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) &#123;</span><br><span class="line">	has_steal_clock = <span class="number">1</span>;</span><br><span class="line">	pv_time_ops.steal_clock = kvm_steal_clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Paravirt steal lock will be replaced by kvm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">kvm_steal_clock</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 steal;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_steal_time</span> *<span class="title">src</span>;</span></span><br><span class="line">	<span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">	src = &amp;per_cpu(steal_time, cpu);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		version = src-&gt;version;</span><br><span class="line">		rmb();</span><br><span class="line">		steal = src-&gt;steal;</span><br><span class="line">		rmb();</span><br><span class="line">	&#125; <span class="keyword">while</span> ((version &amp; <span class="number">1</span>) || (version != src-&gt;version));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> steal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which will steal the time from cpu directly.</p>
<h3 id="KVM-FEATURE-PV-EOI"><a href="#KVM-FEATURE-PV-EOI" class="headerlink" title="KVM_FEATURE_PV_EOI"></a>KVM_FEATURE_PV_EOI</h3><p>From kvm guest init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">	apic_set_eoi_write(kvm_guest_apic_eoi_write);</span><br></pre></td></tr></table></figure>

<p>During kvm guest cpu init:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI)) &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pa;</span><br><span class="line">	<span class="comment">/* Size alignment is implied but just to make it explicit. */</span></span><br><span class="line">	BUILD_BUG_ON(__alignof__(kvm_apic_eoi) &lt; <span class="number">4</span>);</span><br><span class="line">	__this_cpu_write(kvm_apic_eoi, <span class="number">0</span>);</span><br><span class="line">	pa = slow_virt_to_phys(this_cpu_ptr(&amp;kvm_apic_eoi))</span><br><span class="line">		| KVM_MSR_ENABLED;</span><br><span class="line">	wrmsrl(MSR_KVM_PV_EOI_EN, pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Besides, those paravirt kvm features is used by kernel so those features need to be disabled if kernel changed, for example, load kernel by kexec, to avoid the features pointing to old memory of old kernel, those features will disabled by write msr manually:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_pv_guest_cpu_reboot</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We disable PV EOI before we load a new kernel by kexec,</span></span><br><span class="line"><span class="comment">	 * since MSR_KVM_PV_EOI_EN stores a pointer into old kernel&#x27;s memory.</span></span><br><span class="line"><span class="comment">	 * New kernel can re-enable when it boots.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">		wrmsrl(MSR_KVM_PV_EOI_EN, <span class="number">0</span>);</span><br><span class="line">	kvm_pv_disable_apf();</span><br><span class="line">	kvm_disable_steal_time();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So does kvm guest cpu offline do:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_guest_cpu_offline</span><span class="params">(<span class="keyword">void</span> *dummy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	kvm_disable_steal_time();</span><br><span class="line">	<span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">		wrmsrl(MSR_KVM_PV_EOI_EN, <span class="number">0</span>);</span><br><span class="line">	kvm_pv_disable_apf();</span><br><span class="line">	apf_task_wake_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s all due to paravirt use shared memory to use those features between guest and host.</p>
<h3 id="KVM-FEATURE-PV-UNHALT"><a href="#KVM-FEATURE-PV-UNHALT" class="headerlink" title="KVM_FEATURE_PV_UNHALT"></a>KVM_FEATURE_PV_UNHALT</h3><p>Allow to use para-virtualized spinlock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">kvm_spinlock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/* Does host kernel support KVM_FEATURE_PV_UNHALT? */</span></span><br><span class="line">	<span class="keyword">if</span> (!kvm_para_has_feature(KVM_FEATURE_PV_UNHALT))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="KVM-FEATURE-CLOCKSOURCE-STABLE-BIT"><a href="#KVM-FEATURE-CLOCKSOURCE-STABLE-BIT" class="headerlink" title="KVM_FEATURE_CLOCKSOURCE_STABLE_BIT"></a>KVM_FEATURE_CLOCKSOURCE_STABLE_BIT</h3><p>kvm clock will set a <code>PVCLOCK_TSC_STABLE_BIT</code> to pvclock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_INFO <span class="string">&quot;kvm-clock: Using msrs %x and %x&quot;</span>,</span><br><span class="line">       msr_kvm_system_time, msr_kvm_wall_clock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))</span><br><span class="line">	pvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);</span><br></pre></td></tr></table></figure>

<p>when stable source detected:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u64 <span class="title">pvclock_clocksource_read</span><span class="params">(struct pvclock_vcpu_time_info *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> version;</span><br><span class="line">	u64 ret;</span><br><span class="line">	u64 last;</span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		version = pvclock_read_begin(src);</span><br><span class="line">		ret = __pvclock_read_cycles(src, rdtsc_ordered());</span><br><span class="line">		flags = src-&gt;flags;</span><br><span class="line">	&#125; <span class="keyword">while</span> (pvclock_read_retry(src, version));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely((flags &amp; PVCLOCK_GUEST_STOPPED) != <span class="number">0</span>)) &#123;</span><br><span class="line">		src-&gt;flags &amp;= ~PVCLOCK_GUEST_STOPPED;</span><br><span class="line">		pvclock_touch_watchdogs();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((valid_flags &amp; PVCLOCK_TSC_STABLE_BIT) &amp;&amp;</span><br><span class="line">		(flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>

<p>clocksource read will return directly.</p>
<h4 id="Hyper-v-impact"><a href="#Hyper-v-impact" class="headerlink" title="Hyper-v impact"></a>Hyper-v impact</h4><p>linux will converting hyperv and kvmclock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compute_tsc_page_parameters</span><span class="params">(struct pvclock_vcpu_time_info *hv_clock,</span></span></span><br><span class="line"><span class="function"><span class="params">					HV_REFERENCE_TSC_PAGE *tsc_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 max_mul;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(hv_clock-&gt;flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>but if no stable tsc allowed, hypervclock and kvmclock computing will be skipped.</p>
<p>Function chain as following:</p>
<p><code>kvm_guest_time_update</code> -&gt; <code>kvm_hv_setup_tsc_page</code> -&gt; <code>compute_tsc_page_parameters</code></p>
<p>And source is from kvm request:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) &#123;</span><br><span class="line">	r = kvm_guest_time_update(vcpu);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(r))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to know more about <code>KVM_REQ_CLOCK_UPDATE</code> to figure out when. this request will be used.</p>
<p>The clue is <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code> make request usage.</p>
<ul>
<li><p>Ioctl kvm clock set -&gt; <code>KVM_SET_CLOCK</code> -&gt;  <code>kvm_gen_update_masterclock</code> </p>
</li>
<li><p><code>kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu)</code> -&gt;  <code>kvm_gen_update_masterclock</code> </p>
</li>
<li><p><code>kvm_guest_time_update</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code><br>first update is from kvm request:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) &#123;</span><br><span class="line">	r = kvm_guest_time_update(vcpu);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(r))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>then interrupt will be disabled to prevent clock changes:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keep irq disabled to prevent changes to the clock */</span></span><br><span class="line">local_irq_save(flags);</span><br><span class="line">this_tsc_khz = __this_cpu_read(cpu_tsc_khz);</span><br><span class="line"><span class="keyword">if</span> (unlikely(this_tsc_khz == <span class="number">0</span>)) &#123;</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>INIT_DELAYED_WORK(&amp;kvm-&gt;arch.kvmclock_update_work, kvmclock_update_fn);</code> -&gt; <code>kvmclock_update_fn</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code><br>kvm lock will be updated by a schedule:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kvmclock updates which are isolated to a given vcpu, such as</span></span><br><span class="line"><span class="comment"> * vcpu-&gt;cpu migration, should not allow system_timestamp from</span></span><br><span class="line"><span class="comment"> * the rest of the vcpus to remain static. Otherwise ntp frequency</span></span><br><span class="line"><span class="comment"> * correction applies to one vcpu&#x27;s system_timestamp but not</span></span><br><span class="line"><span class="comment"> * the others.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So in those cases, request a kvmclock update for all vcpus.</span></span><br><span class="line"><span class="comment"> * We need to rate-limit these requests though, as they can</span></span><br><span class="line"><span class="comment"> * considerably slow guests that have a large number of vcpus.</span></span><br><span class="line"><span class="comment"> * The time for a remote vcpu to update its kvmclock is bound</span></span><br><span class="line"><span class="comment"> * by the delay we use to rate-limit the updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)</span></span><br></pre></td></tr></table></figure>

<p>and kvmlock sync delays are</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVMCLOCK_SYNC_PERIOD (300 * HZ)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu)</code> -&gt;  <code>kvm_gen_kvmclock_update</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);</code></p>
<ul>
<li><p>MSR_KVM_SYSTEM_TIME</p>
</li>
<li><p>kvm_arch_vcpu_load<br>update clock if no master clock or host cpu to sync.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On a host with synchronized TSC, there is no need to update</span></span><br><span class="line"><span class="comment"> * kvmclock on vcpu-&gt;cpu migration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!vcpu-&gt;kvm-&gt;arch.use_master_clock || vcpu-&gt;cpu == <span class="number">-1</span>)</span><br><span class="line">	kvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);</span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;cpu != cpu)</span><br><span class="line">	kvm_migrate_timers(vcpu);</span><br><span class="line">vcpu-&gt;cpu = cpu;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>kvm_arch_vcpu_load</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>Adjust time if needed</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Apply any externally detected TSC adjustments (due to suspend) */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(vcpu-&gt;arch.tsc_offset_adjustment)) &#123;</span><br><span class="line">	adjust_tsc_offset_host(vcpu, vcpu-&gt;arch.tsc_offset_adjustment);</span><br><span class="line">	vcpu-&gt;arch.tsc_offset_adjustment = <span class="number">0</span>;</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvm_set_guest_paused</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>if guest kernel stopped by hypervisor use this to update pv clock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kvm_set_guest_paused() indicates to the guest kernel that it has been</span></span><br><span class="line"><span class="comment"> * stopped by the hypervisor.  This function will be called from the host only.</span></span><br><span class="line"><span class="comment"> * EINVAL is returned when the host attempts to set the flag for a guest that</span></span><br><span class="line"><span class="comment"> * does not support pv clocks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kvm_set_guest_paused</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!vcpu-&gt;arch.pv_time_enabled)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	vcpu-&gt;arch.pvclock_set_guest_stopped_request = <span class="literal">true</span>;</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>kvmclock_cpufreq_notifier</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>see the annotation from code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We allow guests to temporarily run on slowing clocks,</span></span><br><span class="line"><span class="comment"> * provided we notify them after, or to run on accelerating</span></span><br><span class="line"><span class="comment"> * clocks, provided we notify them before.  Thus time never</span></span><br><span class="line"><span class="comment"> * goes backwards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, we have a problem.  We can&#x27;t atomically update</span></span><br><span class="line"><span class="comment"> * the frequency of a given CPU from this function; it is</span></span><br><span class="line"><span class="comment"> * merely a notifier, which can be called from any CPU.</span></span><br><span class="line"><span class="comment"> * Changing the TSC frequency at arbitrary points in time</span></span><br><span class="line"><span class="comment"> * requires a recomputation of local variables related to</span></span><br><span class="line"><span class="comment"> * the TSC for each VCPU.  We must flag these local variables</span></span><br><span class="line"><span class="comment"> * to be updated and be sure the update takes place with the</span></span><br><span class="line"><span class="comment"> * new frequency before any guests proceed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unfortunately, the combination of hotplug CPU and frequency</span></span><br><span class="line"><span class="comment"> * change creates an intractable locking scenario; the order</span></span><br><span class="line"><span class="comment"> * of when these callouts happen is undefined with respect to</span></span><br><span class="line"><span class="comment"> * CPU hotplug, and they can race with each other.  As such,</span></span><br><span class="line"><span class="comment"> * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is</span></span><br><span class="line"><span class="comment"> * undefined; you can actually have a CPU frequency change take</span></span><br><span class="line"><span class="comment"> * place in between the computation of X and the setting of the</span></span><br><span class="line"><span class="comment"> * variable.  To protect against this problem, all updates of</span></span><br><span class="line"><span class="comment"> * the per_cpu tsc_khz variable are done in an interrupt</span></span><br><span class="line"><span class="comment"> * protected IPI, and all callers wishing to update the value</span></span><br><span class="line"><span class="comment"> * must wait for a synchronous IPI to complete (which is trivial</span></span><br><span class="line"><span class="comment"> * if the caller is on the CPU already).  This establishes the</span></span><br><span class="line"><span class="comment"> * necessary total order on variable updates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that because a guest time update may take place</span></span><br><span class="line"><span class="comment"> * anytime after the setting of the VCPU&#x27;s request bit, the</span></span><br><span class="line"><span class="comment"> * correct TSC value must be set before the request.  However,</span></span><br><span class="line"><span class="comment"> * to ensure the update actually makes it to any guest which</span></span><br><span class="line"><span class="comment"> * starts running in hardware virtualization between the set</span></span><br><span class="line"><span class="comment"> * and the acquisition of the spinlock, we must also ping the</span></span><br><span class="line"><span class="comment"> * CPU after setting the request bit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>after <code>kvm_guest_exit();</code><br>update clock if vcpu request clock always up to date.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(vcpu-&gt;arch.tsc_always_catchup))</span><br><span class="line">	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hardware_enable_nolock</code> -&gt; <code>kvm_arch_hardware_enable</code> -&gt; <code>kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);</code><br>multi functino access hardware_enable_nolock</p>
<ul>
<li><code>kvm_cpu_hotplug</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kvm_cpu_hotplug</span><span class="params">(struct notifier_block *notifier, <span class="keyword">unsigned</span> <span class="keyword">long</span> val,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	val &amp;= ~CPU_TASKS_FROZEN;</span><br><span class="line">	<span class="keyword">switch</span> (val) &#123;</span><br><span class="line">	<span class="keyword">case</span> CPU_DYING:</span><br><span class="line">		hardware_disable();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CPU_STARTING:</span><br><span class="line">		hardware_enable();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kvm_resume</code> </li>
</ul>
</li>
</ul>
<p>Note: for <code>hv_stimer</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * KVM_REQ_HV_STIMER has to be processed after</span></span><br><span class="line"><span class="comment"> * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers</span></span><br><span class="line"><span class="comment"> * depend on the guest clock being up-to-date</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))</span><br><span class="line">	kvm_hv_process_stimers(vcpu);</span><br></pre></td></tr></table></figure>

<p>will be done after guest clock up-to-date.</p>
<h4 id="Hyper-v-impact-conclusion"><a href="#Hyper-v-impact-conclusion" class="headerlink" title="Hyper-v impact conclusion"></a>Hyper-v impact conclusion</h4><p>With kvm hidden, hyper-v tsc compute will be skipped:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compute_tsc_page_parameters</span><span class="params">(struct pvclock_vcpu_time_info *hv_clock,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct ms_hyperv_tsc_page *tsc_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 max_mul;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(hv_clock-&gt;flags &amp; PVCLOCK_TSC_STABLE_BIT))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>which can be triggered by above kvm code.</p>
<p>During migration, we know that guest will be stopped (paused) by <code>KVM_KVMCLOCK_CTRL</code> and we could check kvm userspace’s (qemu) usage:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvmclock_vm_state_change</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> running,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     RunState state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KVMClockState *s = opaque;</span><br><span class="line">    CPUState *cpu;</span><br><span class="line">    <span class="keyword">int</span> cap_clock_ctrl = kvm_check_extension(kvm_state, KVM_CAP_KVMCLOCK_CTRL);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">data</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the host where s-&gt;clock was read did not support reliable</span></span><br><span class="line"><span class="comment">         * KVM_GET_CLOCK, read kvmclock value from memory.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;clock_is_reliable) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> pvclock_via_mem = kvmclock_current_nsec(s);</span><br><span class="line">            <span class="comment">/* We can&#x27;t rely on the saved clock value, just discard it */</span></span><br><span class="line">            <span class="keyword">if</span> (pvclock_via_mem) &#123;</span><br><span class="line">                s-&gt;clock = pvclock_via_mem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s-&gt;clock_valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        data.clock = s-&gt;clock;</span><br><span class="line">        ret = kvm_vm_ioctl(kvm_state, KVM_SET_CLOCK, &amp;data);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;KVM_SET_CLOCK failed: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cap_clock_ctrl) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CPU_FOREACH(cpu) &#123;</span><br><span class="line">            run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;clock_valid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s-&gt;runstate_paused = runstate_check(RUN_STATE_PAUSED);</span><br><span class="line"></span><br><span class="line">        kvm_synchronize_all_tsc();</span><br><span class="line"></span><br><span class="line">        kvm_update_clock(s);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the VM is stopped, declare the clock state valid to</span></span><br><span class="line"><span class="comment">         * avoid re-reading it on next vmsave (which would return</span></span><br><span class="line"><span class="comment">         * a different value). Will be reset when the VM is continued.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s-&gt;clock_valid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>when set guest to running, qemu will use <code>KVM_SET_CLOCK</code> else will use <code>kvm_update_clock</code>  works as following:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_update_clock</span><span class="params">(KVMClockState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &amp;data);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;KVM_GET_CLOCK failed: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;clock = data.clock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If kvm_has_adjust_clock_stable() is false, KVM_GET_CLOCK returns</span></span><br><span class="line"><span class="comment">     * essentially CLOCK_MONOTONIC plus a guest-specific adjustment.  This</span></span><br><span class="line"><span class="comment">     * can drift from the TSC-based value that is computed by the guest,</span></span><br><span class="line"><span class="comment">     * so we need to go through kvmclock_current_nsec().  If</span></span><br><span class="line"><span class="comment">     * kvm_has_adjust_clock_stable() is true, and the flags contain</span></span><br><span class="line"><span class="comment">     * KVM_CLOCK_TSC_STABLE, then KVM_GET_CLOCK returns a TSC-based value</span></span><br><span class="line"><span class="comment">     * and kvmclock_current_nsec() is not necessary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here, however, we need not check KVM_CLOCK_TSC_STABLE.  This is because:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if the host has disabled the kvmclock master clock, the guest already</span></span><br><span class="line"><span class="comment">     *   has protection against time going backwards.  This &quot;safety net&quot; is only</span></span><br><span class="line"><span class="comment">     *   absent when kvmclock is stable;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - therefore, we can replace a check like</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if last KVM_GET_CLOCK was not reliable then</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   with</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if last KVM_GET_CLOCK was not reliable &amp;&amp; masterclock is enabled</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * However:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if kvm_has_adjust_clock_stable() returns false, the left side is</span></span><br><span class="line"><span class="comment">     *   always true (KVM_GET_CLOCK is never reliable), and the right side is</span></span><br><span class="line"><span class="comment">     *   unknown (because we don&#x27;t have data.flags).  We must assume it&#x27;s true</span></span><br><span class="line"><span class="comment">     *   and read from memory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - if kvm_has_adjust_clock_stable() returns true, the result of the &amp;&amp;</span></span><br><span class="line"><span class="comment">     *   is always false (masterclock is enabled iff KVM_GET_CLOCK is reliable)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So we can just use this instead:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       if !kvm_has_adjust_clock_stable() then</span></span><br><span class="line"><span class="comment">     *               read from memory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s-&gt;clock_is_reliable = kvm_has_adjust_clock_stable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But from the annotation in <code>kvmclock_vm_state_change</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the VM is stopped, declare the clock state valid to</span></span><br><span class="line"><span class="comment"> * avoid re-reading it on next vmsave (which would return</span></span><br><span class="line"><span class="comment"> * a different value). Will be reset when the VM is continued.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>qemu seems to relay on vmsave to reset the guest while vm is continued, we just keep our eyes on that.</p>
<p>Combine qemu guest state change hook:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_SET_CLOCK: &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_arch</span> *<span class="title">ka</span> =</span> &amp;kvm-&gt;arch;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_clock_data</span> <span class="title">user_ns</span>;</span></span><br><span class="line">	u64 now_ns;</span><br><span class="line"></span><br><span class="line">	r = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;user_ns, argp, <span class="keyword">sizeof</span>(user_ns)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	r = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (user_ns.flags)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	r = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">TODO:</span> userspace has to take care of races with VCPU_RUN, so</span></span><br><span class="line"><span class="comment">	 * kvm_gen_update_masterclock() can be cut down to locked</span></span><br><span class="line"><span class="comment">	 * pvclock_update_vm_gtod_copy().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kvm_gen_update_masterclock(kvm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This pairs with kvm_guest_time_update(): when masterclock is</span></span><br><span class="line"><span class="comment">	 * in use, we use master_kernel_ns + kvmclock_offset to set</span></span><br><span class="line"><span class="comment">	 * unsigned &#x27;system_time&#x27; so if we use get_kvmclock_ns() (which</span></span><br><span class="line"><span class="comment">	 * is slightly ahead) here we risk going negative on unsigned</span></span><br><span class="line"><span class="comment">	 * &#x27;system_time&#x27; when &#x27;user_ns.clock&#x27; is very small.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_lock_irq(&amp;ka-&gt;pvclock_gtod_sync_lock);</span><br><span class="line">	<span class="keyword">if</span> (kvm-&gt;arch.use_master_clock)</span><br><span class="line">		now_ns = ka-&gt;master_kernel_ns;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		now_ns = get_kvmclock_base_ns();</span><br><span class="line">	ka-&gt;kvmclock_offset = user_ns.clock - now_ns;</span><br><span class="line">	spin_unlock_irq(&amp;ka-&gt;pvclock_gtod_sync_lock);</span><br><span class="line"></span><br><span class="line">	kvm_make_all_cpus_request(kvm, KVM_REQ_CLOCK_UPDATE);</span><br></pre></td></tr></table></figure>

<p>will be used to update guest clock.</p>
<h2 id="Hand-on-test-to-confirm-clock-updates"><a href="#Hand-on-test-to-confirm-clock-updates" class="headerlink" title="Hand on test to confirm clock updates"></a>Hand on test to confirm clock updates</h2><p>Enable kvm trace by:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/kernel/debug/tracing/events/kvm/enable</span><br></pre></td></tr></table></figure>

<p>Then collect the output when vm migrated to this host:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/kernel/debug/tracing/trace_pipe &gt; trace_migrated_vm</span><br></pre></td></tr></table></figure>

<p>We can see following logs at first:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;<span class="number">-89383</span> [<span class="number">001</span>] .... <span class="number">97852.765277</span>: kvm_update_master_clock: masterclock <span class="number">0</span> hostclock <span class="number">0x2</span> offsetmatched <span class="number">0</span></span><br><span class="line">&lt;...&gt;<span class="number">-89441</span> [<span class="number">002</span>] d... <span class="number">97852.785366</span>: kvm_write_tsc_offset: vcpu=<span class="number">0</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89441</span> [<span class="number">002</span>] d... <span class="number">97852.785402</span>: kvm_track_tsc: vcpu_id <span class="number">0</span> masterclock <span class="number">0</span> offsetmatched <span class="number">0</span> nr_online <span class="number">1</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89442</span> [<span class="number">002</span>] d... <span class="number">97852.786522</span>: kvm_write_tsc_offset: vcpu=<span class="number">1</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89442</span> [<span class="number">002</span>] d... <span class="number">97852.786533</span>: kvm_track_tsc: vcpu_id <span class="number">1</span> masterclock <span class="number">0</span> offsetmatched <span class="number">1</span> nr_online <span class="number">2</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89443</span> [<span class="number">002</span>] d... <span class="number">97852.787341</span>: kvm_write_tsc_offset: vcpu=<span class="number">2</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89443</span> [<span class="number">002</span>] d... <span class="number">97852.787348</span>: kvm_track_tsc: vcpu_id <span class="number">2</span> masterclock <span class="number">0</span> offsetmatched <span class="number">2</span> nr_online <span class="number">3</span> hostclock <span class="number">0x2</span></span><br><span class="line">&lt;...&gt;<span class="number">-89444</span> [<span class="number">002</span>] d... <span class="number">97852.788099</span>: kvm_write_tsc_offset: vcpu=<span class="number">3</span> prev=<span class="number">0</span> next=<span class="number">18446539041810541506</span></span><br><span class="line">&lt;...&gt;<span class="number">-89444</span> [<span class="number">002</span>] d... <span class="number">97852.788120</span>: kvm_track_tsc: vcpu_id <span class="number">3</span> masterclock <span class="number">0</span> offsetmatched <span class="number">3</span> nr_online <span class="number">4</span> hostclock <span class="number">0x2</span></span><br></pre></td></tr></table></figure>

<p><code>kvm_update_master_clock</code> is used for vm migration:</p>
<p>And the tsc offset changed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-89441 [002] d... 97852.785366: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89441 [002] d... 97852.785402: kvm_track_tsc: vcpu_id 0 masterclock 0 offsetmatched 0 nr_online 1 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89442 [002] d... 97852.786522: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89442 [002] d... 97852.786533: kvm_track_tsc: vcpu_id 1 masterclock 0 offsetmatched 1 nr_online 2 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89443 [002] d... 97852.787341: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89443 [002] d... 97852.787348: kvm_track_tsc: vcpu_id 2 masterclock 0 offsetmatched 2 nr_online 3 hostclock 0x2</span><br><span class="line">&lt;...&gt;-89444 [002] d... 97852.788099: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;0 next&#x3D;18446539041810541506</span><br><span class="line"></span><br><span class="line">&lt;...&gt;-89441 [003] d... 97852.872014: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89442 [003] d... 97852.872105: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89443 [003] d... 97852.872189: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line">&lt;...&gt;-89444 [003] d... 97852.872264: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;18446539041810541506 next&#x3D;18446539041810541506</span><br><span class="line"></span><br><span class="line">&lt;...&gt;-89441 [000] d... 97856.399432: kvm_write_tsc_offset: vcpu&#x3D;0 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89442 [000] d... 97856.403066: kvm_write_tsc_offset: vcpu&#x3D;1 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89443 [000] d... 97856.403273: kvm_write_tsc_offset: vcpu&#x3D;2 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br><span class="line">&lt;...&gt;-89444 [000] d... 97856.403414: kvm_write_tsc_offset: vcpu&#x3D;3 prev&#x3D;18446539041810541506 next&#x3D;18446562414330701094</span><br></pre></td></tr></table></figure>

<p>Follow the trace we can find linux kernel code:</p>
<p><code>kvm_vcpu_write_tsc_offset</code> -&gt; <code>kvm_x86_write_l1_tsc_offset</code> -&gt;  <code>write_l1_tsc_offset</code> -&gt; <code>vmx_write_l1_tsc_offset</code> -&gt; <code>trace_kvm_write_tsc_offset</code></p>
<p>And there are multi usages of <code>kvm_vcpu_write_tsc_offset</code></p>
<ul>
<li><code>kvm_synchronize_tsc</code><ul>
<li><code>MSR_IA32_TSC</code> -&gt; <code>kvm_synchronize_tsc</code></li>
<li><code>kvm_vm_ioctl_create_vcpu</code> -&gt; <code>kvm_arch_vcpu_postcreate</code> -&gt; <code>kvm_synchronize_tsc</code></li>
</ul>
</li>
<li><code>adjust_tsc_offset_guest</code><ul>
<li><code>kvm_guest_time_update</code> -&gt; <code>adjust_tsc_offset_guest</code> and <code>kvm_hv_setup_tsc_page</code> this is hyper-v impacted case</li>
<li><code>MSR_IA32_TSC</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
<li><code>MSR_IA32_TSC_ADJUST</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
<li><code>kvm_arch_vcpu_load</code> -&gt; <code>adjust_tsc_offset_host</code> -&gt; <code>adjust_tsc_offset_guest</code></li>
</ul>
</li>
<li><code>kvm_arch_vcpu_load</code> same as above</li>
</ul>
<p>So the following three parts of <code>kvm_vcpu_write_tsc_offset</code> matches with guest creation.</p>
<ul>
<li>Create vcpu</li>
<li>Load vcpu</li>
<li>Adjust tsc offset</li>
</ul>
<p>In last guest hang post, we can see windows guest try to get counter ref:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_time_ref_counter</span><span class="params">(struct kvm *kvm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_hv</span> *<span class="title">hv</span> =</span> to_kvm_hv(kvm);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span>;</span></span><br><span class="line">	u64 tsc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fall back to get_kvmclock_ns() when TSC page hasn&#x27;t been set up,</span></span><br><span class="line"><span class="comment">	 * is broken, disabled or being updated.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (hv-&gt;hv_tsc_page_status != HV_TSC_PAGE_SET)</span><br><span class="line">		<span class="keyword">return</span> div_u64(get_kvmclock_ns(kvm), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	vcpu = kvm_get_vcpu(kvm, <span class="number">0</span>);</span><br><span class="line">	tsc = kvm_read_l1_tsc(vcpu, rdtsc());</span><br><span class="line">	<span class="keyword">return</span> mul_u64_u64_shr(tsc, hv-&gt;tsc_ref.tsc_scale, <span class="number">64</span>)</span><br><span class="line">		+ hv-&gt;tsc_ref.tsc_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But this is used by MSR read request from guest. And now we need to debug <code>hv_tsc_page_status</code> and <code>kvm_hv_setup_tsc_page</code> usage.</p>
<p>Without kvm hidden:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114210 [002] d... 12255.411580: kvm_exit: vcpu 1 reason MSR_READ rip 0xfffff800ece454c5 info1 0x0000000000000000 info2 0x0000000000000000 intr_info 0x00000000 error_code 0x00000000</span><br><span class="line">&lt;...&gt;-114210 [002] .... 12255.411581: kvm_msr: msr_read 40000020 &#x3D; 0x6fac3c27</span><br><span class="line">&lt;...&gt;-114210 [002] d... 12255.411582: kvm_entry: vcpu 1, rip 0xfffff800ece454c7</span><br><span class="line">&lt;...&gt;-114211 [000] .... 12255.411585: kvm_vcpu_wakeup: wait time 1759974 ns, polling valid</span><br><span class="line">&lt;...&gt;-114211 [000] .... 12255.411585: kvm_hv_timer_state: vcpu_id 2 hv_timer 0</span><br></pre></td></tr></table></figure>

<p>We can find <code>kvm_hv_timer_state</code> in trace, and according to linux kernel code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRACE_EVENT(kvm_hv_timer_state,</span><br><span class="line">		TP_PROTO(<span class="keyword">unsigned</span> <span class="keyword">int</span> vcpu_id, <span class="keyword">unsigned</span> <span class="keyword">int</span> hv_timer_in_use),</span><br></pre></td></tr></table></figure>

<p>There are two ways to show the trace:</p>
<ul>
<li><code>start_sw_timer</code> -&gt; <code>trace_kvm_hv_timer_state(apic-&gt;vcpu-&gt;vcpu_id, false);</code> which is always false (means 0 in trace)</li>
<li><code>start_hv_timer</code> -&gt; <code>trace_kvm_hv_timer_state(vcpu-&gt;vcpu_id, ktimer-&gt;hv_timer_in_use);</code> which returns <code>hv_timer_in_use</code> from  <code>ktimer-&gt;hv_timer_in_use</code></li>
</ul>
<p>Check the code about <code>start_hv_timer</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_hv_timer</span><span class="params">(struct kvm_lapic *apic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_timer</span> *<span class="title">ktimer</span> =</span> &amp;apic-&gt;lapic_timer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> =</span> apic-&gt;vcpu;</span><br><span class="line">	<span class="keyword">bool</span> expired;</span><br><span class="line"></span><br><span class="line">	WARN_ON(preemptible());</span><br><span class="line">	<span class="keyword">if</span> (!kvm_can_use_hv_timer(vcpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ktimer-&gt;tscdeadline)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (static_call(kvm_x86_set_hv_timer)(vcpu, ktimer-&gt;tscdeadline, &amp;expired))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	ktimer-&gt;hv_timer_in_use = <span class="literal">true</span>;</span><br><span class="line">	hrtimer_cancel(&amp;ktimer-&gt;timer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * To simplify handling the periodic timer, leave the hv timer running</span></span><br><span class="line"><span class="comment">	 * even if the deadline timer has expired, i.e. rely on the resulting</span></span><br><span class="line"><span class="comment">	 * VM-Exit to recompute the periodic timer&#x27;s target expiration.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!apic_lvtt_period(apic)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Cancel the hv timer if the sw timer fired while the hv timer</span></span><br><span class="line"><span class="comment">		 * was being programmed, or if the hv timer itself expired.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (atomic_read(&amp;ktimer-&gt;pending)) &#123;</span><br><span class="line">			cancel_hv_timer(apic);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (expired) &#123;</span><br><span class="line">			apic_timer_expired(apic, <span class="literal">false</span>);</span><br><span class="line">			cancel_hv_timer(apic);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_kvm_hv_timer_state(vcpu-&gt;vcpu_id, ktimer-&gt;hv_timer_in_use);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ktimer-&gt;hv_timer_in_use</code> is set to <code>true</code> so we focus on <code>start_sw_timer</code> next.</p>
<p>There are several ways to goes into <code>restart_apic_timer</code></p>
<ul>
<li><code>restart_apic_timer</code> -&gt; <code>start_sw_timer</code><ul>
<li><code>vmx_exit_handlers_fastpath</code> or <code>__vmx_handle_exit</code> -&gt; <code> handle_fastpath_preemption_timer</code> -&gt; <code>kvm_lapic_expired_hv_timer</code>  -&gt; <code>restart_apic_timer</code></li>
<li><code>vcpu_block</code> -&gt; <code>post_block</code> -&gt; <code>vmx_post_block</code> -&gt;  <code>kvm_lapic_switch_to_hv_timer</code> -&gt; <code>restart_apic_timer</code></li>
<li><code>MSR_IA32_TSC_DEADLINE</code> -&gt;<code>handle_fastpath_set_tscdeadline</code> -&gt; <code>kvm_set_lapic_tscdeadline_msr</code> -&gt;  <code>__start_apic_timer</code> -&gt; <code>restart_apic_timer</code></li>
<li><code>APIC_TDCR</code> -&gt; <code>restart_apic_timer</code> </li>
</ul>
</li>
<li><code>vcpu_block</code> -&gt;  <code>vmx_pre_block</code> -&gt; <code>kvm_lapic_switch_to_sw_timer</code> -&gt; <code>start_sw_timer</code></li>
</ul>
<p>Because we see a trace before shows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kvm_vcpu_wakeup: wait time 1759974 ns, polling valid</span><br></pre></td></tr></table></figure>

<p>which is in kvm_vcpu_block, so this means vmx_post_block <code>restart_apic_timer</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trace_kvm_vcpu_wakeup(block_ns, waited, vcpu_valid_wakeup(vcpu));</span><br><span class="line">kvm_arch_vcpu_block_finish(vcpu);</span><br></pre></td></tr></table></figure>

<p>And because the code runs as:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!start_hv_timer(apic))</span><br><span class="line">	start_sw_timer(apic);</span><br></pre></td></tr></table></figure>

<p><code>start_hv_timer</code> must returns false:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_hv_timer</span><span class="params">(struct kvm_lapic *apic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_timer</span> *<span class="title">ktimer</span> =</span> &amp;apic-&gt;lapic_timer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> =</span> apic-&gt;vcpu;</span><br><span class="line">	<span class="keyword">bool</span> expired;</span><br><span class="line"></span><br><span class="line">	WARN_ON(preemptible());</span><br><span class="line">	<span class="keyword">if</span> (!kvm_can_use_hv_timer(vcpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ktimer-&gt;tscdeadline)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (static_call(kvm_x86_set_hv_timer)(vcpu, ktimer-&gt;tscdeadline, &amp;expired))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><code>kvm_can_use_hv_timer</code> check seems works on x86 machine and while <code>X86_FEATURE_MWAIT</code> is supported.</p>
<p>From the trace we could know, when vcpu exit and come back to work, the timer will be updated, and use vcpu 3 as example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114212 [002] d... 12297.437890: kvm_exit: vcpu 3 reason HLT rip 0xfffff800ecc2b36e info1 0x0000000000000000 info2 0x0000000000000000 intr_info 0x00000000 error_code 0x00000000</span><br></pre></td></tr></table></figure>

<p>vcpu 3 HLT and cause kvm_exit.</p>
<p>Then it wakeup after <code>4774180 ns</code>  and hv_timer is traced without usage.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;...&gt;-114212 [002] .... 12255.393408: kvm_vcpu_wakeup: wait time 4774180 ns, polling valid</span><br><span class="line">&lt;...&gt;-114212 [002] .... 12255.393410: kvm_hv_timer_state: vcpu_id 3 hv_timer 0</span><br></pre></td></tr></table></figure>

<p>And hv_timer will be cancelled after live migration:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (apic-&gt;lapic_timer.hv_timer_in_use)</span><br><span class="line">	cancel_hv_timer(apic);</span><br></pre></td></tr></table></figure>

<p>Let’s check hv_timer before migration:</p>
<h2 id="Can-we-resolve-compatibility-issues"><a href="#Can-we-resolve-compatibility-issues" class="headerlink" title="Can we resolve compatibility issues?"></a>Can we resolve compatibility issues?</h2><p>See the code of qemu, it will disable features of FEAT_KVM after all features setup, so we can not manually assign those features:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (l = plus_features; l; l = l-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prop = l-&gt;data;</span><br><span class="line">    object_property_set_bool(OBJECT(cpu), <span class="literal">true</span>, prop, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (l = minus_features; l; l = l-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prop = l-&gt;data;</span><br><span class="line">    object_property_set_bool(OBJECT(cpu), <span class="literal">false</span>, prop, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/09/cpu-features-about-kvm-hidden/" data-id="clf6xo0140000ibwb0fajc90n" data-title="Cpu features about kvm hidden" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/09/cpu-features-about-kvm-hidden/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/09/cpu-features-about-kvm-hidden/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-virtio-on-linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/03/virtio-on-linux/" class="article-date">
  <time class="dt-published" datetime="2023-03-03T14:38:09.000Z" itemprop="datePublished">2023-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>►<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/03/virtio-on-linux/">Virtio on Linux</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote>
<p>Virtio is an open standard that defines a protocol for communication between drivers and devices of different types, see Chapter 5 (“Device Types”) of the virtio spec ([<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id2">1]</a>). Originally developed as a standard for paravirtualized devices implemented by a hypervisor, it can be used to interface any compliant device (real or emulated) with a driver.</p>
</blockquote>
<p>Virtio是一个开放的标准，它定义了驱动程序和不同类型的设备之间的通信协议，见virtio规范（[<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id2">1]</a>）的第五章（”设备类型”）。它最初是作为由管理程序实现的准虚拟化设备的标准而开发的，但它可以用来将任何符合要求的设备（真实的或模拟的）与驱动程序连接。</p>
<blockquote>
<p>For illustrative purposes, this document will focus on the common case of a Linux kernel running in a virtual machine and using paravirtualized devices provided by the hypervisor, which exposes them as virtio devices via standard mechanisms such as PCI.</p>
</blockquote>
<p>为了说明问题，本文将重点讨论Linux内核在虚拟机中运行并使用由管理程序提供的准虚拟化设备的常见情况，管理程序通过标准机制（如PCI）将它们暴露为virtio设备。</p>
<h2 id="Device-Driver-communication-virtqueues"><a href="#Device-Driver-communication-virtqueues" class="headerlink" title="Device - Driver communication: virtqueues"></a>Device - Driver communication: virtqueues</h2><blockquote>
<p>Although the virtio devices are really an abstraction layer in the hypervisor, they’re exposed to the guest as if they are physical devices using a specific transport method – PCI, MMIO or CCW – that is orthogonal to the device itself. The virtio spec defines these transport methods in detail, including device discovery, capabilities and interrupt handling.</p>
</blockquote>
<p>尽管virtio设备实际上是管理程序中的一个抽象层，但它们被暴露给客户，就像它们是使用特定的传输方法–PCI、MMIO或CCW–的物理设备一样，这与设备本身是正交的。virtio规范详细定义了这些传输方法，包括设备发现、能力和中断处理。</p>
<blockquote>
<p>The communication between the driver in the guest OS and the device in the hypervisor is done through shared memory (that’s what makes virtio devices so efficient) using specialized data structures called virtqueues, which are actually ring buffers <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#f1">1</a> of buffer descriptors similar to the ones used in a network device:</p>
</blockquote>
<p>客户操作系统中的驱动程序和管理程序中的设备之间的通信是通过共享内存完成的（这就是virtio设备如此高效的原因），使用称为virtqueues的专门数据结构，这实际上是类似于网络设备中使用的缓冲区描述符的环形缓冲区<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#f1">1</a>。</p>
<p>struct <strong>vring_desc</strong></p>
<p>Virtio ring descriptors, 16 bytes long. These can chain together via <strong>next</strong>.</p>
<p><strong>Definition</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct vring_desc &#123;</span><br><span class="line">    __virtio64 addr;</span><br><span class="line">    __virtio32 len;</span><br><span class="line">    __virtio16 flags;</span><br><span class="line">    __virtio16 next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Members</strong></p>
<ul>
<li><p><code>addr</code></p>
<p>buffer address (guest-physical)</p>
</li>
<li><p><code>len</code></p>
<p>buffer length</p>
</li>
<li><p><code>flags</code></p>
<p>descriptor flags</p>
</li>
<li><p><code>next</code></p>
<p>index of the next descriptor in the chain, if the VRING_DESC_F_NEXT flag is set. We chain unused descriptors via this, too.</p>
</li>
</ul>
<blockquote>
<p>All the buffers the descriptors point to are allocated by the guest and used by the host either for reading or for writing but not for both.</p>
<p>Refer to Chapter 2.5 (“Virtqueues”) of the virtio spec ([<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id2">1]</a>) for the reference definitions of virtqueues and “Virtqueues and virtio ring: How the data travels” blog post ([<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#id3">2]</a>) for an illustrated overview of how the host device and the guest driver communicate.</p>
</blockquote>
<p>描述符指向的所有缓冲区都是由guest分配的，并由host用于读取或写入，但不能同时使用。</p>
<p>请参考virtio规范（[1]）的第2.5章（”虚拟队列”），了解虚拟队列的参考定义和 “虚拟队列和virtio环。数据是如何传输的 “博文（[2]），以图文并茂的方式概述了主机设备和客户驱动的通信方式。</p>
<p>The <code>vring_virtqueue</code> struct models a virtqueue, including the ring buffers and management data. Embedded in this struct is the <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.virtqueue"><code>virtqueue</code></a> struct, which is the data structure that’s ultimately used by virtio drivers:</p>
<p>struct <strong>virtqueue</strong></p>
<p>a queue to register buffers for sending or receiving.</p>
<p><strong>Definition</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct virtqueue &#123;</span><br><span class="line">    struct list_head list;</span><br><span class="line">    void (*callback)(struct virtqueue *vq);</span><br><span class="line">    const char *name;</span><br><span class="line">    struct virtio_device *vdev;</span><br><span class="line">    unsigned int index;</span><br><span class="line">    unsigned int num_free;</span><br><span class="line">    unsigned int num_max;</span><br><span class="line">    void *priv;</span><br><span class="line">    bool reset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Members</strong></p>
<ul>
<li><p><code>list</code></p>
<p>the chain of virtqueues for this device</p>
</li>
<li><p><code>callback</code></p>
<p>the function to call when buffers are consumed (can be NULL).</p>
</li>
<li><p><code>name</code></p>
<p>the name of this virtqueue (mainly for debugging)</p>
</li>
<li><p><code>vdev</code></p>
<p>the virtio device this queue was created for.</p>
</li>
<li><p><code>index</code></p>
<p>the zero-based ordinal number for this queue.</p>
</li>
<li><p><code>num_free</code></p>
<p>number of elements we expect to be able to fit.</p>
</li>
<li><p><code>num_max</code></p>
<p>the maximum number of elements supported by the device.</p>
</li>
<li><p><code>priv</code></p>
<p>a pointer for the virtqueue implementation to use.</p>
</li>
<li><p><code>reset</code></p>
<p>vq is in reset state or not.</p>
</li>
</ul>
<p><strong>Description</strong></p>
<blockquote>
<p> A note on <strong>num_free</strong>: with indirect buffers, each buffer needs one element in the queue, otherwise a buffer will need one element per sg element.</p>
<p>The callback function pointed by this struct is triggered when the device has consumed the buffers provided by the driver. More specifically, the trigger will be an interrupt issued by the hypervisor (see <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.vring_interrupt"><code>vring_interrupt()</code></a>). Interrupt request handlers are registered for a virtqueue during the virtqueue setup process (transport-specific).</p>
</blockquote>
<p>关于<strong>num_free</strong>的说明：对于间接缓冲区，每个缓冲区需要队列中的一个元素，否则一个缓冲区将需要每个sg元素的一个元素。</p>
<p>当设备消耗完驱动提供的缓冲区时，这个结构所指向的回调函数会被触发。更具体地说，触发器将是由管理程序发出的中断（见<a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.vring_interrupt"><code>vring_interrupt()</code></a>）。中断请求处理程序是在虚拟队列设置过程中为虚拟队列注册的（特定于传输）。</p>
<p>irqreturn_t <strong>vring_interrupt</strong>(int irq, void *_vq)</p>
<p>notify a virtqueue on an interrupt</p>
<p><strong>Parameters</strong></p>
<ul>
<li><p><code>int irq</code></p>
<p>the IRQ number (ignored)</p>
</li>
<li><p><code>void *_vq</code></p>
<p>the <a target="_blank" rel="noopener" href="https://docs.kernel.org/next/driver-api/virtio/virtio.html#c.virtqueue"><code>struct virtqueue</code></a> to notify</p>
</li>
</ul>
<p><strong>Description</strong></p>
<p>Calls the callback function of <strong>_vq</strong> to process the virtqueue notification.</p>
<h2 id="Device-discovery-and-probing"><a href="#Device-discovery-and-probing" class="headerlink" title="Device discovery and probing"></a>Device discovery and probing</h2><blockquote>
<p>In the kernel, the virtio core contains the virtio bus driver and transport-specific drivers like virtio-pci and virtio-mmio. Then there are individual virtio drivers for specific device types that are registered to the virtio bus driver.</p>
</blockquote>
<p>在内核中，virtio核心包含virtio总线驱动和特定的传输驱动，如virtio-pci和virtio-mmio。然后，还有针对特定设备类型的单独的virtio驱动程序，它们被注册到virtio总线驱动程序上。</p>
<blockquote>
<p>How a virtio device is found and configured by the kernel depends on how the hypervisor defines it. Taking the QEMU virtio-console device as an example. When using PCI as a transport method, the device will present itself on the PCI bus with vendor 0x1af4 (Red Hat, Inc.) and device id 0x1003 (virtio console), as defined in the spec, so the kernel will detect it as it would do with any other PCI device.</p>
</blockquote>
<p>内核如何发现和配置virtio设备，取决于管理程序如何定义它。以QEMU virtio-console设备为例。当使用PCI作为传输方式时，该设备将在PCI总线上以供应商0x1af4（Red Hat, Inc.）和设备ID 0x1003（virtio console）的形式出现，正如规范中所定义的那样，所以内核会像检测其他PCI设备那样检测它。</p>
<blockquote>
<p>During the PCI enumeration process, if a device is found to match the virtio-pci driver (according to the virtio-pci device table, any PCI device with vendor id = 0x1af4):</p>
</blockquote>
<p>在PCI枚举过程中，如果发现一个设备与virtio-pci驱动相匹配（根据virtio-pci设备表，任何PCI设备的厂商ID=0x1af4）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Qumranet donated their vendor ID for devices 0x1000 thru 0x10FF. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> <span class="title">virtio_pci_id_table</span>[] =</span> &#123;</span><br><span class="line">        &#123; PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_ANY_ID) &#125;,</span><br><span class="line">        &#123; <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>then the virtio-pci driver is probed and, if the probing goes well, the device is registered to the virtio bus:</p>
</blockquote>
<p>然后对virtio-pci驱动进行探测，如果探测顺利，该设备就被注册到virtio总线上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">virtio_pci_probe</span><span class="params">(struct pci_dev *pci_dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct pci_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (force_legacy) &#123;</span><br><span class="line">                rc = virtio_pci_legacy_probe(vp_dev);</span><br><span class="line">                <span class="comment">/* Also try modern mode if we can&#x27;t map BAR0 (no IO space). */</span></span><br><span class="line">                <span class="keyword">if</span> (rc == -ENODEV || rc == -ENOMEM)</span><br><span class="line">                        rc = virtio_pci_modern_probe(vp_dev);</span><br><span class="line">                <span class="keyword">if</span> (rc)</span><br><span class="line">                        <span class="keyword">goto</span> err_probe;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rc = virtio_pci_modern_probe(vp_dev);</span><br><span class="line">                <span class="keyword">if</span> (rc == -ENODEV)</span><br><span class="line">                        rc = virtio_pci_legacy_probe(vp_dev);</span><br><span class="line">                <span class="keyword">if</span> (rc)</span><br><span class="line">                        <span class="keyword">goto</span> err_probe;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        rc = register_virtio_device(&amp;vp_dev-&gt;vdev);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>When the device is registered to the virtio bus the kernel will look for a driver in the bus that can handle the device and call that driver’s probe method.</p>
<p>At this point, the virtqueues will be allocated and configured by calling the appropriate virtio_find helper function, such as virtio_find_single_vq() or virtio_find_vqs(), which will end up calling a transport-specific find_vqs method.</p>
</blockquote>
<p>当设备被注册到virtio总线上时，内核将在总线上寻找一个可以处理该设备的驱动程序，并调用该驱动程序的探测方法。</p>
<p>此时，将通过调用适当的virtio_find辅助函数，如virtio_find_single_vq()或virtio_find_vqs()来分配和配置virtqueues，最终会调用一个特定于传输的find_vqs方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/03/virtio-on-linux/" data-id="clesn3uub00004xwb5f94h8vb" data-title="Virtio on Linux" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/03/virtio-on-linux/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/03/virtio-on-linux/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cpu-feature-configuration-code-diving" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/cpu-feature-configuration-code-diving/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:48:22.000Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/libvirt/">libvirt</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/cpu-feature-configuration-code-diving/">Cpu feature configuration code diving</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>If disable a feature in libvirt domain xml configuration, what will happen?</p>
<h2 id="General-code-about-libvirt-cpu-conf"><a href="#General-code-about-libvirt-cpu-conf" class="headerlink" title="General code about libvirt cpu conf"></a>General code about libvirt cpu conf</h2><p>Read cpu_conf.c main entrance is <code>virCPUDefFormatBuf</code></p>
<p>Libvirt have two types format:</p>
<ul>
<li><code>CUSTOM</code>: user define model and features of a cpu conf</li>
<li><code>HOST_MODEL</code>: matches a most suitable feature list with host</li>
</ul>
<p>And while handle conf definition:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">formatModel = (def-&gt;mode == VIR_CPU_MODE_CUSTOM ||</span><br><span class="line">               def-&gt;mode == VIR_CPU_MODE_HOST_MODEL);</span><br><span class="line">formatFallback = (def-&gt;type == VIR_CPU_TYPE_GUEST &amp;&amp;</span><br><span class="line">                  (def-&gt;mode == VIR_CPU_MODE_HOST_MODEL ||</span><br><span class="line">                   (def-&gt;mode == VIR_CPU_MODE_CUSTOM &amp;&amp; def-&gt;model)));</span><br></pre></td></tr></table></figure>

<p>see the enum:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    VIR_CPU_TYPE_HOST,</span><br><span class="line">    VIR_CPU_TYPE_GUEST,</span><br><span class="line">    VIR_CPU_TYPE_AUTO,</span><br><span class="line"></span><br><span class="line">    VIR_CPU_TYPE_LAST</span><br><span class="line">&#125; virCPUType;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VIR_CPU_TYPE_AUTO</code> : detect the input xml to tell is guest or host cpu model definition</li>
<li><code>VIR_CPU_TYPE_GUEST</code> : guest cpu model means the cpu conf define from domain xml</li>
<li><code>VIR_CPU_TYPE_HOST</code> : host cpu model means the cpu conf load from host capabilities xml</li>
</ul>
<p>So the could focus on <code>formatFallback</code>. </p>
<p>Verification is required, if you use a custom mode without a cpu model is not allowed, because custom means you need specify a collections of cpu features and custom features of the subset.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!def-&gt;model &amp;&amp; def-&gt;mode == VIR_CPU_MODE_CUSTOM &amp;&amp; def-&gt;nfeatures) &#123;</span><br><span class="line">    virReportError(VIR_ERR_INTERNAL_ERROR, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                   _(<span class="string">&quot;Non-empty feature list specified without CPU model&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while define model, need to get a fallback value for guest cpu</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((formatModel &amp;&amp; def-&gt;model) || formatFallback) &#123;</span><br><span class="line">    virBufferAddLit(buf, <span class="string">&quot;&lt;model&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (formatFallback) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *fallback;</span><br><span class="line"></span><br><span class="line">        fallback = virCPUFallbackTypeToString(def-&gt;fallback);</span><br><span class="line">        <span class="keyword">if</span> (!fallback) &#123;</span><br><span class="line">            virReportError(VIR_ERR_INTERNAL_ERROR,</span><br><span class="line">                           _(<span class="string">&quot;Unexpected CPU fallback value: %d&quot;</span>),</span><br><span class="line">                           def-&gt;fallback);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        virBufferAsprintf(buf, <span class="string">&quot; fallback=&#x27;%s&#x27;&quot;</span>, fallback);</span><br><span class="line">        <span class="keyword">if</span> (def-&gt;vendor_id)</span><br><span class="line">            virBufferEscapeString(buf, <span class="string">&quot; vendor_id=&#x27;%s&#x27;&quot;</span>, def-&gt;vendor_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (formatModel &amp;&amp; def-&gt;model) &#123;</span><br><span class="line">        virBufferEscapeString(buf, <span class="string">&quot;&gt;%s&lt;/model&gt;\n&quot;</span>, def-&gt;model);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        virBufferAddLit(buf, <span class="string">&quot;/&gt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fallback type:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    VIR_CPU_FALLBACK_ALLOW,</span><br><span class="line">    VIR_CPU_FALLBACK_FORBID,</span><br><span class="line"></span><br><span class="line">    VIR_CPU_FALLBACK_LAST</span><br><span class="line">&#125; virCPUFallback;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VIR_CPU_FALLBACK_ALLOW</code> means just use the cpu capabilities from host capabilities xml</li>
<li><code>VIR_CPU_FALLBACK_FORBID</code>means can stop guest from start with unsupported feature</li>
</ul>
<p>Also the topology can be defined:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (def-&gt;sockets &amp;&amp; def-&gt;cores &amp;&amp; def-&gt;threads) &#123;</span><br><span class="line">    virBufferAddLit(buf, <span class="string">&quot;&lt;topology&quot;</span>);</span><br><span class="line">    virBufferAsprintf(buf, <span class="string">&quot; sockets=&#x27;%u&#x27;&quot;</span>, def-&gt;sockets);</span><br><span class="line">    virBufferAsprintf(buf, <span class="string">&quot; cores=&#x27;%u&#x27;&quot;</span>, def-&gt;cores);</span><br><span class="line">    virBufferAsprintf(buf, <span class="string">&quot; threads=&#x27;%u&#x27;&quot;</span>, def-&gt;threads);</span><br><span class="line">    virBufferAddLit(buf, <span class="string">&quot;/&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>from xml too.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; def-&gt;nfeatures; i++) &#123;</span><br><span class="line">    virCPUFeatureDefPtr feature = def-&gt;features + i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!feature-&gt;name) &#123;</span><br><span class="line">        virReportError(VIR_ERR_INTERNAL_ERROR, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                       _(<span class="string">&quot;Missing CPU feature name&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (def-&gt;type == VIR_CPU_TYPE_GUEST) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *policy;</span><br><span class="line"></span><br><span class="line">        policy = virCPUFeaturePolicyTypeToString(feature-&gt;policy);</span><br><span class="line">        <span class="keyword">if</span> (!policy) &#123;</span><br><span class="line">            virReportError(VIR_ERR_INTERNAL_ERROR,</span><br><span class="line">                           _(<span class="string">&quot;Unexpected CPU feature policy %d&quot;</span>),</span><br><span class="line">                           feature-&gt;policy);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        virBufferAsprintf(buf, <span class="string">&quot;&lt;feature policy=&#x27;%s&#x27; name=&#x27;%s&#x27;/&gt;\n&quot;</span>,</span><br><span class="line">                          policy, feature-&gt;name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        virBufferAsprintf(buf, <span class="string">&quot;&lt;feature name=&#x27;%s&#x27;/&gt;\n&quot;</span>,</span><br><span class="line">                          feature-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Features will follow policies:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VIR_ENUM_IMPL(virCPUFeaturePolicy, VIR_CPU_FEATURE_LAST,</span><br><span class="line">              <span class="string">&quot;force&quot;</span>,</span><br><span class="line">              <span class="string">&quot;require&quot;</span>,</span><br><span class="line">              <span class="string">&quot;optional&quot;</span>,</span><br><span class="line">              <span class="string">&quot;disable&quot;</span>,</span><br><span class="line">              <span class="string">&quot;forbid&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Following part explains about those policies.</p>
<p><strong>force</strong></p>
<p>The virtual CPU will claim the feature is supported regardless of it being supported by host CPU.</p>
<p><strong>require</strong></p>
<p>Guest creation will fail unless the feature is supported by the host CPU or the hypervisor is able to emulate it.</p>
<p><strong>optional</strong></p>
<p>The feature will be supported by virtual CPU if and only if it is supported by host CPU.</p>
<p><strong>disable</strong></p>
<p>The feature will not be supported by virtual CPU.</p>
<p><strong>forbid</strong></p>
<p>Guest creation will fail if the feature is supported by host CPU.</p>
<p><code>virCPUDefFormatBuf</code> is used by <code>capabilities.c</code> which collects host features from host capabilities xml. But now we need to check the code in <code>domain_capabilities.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> virCPUDef *virCPUDefPtr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">virCPUDef</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> type;           <span class="comment">/* enum virCPUType */</span></span><br><span class="line">    <span class="keyword">int</span> mode;           <span class="comment">/* enum virCPUMode */</span></span><br><span class="line">    <span class="keyword">int</span> match;          <span class="comment">/* enum virCPUMatch */</span></span><br><span class="line">    virCPUCheck check;</span><br><span class="line">    virArch arch;</span><br><span class="line">    <span class="keyword">char</span> *model;</span><br><span class="line">    <span class="keyword">char</span> *vendor_id;    <span class="comment">/* vendor id returned by CPUID in the guest */</span></span><br><span class="line">    <span class="keyword">int</span> fallback;       <span class="comment">/* enum virCPUFallback */</span></span><br><span class="line">    <span class="keyword">char</span> *vendor;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> microcodeVersion;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sockets;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cores;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> threads;</span><br><span class="line">    <span class="keyword">size_t</span> nfeatures;</span><br><span class="line">    <span class="keyword">size_t</span> nfeatures_max;</span><br><span class="line">    virCPUFeatureDefPtr features;</span><br><span class="line">    virCPUCacheDefPtr cache;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>nfeatures will be set in _virCPUDef and supported features are parsed from domain xml:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Parses CPU definition XML from a node pointed to by @xpath. If @xpath is</span></span><br><span class="line"><span class="comment"> * NULL, the current node of @ctxt is used (i.e., it is a shortcut to &quot;.&quot;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Missing &lt;cpu&gt; element in the XML document is not considered an error unless</span></span><br><span class="line"><span class="comment"> * @xpath is NULL in which case the function expects it was provided with a</span></span><br><span class="line"><span class="comment"> * valid &lt;cpu&gt; element already. In other words, the function returns success</span></span><br><span class="line"><span class="comment"> * and sets @cpu to NULL if @xpath is not NULL and the node pointed to by</span></span><br><span class="line"><span class="comment"> * @xpath is not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success, -1 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">virCPUDefParseXML(xmlXPathContextPtr ctxt,</span><br><span class="line">                  <span class="keyword">const</span> <span class="keyword">char</span> *xpath,</span><br><span class="line">                  virCPUType type,</span><br><span class="line">                  virCPUDefPtr *cpu)</span><br></pre></td></tr></table></figure>

<p>Finally, <code>qemu_command.c</code> would use those features to qemu commandline:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cpu-&gt;nfeatures; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (STREQ(<span class="string">&quot;rtm&quot;</span>, cpu-&gt;features[i].name))</span><br><span class="line">        rtm = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (STREQ(<span class="string">&quot;hle&quot;</span>, cpu-&gt;features[i].name))</span><br><span class="line">        hle = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ((virCPUFeaturePolicy) cpu-&gt;features[i].policy) &#123;</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_FORCE:</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_REQUIRE:</span><br><span class="line">        <span class="keyword">if</span> (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))</span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,%s=on&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,+%s&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_DISABLE:</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_FORBID:</span><br><span class="line">        <span class="keyword">if</span> (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))</span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,%s=off&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            virBufferAsprintf(buf, <span class="string">&quot;,-%s&quot;</span>, cpu-&gt;features[i].name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_OPTIONAL:</span><br><span class="line">    <span class="keyword">case</span> VIR_CPU_FEATURE_LAST:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>like <code>-cpu ... feature1=on,feature2=off</code> to make those features take effects.</p>
<h2 id="Turn-to-qemu"><a href="#Turn-to-qemu" class="headerlink" title="Turn to qemu"></a>Turn to qemu</h2><p>Firstly, qemu will parse input <code>-cpu ....</code> string:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">parse_cpu_model</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cpu_model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectClass *oc;</span><br><span class="line">    CPUClass *cc;</span><br><span class="line">    gchar **model_pieces;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cpu_type;</span><br><span class="line"></span><br><span class="line">    model_pieces = g_strsplit(cpu_model, <span class="string">&quot;,&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    oc = cpu_class_by_name(CPU_RESOLVING_TYPE, model_pieces[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (oc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;unable to find CPU model &#x27;%s&#x27;&quot;</span>, model_pieces[<span class="number">0</span>]);</span><br><span class="line">        g_strfreev(model_pieces);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpu_type = object_class_get_name(oc);</span><br><span class="line">    cc = CPU_CLASS(oc);</span><br><span class="line">    cc-&gt;parse_features(cpu_type, model_pieces[<span class="number">1</span>], &amp;error_fatal);</span><br><span class="line">    g_strfreev(model_pieces);</span><br><span class="line">    <span class="keyword">return</span> cpu_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>An object from <code>oc = cpu_class_by_name(CPU_RESOLVING_TYPE, model_pieces[0]);</code>will return a cpu object class which support parse features. See following code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_common_parse_features</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">typename</span>, <span class="keyword">char</span> *features,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *val;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> cpu_globals_initialized;</span><br><span class="line">    <span class="comment">/* Single &quot;key=value&quot; string being parsed */</span></span><br><span class="line">    <span class="keyword">char</span> *featurestr = features ? strtok(features, <span class="string">&quot;,&quot;</span>) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should be called only once, catch invalid users */</span></span><br><span class="line">    assert(!cpu_globals_initialized);</span><br><span class="line">    cpu_globals_initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (featurestr) &#123;</span><br><span class="line">        val = <span class="built_in">strchr</span>(featurestr, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">            GlobalProperty *prop = g_new0(typeof(*prop), <span class="number">1</span>);</span><br><span class="line">            *val = <span class="number">0</span>;</span><br><span class="line">            val++;</span><br><span class="line">            prop-&gt;driver = <span class="keyword">typename</span>;</span><br><span class="line">            prop-&gt;property = g_strdup(featurestr);</span><br><span class="line">            prop-&gt;value = g_strdup(val);</span><br><span class="line">            prop-&gt;errp = &amp;error_fatal;</span><br><span class="line">            qdev_prop_register_global(prop);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error_setg(errp, <span class="string">&quot;Expected key=value format, found %s.&quot;</span>,</span><br><span class="line">                       featurestr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        featurestr = strtok(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>key=value</code> format will be parse and store into qemu’s global property.</p>
<p>From: <code>target/i386/cpu.c</code></p>
<p>qemu defined <code>#define CPUID_EXT_HYPERVISOR  (1U &lt;&lt; 31)</code> for CPUID EXT to expose hypervisor information.</p>
<p>Then x86 cpu will use those global properties to initialize vcpu:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Parse &quot;+feature,-feature,feature=foo&quot; CPU feature string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_parse_featurestr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">typename</span>, <span class="keyword">char</span> *features,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *featurestr; <span class="comment">/* Single &#x27;key=value&quot; string being parsed */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> cpu_globals_initialized;</span><br><span class="line">    <span class="keyword">bool</span> ambiguous = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpu_globals_initialized) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cpu_globals_initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!features) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (featurestr = strtok(features, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">         featurestr;</span><br><span class="line">         featurestr = strtok(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *val = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> *eq = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> num[<span class="number">32</span>];</span><br><span class="line">        GlobalProperty *prop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Compatibility syntax: */</span></span><br><span class="line">        <span class="keyword">if</span> (featurestr[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            plus_features = g_list_append(plus_features,</span><br><span class="line">                                          g_strdup(featurestr + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (featurestr[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            minus_features = g_list_append(minus_features,</span><br><span class="line">                                           g_strdup(featurestr + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eq = <span class="built_in">strchr</span>(featurestr, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eq) &#123;</span><br><span class="line">            *eq++ = <span class="number">0</span>;</span><br><span class="line">            val = eq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        feat2prop(featurestr);</span><br><span class="line">        name = featurestr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_list_find_custom(plus_features, name, compare_string)) &#123;</span><br><span class="line">            warn_report(<span class="string">&quot;Ambiguous CPU model string. &quot;</span></span><br><span class="line">                        <span class="string">&quot;Don&#x27;t mix both \&quot;+%s\&quot; and \&quot;%s=%s\&quot;&quot;</span>,</span><br><span class="line">                        name, name, val);</span><br><span class="line">            ambiguous = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g_list_find_custom(minus_features, name, compare_string)) &#123;</span><br><span class="line">            warn_report(<span class="string">&quot;Ambiguous CPU model string. &quot;</span></span><br><span class="line">                        <span class="string">&quot;Don&#x27;t mix both \&quot;-%s\&quot; and \&quot;%s=%s\&quot;&quot;</span>,</span><br><span class="line">                        name, name, val);</span><br><span class="line">            ambiguous = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Special case: */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;tsc-freq&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret;</span><br><span class="line">            <span class="keyword">uint64_t</span> tsc_freq;</span><br><span class="line"></span><br><span class="line">            ret = qemu_strtosz_metric(val, <span class="literal">NULL</span>, &amp;tsc_freq);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span> || tsc_freq &gt; INT64_MAX) &#123;</span><br><span class="line">                error_setg(errp, <span class="string">&quot;bad numerical value %s&quot;</span>, val);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">snprintf</span>(num, <span class="keyword">sizeof</span>(num), <span class="string">&quot;%&quot;</span> PRId64, tsc_freq);</span><br><span class="line">            val = num;</span><br><span class="line">            name = <span class="string">&quot;tsc-frequency&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prop = g_new0(typeof(*prop), <span class="number">1</span>);</span><br><span class="line">        prop-&gt;driver = <span class="keyword">typename</span>;</span><br><span class="line">        prop-&gt;property = g_strdup(name);</span><br><span class="line">        prop-&gt;value = g_strdup(val);</span><br><span class="line">        prop-&gt;errp = &amp;error_fatal;</span><br><span class="line">        qdev_prop_register_global(prop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ambiguous) &#123;</span><br><span class="line">        warn_report(<span class="string">&quot;Compatibility of ambiguous CPU model &quot;</span></span><br><span class="line">                    <span class="string">&quot;strings won&#x27;t be kept on future QEMU versions&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which is registered as <code>cc-&gt;parse_features = x86_cpu_parse_featurestr;</code>.</p>
<p>features from qemu commandline will be put as global property for x86 cpu.</p>
<p>And before start virtual machine, qemu will insure there is not unavailable or missing features:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_get_unavailable_features</span><span class="params">(Object *obj, Visitor *v,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *opaque,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X86CPU *xc = X86_CPU(obj);</span><br><span class="line">    strList *result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    x86_cpu_list_feature_names(xc-&gt;filtered_features, &amp;result);</span><br><span class="line">    visit_type_strList(v, <span class="string">&quot;unavailable-features&quot;</span>, &amp;result, errp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for missing features that may prevent the CPU class from</span></span><br><span class="line"><span class="comment"> * running using the current machine and accelerator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_class_check_missing_features</span><span class="params">(X86CPUClass *xcc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 strList **missing_feats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X86CPU *xc;</span><br><span class="line">    Error *err = <span class="literal">NULL</span>;</span><br><span class="line">    strList **next = missing_feats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xcc-&gt;host_cpuid_required &amp;&amp; !accel_uses_host_cpuid()) &#123;</span><br><span class="line">        strList *<span class="keyword">new</span> = g_new0(strList, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span>-&gt;value = g_strdup(<span class="string">&quot;kvm&quot;</span>);</span><br><span class="line">        *missing_feats = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xc = X86_CPU(object_new(object_class_get_name(OBJECT_CLASS(xcc))));</span><br><span class="line"></span><br><span class="line">    x86_cpu_expand_features(xc, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">/* Errors at x86_cpu_expand_features should never happen,</span></span><br><span class="line"><span class="comment">         * but in case it does, just report the model as not</span></span><br><span class="line"><span class="comment">         * runnable at all using the &quot;type&quot; property.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        strList *<span class="keyword">new</span> = g_new0(strList, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span>-&gt;value = g_strdup(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">        *next = <span class="keyword">new</span>;</span><br><span class="line">        next = &amp;<span class="keyword">new</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x86_cpu_filter_features(xc, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    x86_cpu_list_feature_names(xc-&gt;filtered_features, next);</span><br><span class="line"></span><br><span class="line">    object_unref(OBJECT(xc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while qemu init cpu:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_realizefn</span><span class="params">(DeviceState *dev, Error **errp)</span></span></span><br></pre></td></tr></table></figure>

<p>features will be set to a CPU object:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!kvm_enabled() || !cpu-&gt;expose_kvm) &#123;</span><br><span class="line">    env-&gt;features[FEAT_KVM] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>we could find “hypervisor” related cpu features defined by <code>FEAT_1_ECX</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[FEAT_1_ECX] = &#123;</span><br><span class="line">    .type = CPUID_FEATURE_WORD,</span><br><span class="line">    .feat_names = &#123;</span><br><span class="line">        <span class="string">&quot;pni&quot;</span> <span class="comment">/* Intel,AMD sse3 */</span>, <span class="string">&quot;pclmulqdq&quot;</span>, <span class="string">&quot;dtes64&quot;</span>, <span class="string">&quot;monitor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ds-cpl&quot;</span>, <span class="string">&quot;vmx&quot;</span>, <span class="string">&quot;smx&quot;</span>, <span class="string">&quot;est&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tm2&quot;</span>, <span class="string">&quot;ssse3&quot;</span>, <span class="string">&quot;cid&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="string">&quot;fma&quot;</span>, <span class="string">&quot;cx16&quot;</span>, <span class="string">&quot;xtpr&quot;</span>, <span class="string">&quot;pdcm&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">&quot;pcid&quot;</span>, <span class="string">&quot;dca&quot;</span>, <span class="string">&quot;sse4.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sse4.2&quot;</span>, <span class="string">&quot;x2apic&quot;</span>, <span class="string">&quot;movbe&quot;</span>, <span class="string">&quot;popcnt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tsc-deadline&quot;</span>, <span class="string">&quot;aes&quot;</span>, <span class="string">&quot;xsave&quot;</span>, <span class="string">&quot;osxsave&quot;</span>,</span><br><span class="line">        <span class="string">&quot;avx&quot;</span>, <span class="string">&quot;f16c&quot;</span>, <span class="string">&quot;rdrand&quot;</span>, <span class="string">&quot;hypervisor&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .cpuid = &#123; .eax = <span class="number">1</span>, .reg = R_ECX, &#125;,</span><br><span class="line">    .tcg_features = TCG_EXT_FEATURES,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>then cpu will read those features with key words:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Finishes initialization of CPUID data, filters CPU feature</span></span><br><span class="line"><span class="comment"> * words based on host availability of each feature.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: 0 if all flags are supported by the host, non-zero otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">x86_cpu_filter_features</span><span class="params">(X86CPU *cpu, <span class="keyword">bool</span> verbose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPUX86State *env = &amp;cpu-&gt;env;</span><br><span class="line">    FeatureWord w;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prefix = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        prefix = accel_uses_host_cpuid()</span><br><span class="line">                 ? <span class="string">&quot;host doesn&#x27;t support requested feature&quot;</span></span><br><span class="line">                 : <span class="string">&quot;TCG doesn&#x27;t support requested feature&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; FEATURE_WORDS; w++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> host_feat =</span><br><span class="line">            x86_cpu_get_supported_feature_word(w, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">uint64_t</span> requested_features = env-&gt;features[w];</span><br><span class="line">        <span class="keyword">uint64_t</span> unavailable_features = requested_features &amp; ~host_feat;</span><br><span class="line">        mark_unavailable_features(cpu, w, unavailable_features, prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((env-&gt;features[FEAT_7_0_EBX] &amp; CPUID_7_0_EBX_INTEL_PT) &amp;&amp;</span><br><span class="line">        kvm_enabled()) &#123;</span><br><span class="line">        KVMState *s = CPU(cpu)-&gt;kvm_state;</span><br><span class="line">        <span class="keyword">uint32_t</span> eax_0 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">0</span>, R_EAX);</span><br><span class="line">        <span class="keyword">uint32_t</span> ebx_0 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">0</span>, R_EBX);</span><br><span class="line">        <span class="keyword">uint32_t</span> ecx_0 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">0</span>, R_ECX);</span><br><span class="line">        <span class="keyword">uint32_t</span> eax_1 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">1</span>, R_EAX);</span><br><span class="line">        <span class="keyword">uint32_t</span> ebx_1 = kvm_arch_get_supported_cpuid(s, <span class="number">0x14</span>, <span class="number">1</span>, R_EBX);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!eax_0 ||</span><br><span class="line">           ((ebx_0 &amp; INTEL_PT_MINIMAL_EBX) != INTEL_PT_MINIMAL_EBX) ||</span><br><span class="line">           ((ecx_0 &amp; INTEL_PT_MINIMAL_ECX) != INTEL_PT_MINIMAL_ECX) ||</span><br><span class="line">           ((eax_1 &amp; INTEL_PT_MTC_BITMAP) != INTEL_PT_MTC_BITMAP) ||</span><br><span class="line">           ((eax_1 &amp; INTEL_PT_ADDR_RANGES_NUM_MASK) &lt;</span><br><span class="line">                                           INTEL_PT_ADDR_RANGES_NUM) ||</span><br><span class="line">           ((ebx_1 &amp; (INTEL_PT_PSB_BITMAP | INTEL_PT_CYCLE_BITMAP)) !=</span><br><span class="line">                (INTEL_PT_PSB_BITMAP | INTEL_PT_CYCLE_BITMAP)) ||</span><br><span class="line">           (ecx_0 &amp; INTEL_PT_IP_LIP)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Processor Trace capabilities aren&#x27;t configurable, so if the</span></span><br><span class="line"><span class="comment">             * host can&#x27;t emulate the capabilities we report on</span></span><br><span class="line"><span class="comment">             * cpu_x86_cpuid(), intel-pt can&#x27;t be enabled on the current host.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mark_unavailable_features(cpu, FEAT_7_0_EBX, CPUID_7_0_EBX_INTEL_PT, prefix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mainly the features is set by:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; FEATURE_WORDS; w++) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> host_feat =</span><br><span class="line">        x86_cpu_get_supported_feature_word(w, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> requested_features = env-&gt;features[w];</span><br><span class="line">    <span class="keyword">uint64_t</span> unavailable_features = requested_features &amp; ~host_feat;</span><br><span class="line">    mark_unavailable_features(cpu, w, unavailable_features, prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this part and supported feature keeps 0 because </p>
<p><code>requested_features &amp; ~host_feat</code> host unavialable features would be <code>~</code> at first.</p>
<p>We can dump those configurations from qemu vcpu to check is usage. </p>
<h2 id="How-kernel-use-it"><a href="#How-kernel-use-it" class="headerlink" title="How kernel use it"></a>How kernel use it</h2><p>Then we move to linux kernel check about those features usages.</p>
<p><code>#define X86_FEATURE_HYPERVISOR  (4*32+31) /* Running on a hypervisor */</code></p>
<p>kernel use <code>X86_FEATURE_HYPERVISOR</code> means if running on hypervisor.</p>
<h2 id="Hand-on-test"><a href="#Hand-on-test" class="headerlink" title="Hand on test"></a>Hand on test</h2><p>Now try to run a guest detecting hypervisor and figure out how to bypass the detection by virtualization level configs.</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><a target="_blank" rel="noopener" href="http://www.etallen.com/cpuid.html">http://www.etallen.com/cpuid.html</a> use a cpuid tool to dump cpu id of a guest to check our configuration.</p>
<p>By run <code>cpuid</code> to dump features, we can see following output with our expected values:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">feature information (1/ecx):</span><br><span class="line">   PNI/SSE3: Prescott New Instructions     = true</span><br><span class="line">   PCLMULDQ instruction                    = true</span><br><span class="line">   DTES64: 64-bit debug store              = false</span><br><span class="line">   MONITOR/MWAIT                           = false</span><br><span class="line">   CPL-qualified debug store               = false</span><br><span class="line">   VMX: virtual machine extensions         = true</span><br><span class="line">   SMX: safer mode extensions              = false</span><br><span class="line">   Enhanced Intel SpeedStep Technology     = false</span><br><span class="line">   TM2: thermal monitor 2                  = false</span><br><span class="line">   SSSE3 extensions                        = true</span><br><span class="line">   context ID: adaptive or shared L1 data  = false</span><br><span class="line">   SDBG: IA32_DEBUG_INTERFACE              = false</span><br><span class="line">   FMA instruction                         = true</span><br><span class="line">   CMPXCHG16B instruction                  = true</span><br><span class="line">   xTPR disable                            = false</span><br><span class="line">   PDCM: perfmon and debug                 = false</span><br><span class="line">   PCID: process context identifiers       = true</span><br><span class="line">   DCA: direct cache access                = false</span><br><span class="line">   SSE4.1 extensions                       = true</span><br><span class="line">   SSE4.2 extensions                       = true</span><br><span class="line">   x2APIC: extended xAPIC support          = true</span><br><span class="line">   MOVBE instruction                       = true</span><br><span class="line">   POPCNT instruction                      = true</span><br><span class="line">   time stamp counter deadline             = true</span><br><span class="line">   AES instruction                         = true</span><br><span class="line">   XSAVE/XSTOR states                      = true</span><br><span class="line">   OS-enabled XSAVE/XSTOR                  = true</span><br><span class="line">   AVX: advanced vector extensions         = true</span><br><span class="line">   F16C half-precision convert instruction = true</span><br><span class="line">   RDRAND instruction                      = true</span><br><span class="line">   hypervisor guest status                 = true</span><br></pre></td></tr></table></figure>

<p>the <code>hypervisor guest status                 = true</code> matches with linux kernel’s definition.</p>
<p>While with hypervisor feature disabled the output changed to:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">feature <span class="title">information</span> <span class="params">(<span class="number">1</span>/edx)</span>:</span></span><br><span class="line"><span class="function">   x87 FPU on chip                        </span>= <span class="literal">true</span></span><br><span class="line">   VME: <span class="keyword">virtual</span><span class="number">-8086</span> mode enhancement     = <span class="literal">true</span></span><br><span class="line">   DE: debugging extensions               = <span class="literal">true</span></span><br><span class="line">   PSE: page size extensions              = <span class="literal">true</span></span><br><span class="line">   TSC: time stamp counter                = <span class="literal">true</span></span><br><span class="line">   RDMSR <span class="keyword">and</span> WRMSR support                = <span class="literal">true</span></span><br><span class="line">   PAE: physical address extensions       = <span class="literal">true</span></span><br><span class="line">   MCE: machine check exception           = <span class="literal">true</span></span><br><span class="line">   CMPXCHG8B inst.                        = <span class="literal">true</span></span><br><span class="line">   APIC on chip                           = <span class="literal">true</span></span><br><span class="line">   SYSENTER <span class="keyword">and</span> SYSEXIT                   = <span class="literal">true</span></span><br><span class="line">   MTRR: memory type range registers      = <span class="literal">true</span></span><br><span class="line">   PTE global bit                         = <span class="literal">true</span></span><br><span class="line">   MCA: machine check architecture        = <span class="literal">true</span></span><br><span class="line">   CMOV: conditional move/compare instr   = <span class="literal">true</span></span><br><span class="line">   PAT: page attribute table              = <span class="literal">true</span></span><br><span class="line">   PSE<span class="number">-36</span>: page size extension            = <span class="literal">true</span></span><br><span class="line">   PSN: processor serial number           = <span class="literal">false</span></span><br><span class="line">   CLFLUSH instruction                    = <span class="literal">true</span></span><br><span class="line">   DS: debug store                        = <span class="literal">false</span></span><br><span class="line">   ACPI: thermal monitor <span class="keyword">and</span> clock ctrl   = <span class="literal">false</span></span><br><span class="line">   MMX Technology                         = <span class="literal">true</span></span><br><span class="line">   FXSAVE/FXRSTOR                         = <span class="literal">true</span></span><br><span class="line">   SSE extensions                         = <span class="literal">true</span></span><br><span class="line">   SSE2 extensions                        = <span class="literal">true</span></span><br><span class="line">   SS: self snoop                         = <span class="literal">true</span></span><br><span class="line">   hyper-threading / multi-core supported = <span class="literal">true</span></span><br><span class="line">   TM: therm. monitor                     = <span class="literal">false</span></span><br><span class="line">   IA64                                   = <span class="literal">false</span></span><br><span class="line">   PBE: pending <span class="keyword">break</span> event               = <span class="literal">false</span></span><br><span class="line">feature information (<span class="number">1</span>/ecx):</span><br><span class="line">   PNI/SSE3: Prescott New Instructions     = <span class="literal">true</span></span><br><span class="line">   PCLMULDQ instruction                    = <span class="literal">true</span></span><br><span class="line">   DTES64: <span class="number">64</span>-bit debug store              = <span class="literal">false</span></span><br><span class="line">   MONITOR/MWAIT                           = <span class="literal">false</span></span><br><span class="line">   CPL-qualified debug store               = <span class="literal">false</span></span><br><span class="line">   VMX: <span class="keyword">virtual</span> machine extensions         = <span class="literal">true</span></span><br><span class="line">   SMX: safer mode extensions              = <span class="literal">false</span></span><br><span class="line">   Enhanced Intel SpeedStep Technology     = <span class="literal">false</span></span><br><span class="line">   TM2: thermal monitor <span class="number">2</span>                  = <span class="literal">false</span></span><br><span class="line">   SSSE3 extensions                        = <span class="literal">true</span></span><br><span class="line">   context ID: adaptive <span class="keyword">or</span> shared L1 data  = <span class="literal">false</span></span><br><span class="line">   SDBG: IA32_DEBUG_INTERFACE              = <span class="literal">false</span></span><br><span class="line">   FMA instruction                         = <span class="literal">true</span></span><br><span class="line">   CMPXCHG16B instruction                  = <span class="literal">true</span></span><br><span class="line">   xTPR disable                            = <span class="literal">false</span></span><br><span class="line">   PDCM: perfmon <span class="keyword">and</span> debug                 = <span class="literal">false</span></span><br><span class="line">   PCID: process context identifiers       = <span class="literal">true</span></span><br><span class="line">   DCA: direct cache access                = <span class="literal">false</span></span><br><span class="line">   SSE4<span class="number">.1</span> extensions                       = <span class="literal">true</span></span><br><span class="line">   SSE4<span class="number">.2</span> extensions                       = <span class="literal">true</span></span><br><span class="line">   x2APIC: extended xAPIC support          = <span class="literal">true</span></span><br><span class="line">   MOVBE instruction                       = <span class="literal">true</span></span><br><span class="line">   POPCNT instruction                      = <span class="literal">true</span></span><br><span class="line">   time stamp counter deadline             = <span class="literal">true</span></span><br><span class="line">   AES instruction                         = <span class="literal">true</span></span><br><span class="line">   XSAVE/XSTOR states                      = <span class="literal">true</span></span><br><span class="line">   OS-enabled XSAVE/XSTOR                  = <span class="literal">true</span></span><br><span class="line">   AVX: advanced <span class="built_in">vector</span> extensions         = <span class="literal">true</span></span><br><span class="line">   F16C half-precision convert instruction = <span class="literal">true</span></span><br><span class="line">   RDRAND instruction                      = <span class="literal">true</span></span><br><span class="line">   hypervisor guest status                 = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>the <code>hypervisor guest status                 = false</code> value changed as expected.</p>
<h4 id="Linux-drawbacks"><a href="#Linux-drawbacks" class="headerlink" title="Linux drawbacks"></a>Linux drawbacks</h4><p>Read the usage about <code>X86_FEATURE_HYPERVISOR</code> in linux kernel. Some drawbacks can be found in kernel code directly.</p>
<p>From <code>qspintlock.h</code> :    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RHEL7 specific:</span></span><br><span class="line"><span class="comment"> * To provide backward compatibility with pre-7.4 kernel modules that</span></span><br><span class="line"><span class="comment"> * inlines the ticket spinlock unlock code. The virt_spin_lock() function</span></span><br><span class="line"><span class="comment"> * will have to recognize both a lock value of 0 or _Q_UNLOCKED_VAL as</span></span><br><span class="line"><span class="comment"> * being in an unlocked state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">virt_spin_lock</span><span class="params">(struct qspinlock *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lockval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!static_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>Slow spin lock will not be detected.</p>
<p>From <code>paravirt-spinlocks.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">queued_enable_pv_ticketlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!static_cpu_has(X86_FEATURE_HYPERVISOR) ||</span><br><span class="line">	   (pv_lock_ops.queued_spin_lock_slowpath !=</span><br><span class="line">	    native_queued_spin_lock_slowpath))</span><br><span class="line">		static_key_slow_inc(&amp;paravirt_ticketlocks_enabled);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>From <code>tsc.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t enable ART in a VM, non-stop TSC required,</span></span><br><span class="line"><span class="comment"> * and the TSC counter resets must not occur asynchronously.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (boot_cpu_has(X86_FEATURE_HYPERVISOR) ||</span><br><span class="line">    !boot_cpu_has(X86_FEATURE_NONSTOP_TSC) ||</span><br><span class="line">    art_to_tsc_denominator &lt; ART_MIN_DENOMINATOR ||</span><br><span class="line">    tsc_async_resets)</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>Always run timer will be started which actually should not be enabled.</p>
<p>From <code>apic.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER) ||</span><br><span class="line">    boot_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>From <code>mshyperv.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!boot_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>Can not detect if run on hyperv.</p>
<p>From <code>radeon_device</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * radeon_device_is_virtual - check if we are running is a virtual environment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Check if the asic has been passed through to a VM (all asics).</span></span><br><span class="line"><span class="comment"> * Used at driver startup.</span></span><br><span class="line"><span class="comment"> * Returns true if virtual or false if not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">radeon_device_is_virtual</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">	<span class="keyword">return</span> boot_cpu_has(X86_FEATURE_HYPERVISOR);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Radeon gpu will not detect it is running as guest.</p>
<p>For kernel it may failed to detect that it is running over hypervisor. So related performance improvement changed won’t be applied so there will be a performance drop for those guests.</p>
<p>So does the userspace application also can not do specific things without knowing it is running in virtual machine.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/03/01/cpu-feature-configuration-code-diving/" data-id="clepog9dl0000fdwb444cfiz4" data-title="Cpu feature configuration code diving" class="article-share-link">Share</a>
      
      
        <a href="/2023/03/01/cpu-feature-configuration-code-diving/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/03/01/cpu-feature-configuration-code-diving/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-packed-virtqueue-how-to-reduce-overhead-with-virtio" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" class="article-date">
  <time class="dt-published" datetime="2023-02-23T15:13:20.000Z" itemprop="datePublished">2023-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>►<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/">Packed virtqueue: How to reduce overhead with virtio</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>This is the final post of a three-post series, the previous posts are “<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">Virtio devices and drivers overview: The headjack and the phone</a>,” and “<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtqueues-and-virtio-ring-how-data-travels">Virtqueues and virtio ring: How the data travels</a>.”</p>
</blockquote>
<p> 这是三篇系列文章的最后一篇，之前的文章是”<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">Virtio设备和驱动概述：头戴式耳机和手机</a>“，以及”<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtqueues-and-virtio-ring-how-data-travels">Virtqueues和virtio环：数据如何传输</a>“。</p>
<h2 id="Split-virtqueue-issues-Too-much-spinning-around"><a href="#Split-virtqueue-issues-Too-much-spinning-around" class="headerlink" title="Split virtqueue issues: Too much spinning around"></a>Split virtqueue issues: Too much spinning around</h2><blockquote>
<p>While the split virtqueue shines because of the simplicity of its design, it has a fundamental problem: The avail-used buffer cycle needs to use memory in a very sparse way. This puts pressure on the CPU cache utilization, and in the case of hardware means several PCI transactions for each descriptor.</p>
</blockquote>
<p>虽然split virtqueue因其设计的简单性而大放异彩，但它有一个基本问题：可用的缓冲区环需要以一种非常稀疏的方式使用内存。这给CPU的缓存利用率带来了压力，在硬件的情况下，意味着每个描述符都要有几个PCI事务。</p>
<blockquote>
<p>Packed virtqueue amends it by merging the three rings in just one location in virtual environment guest memory. While this may seem complicated at first glance, it’s a natural step after the split version if we realize that the device can discard and overwrite the data it already has read from the driver, and the same happens the other way around.</p>
</blockquote>
<p>Packed virtqueue对其进行了修正，将三个环合并在虚拟环境guest内存的一个位置。虽然这乍看起来很复杂，但如果我们意识到设备可以丢弃和覆盖它已经从驱动中读取的数据，那么这就是分裂版本之后的一个自然步骤，反之亦然。</p>
<h3 id="Supplying-descriptors-to-the-device-How-to-fill-device-todo-list"><a href="#Supplying-descriptors-to-the-device-How-to-fill-device-todo-list" class="headerlink" title="Supplying descriptors to the device: How to fill device todo-list"></a>Supplying descriptors to the device: How to fill device todo-list</h3><blockquote>
<p>After initialization in the same process as described in Virtio device initialization: feature bits, and after the agreement on RING_PACKED feature flag, the driver and the device starts with a shared blank canvas of descriptors with an agreed length (up to 215 entries) in a agreed guest’s memory location. The layout of these descriptors is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_desc</span> &#123;</span> </span><br><span class="line">        le64 addr;</span><br><span class="line">        le32 len;</span><br><span class="line">        le16 id;</span><br><span class="line">        le16 flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Memory layout of a packed virtqueue descriptor</strong></p>
</blockquote>
<p>在Virtio设备初始化：特征位中描述的相同过程中进行初始化后，在就RING_PACKED特征标志达成一致后，驱动程序和设备开始在商定的客体内存位置上共享一个空白的描述符，其长度是商定的（最多215条）。这些描述符的布局是：。</p>
<blockquote>
<p>This time, the id field is not an index for the device to look for the buffer: it is an opaque value for it, only has meaning for the driver.</p>
<p>The driver also maintains an internal single-bit ring wrap counter initialized to 1. The driver will flip its value every time it makes available the last descriptor in the ring.</p>
<p>As with split descriptors, the first step is to write the different fields: address, length, id and flags. However, packed descriptors take into account two new flags: <code>AVAIL(0x7)</code> and <code>USED(0x15)</code>. To mark a descriptor as available, the driver makes the <code>AVAIL(0x7)</code> flag the same as its internal wrap counter, and the used flag the inverse. While just a binary flag avail/used would be easier to implement, it would prevent useful optimizations we will describe later.</p>
</blockquote>
<p>这一次，id字段不是设备寻找缓冲区的索引：它是一个不透明的值，只对驱动有意义。</p>
<p>驱动程序还维护一个内部的单比特环形缠绕计数器，初始化为1，每次提供环形的最后一个描述符时，驱动程序都会翻转其值。</p>
<p>与分割描述符一样，第一步是写入不同的字段：地址、长度、ID和标志。然而，打包描述符考虑到了两个新的标志。AVAIL(0x7)和USED(0x15)。为了将一个描述符标记为可用，驱动程序使AVAIL(0x7)标志与它的内部包装计数器相同，而使用的标志则是相反的。虽然只有一个二进制标志AVA/USED会更容易实现，但它会妨碍我们后面要描述的有用的优化。</p>
<blockquote>
<p>As an example, if the driver allocates a write buffer with <code>0x1000</code> bytes on position <code>0x80000000</code> in the step 1 in the diagram, and makes it the first available descriptor setting <code>AVAIL(0x7)</code> flag the same as internal wrap counter (set) in step 2. The descriptor table would look like this:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Descriptor table after add the first buffer</strong></p>
</blockquote>
<p>举个例子，如果驱动程序在图中的第1步中在<code>0x80000000</code>位置分配了一个<code>0x1000</code>字节的写缓冲区，并使其成为第一个可用的描述符，在第2步中设置<code>AVAIL(0x7)</code>标志与内部包络计数相同（设置）。描述符表将看起来像这样。</p>
<blockquote>
<p>Note that the avail and used idx columns are in the table just for guidance, they don’t exist in the descriptor table: Each side should have its internal counter to know which position needs to poll or write next, and also the device must track the driver’s wrap counter. Lastly, as with used virtqueue, the driver notifies the device if the latter has notifications enabled (step 3 in the diagram).</p>
</blockquote>
<p>注意，表中的avail和used idx列只是为了指导，它们在描述符表中并不存在。每一方都应该有自己的内部计数器，以知道下一步需要轮询或写入哪个位置，同时设备也必须跟踪驱动的wrap计数器。最后，和使用的virtqueue一样，如果设备启用了通知功能，驱动程序就会通知设备（图中第3步）。</p>
<blockquote>
<p>And the usual diagram of the updates. Note the lack of the avail and used ring, as only the descriptor table is needed now.</p>
</blockquote>
<p>还有通常的更新图。请注意，由于现在只需要描述符表，所以缺少可用和已用环。</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-1.png" class="">

<p><strong>Diagram: Driver makes available a descriptor using a packed queue</strong></p>
<h3 id="Returning-used-descriptors-How-the-device-fills-the-“done”-list"><a href="#Returning-used-descriptors-How-the-device-fills-the-“done”-list" class="headerlink" title="Returning used descriptors: How the device fills the “done” list"></a>Returning used descriptors: How the device fills the “done” list</h3><blockquote>
<p>As the driver, the device maintains an internal single-bit ring wrap counter initialized to 1, and knows that the driver also has its internal ring wrap counter set. When the latter first searches for the first descriptor the driver has made available, it polls the first entry of the ring, looking for the avail flag equal to the driver internal wrap flag (set in this case).</p>
</blockquote>
<p>作为驱动程序，设备维护着一个初始化为1的内部单比特环形缠绕计数器，并且知道驱动程序也设置了其内部环形缠绕计数器。当后者第一次搜索驱动器提供的第一个描述符时，它就会轮询环的第一个条目，寻找等于驱动器内部包络标志的可用标志（在这种情况下是设置的）。</p>
<blockquote>
<p>As with a used ring, the length of the written data is returned in the “length” entry (if any), and the id of the used descriptor. At last, the device will make the avail (A) and used (U) flag the same as the device’s internal wrap counter.</p>
<p>Following the example, the device will let the descriptor table as figure 6. The device will know that the buffer has been returned because the used flag matches the available flag, and with the device internal wrap counter at the moment it wrote the descriptor. The returned address is not important: only the ID.</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Descriptor table after add the first buffer</strong></p>
</blockquote>
<p>与已用环一样，写入数据的长度会在 “length “条目中返回（如果有的话），以及已用描述符的id。最后，设备将使可用(A)和已用(U)标志与设备的内部缠绕计数器相同。</p>
<p>按照这个例子，设备将让描述符表如图6所示。设备将知道缓冲区已经被返回，因为使用的标志与可用的标志相匹配，并且在写描述符的时候与设备内部的wrap计数器相匹配。返回的地址并不重要：只有ID。</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-2.png" class="">

<p><strong>Diagram: Device marks a descriptor as used using a packed queue</strong></p>
<h3 id="Wrapping-the-descriptor-ring-How-the-lanes-keep-separated"><a href="#Wrapping-the-descriptor-ring-How-the-lanes-keep-separated" class="headerlink" title="Wrapping the descriptor ring: How the lanes keep separated?"></a>Wrapping the descriptor ring: How the lanes keep separated?</h3><blockquote>
<p>When the driver fills the complete descriptor table, it wraps and changes its internal Driver Ring Wrap. So, in the second round, the available descriptions will have the avail and used flags clear, so the device will have to poll looking for this condition once it wraps reading descriptors. Let’s see a full example of the different situations.</p>
</blockquote>
<p>当驱动程序填满了完整的描述符表，它就会包裹并改变其内部的驱动程序环形包裹。所以，在第二轮中，可用的描述符将有avail和used标志被清除，所以设备一旦包裹读取描述符，就必须轮询寻找这个条件。让我们来看看不同情况的完整例子。</p>
<blockquote>
<p>If we have a descriptor table with only two entries, the Driver Ring Wrap Counter is set, and it fills the descriptor table making available two buffers at the beginning of the operation, driver will reverse its internal wrap counter, so it will be clear (0). We have the next table:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>→</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Full two-entries descriptor table</strong></p>
</blockquote>
<p>如果我们有一个只有两个条目的描述符表，驱动环形缠绕计数器被设置，它填满描述符表，在操作开始时腾出两个缓冲区，驱动将扭转其内部缠绕计数器，所以它将是clear（0）。我们有下一个表。</p>
<blockquote>
<p>After that, the device realizes that has both descriptors with id #0 and #1 available: it knows that the driver had its wrap counter set when it wrote them, the avail flag is set on them, and the used one is clear on both. If device uses the descriptor with id #1, we have the Figure 8 descriptor table. The buffer #0 still belongs to the device!</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>→</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Using first buffer out of order</strong></p>
</blockquote>
<p>之后，设备意识到有两个ID为#0和#1的描述符是可用的：它知道驱动程序在写它们的时候设置了wrap计数器，它们的avail标志被设置，而且这两个描述符的used标志都是清零的。如果设备使用id为#1的描述符，我们就有了图8的描述符表。缓冲区#0仍然属于设备!</p>
<blockquote>
<p>Now the driver realize the buffer #1 has been used, since avail and used flags are the same (set) and match the device’s internal wrap counter at the moment it wrote it. If device now uses the buffer id #0, it will make the table look like this:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td>→</td>
<td>0x80000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A|U</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Using second buffer out of order</strong></p>
</blockquote>
<p>现在驱动程序意识到1号缓冲区已经被使用了，因为avail和used标志是一样的（设置），并且与设备的内部wrap计数器在写的时候是一致的。如果设备现在使用缓冲区ID #0，它将使表看起来像这样。</p>
<blockquote>
<p>But there is a more interesting case: Starting from the “first buffer out of order” situation, the driver makes available the buffer #1 again. In that case, the descriptor table goes directly from the “first buffer” to the next figure, “Full two-entries descriptor table.”</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td>←</td>
</tr>
<tr>
<td>→</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Full two-entries descriptor table</strong></p>
</blockquote>
<p>但还有一种更有趣的情况。从 “第一个缓冲区失灵 “的情况开始，驱动程序再次提供了1号缓冲区。在这种情况下，描述符表直接从 “第一个缓冲区 “进入下一个图，”完整的两行描述符表”。</p>
<h3 id="Chained-descriptors-No-more-jumps"><a href="#Chained-descriptors-No-more-jumps" class="headerlink" title="Chained descriptors: No more jumps"></a>Chained descriptors: No more jumps</h3><blockquote>
<p>Chained descriptors work likewise: no need for the next field in the head (or subsequent) descriptor in the chain to search subsequent ones, since the latter always occupies the next position. However, while in the split used ring you only need to return as used the id of the head of the chain, in packed you only need to return the tail id.</p>
</blockquote>
<p>链式描述符的工作原理也是如此：不需要在链中的头部（或后续）描述符的下一个字段来搜索后续的描述符，因为后者总是占据着下一个位置。然而，在分割使用的环中，你只需要返回链头的id作为使用，而在打包中你只需要返回尾部的id。</p>
<blockquote>
<p>Back to the used ring, every time we use chained descriptors, we make the used idx lag regarding the avail idx. More than one descriptor mark as available to the device, but we only send one as used to the driver. While this is not a problem in the split ring, this would cause descriptor entry exhaustion in the packed version.</p>
</blockquote>
<p>回到已用环，每次我们使用链式描述符时，都会使已用idx滞后于可用idx。一个以上的描述符被标记为设备可用，但我们只把一个描述符作为已使用的描述符发送给驱动。虽然这在分割环中不是一个问题，但在打包版本中会导致描述符条目耗尽。</p>
<blockquote>
<p>The straightforward solution is to make the device mark as used every descriptor in the chain. However, this can be expensive, since we are modifying a shared area of memory, and could cause cache bounces.</p>
<p>However, the driver already knows the chain, so it can skip all the chain with only the last id. This is why we need to compare the used/avail pair with the driver/device Wrap Counter: after a jump, we wouldn’t know if the next descriptor has been made available in this driver’s round or in the next if we only have a binary available/used flag.</p>
</blockquote>
<p>直接的解决方案是让设备将链上的每个描述符都标记为已使用。然而，这可能是昂贵的，因为我们正在修改内存的共享区域，并可能导致缓存跳出。</p>
<p>然而，驱动程序已经知道了链，所以它可以跳过所有的链，只保留最后一个ID。这就是为什么我们需要将已用/可用对与驱动/设备的Wrap Counter进行比较：在跳转之后，如果我们只有一个二进制的可用/已用标志，我们就不知道下一个描述符是在这个驱动的回合中还是在下一个回合中被提供的。</p>
<blockquote>
<p>For example, in a four entries ring, the driver makes available the chain of three descriptors:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Three chained descriptors available</strong></p>
</blockquote>
<p>例如，在一个四项环中，驱动器提供了三个描述符的链。</p>
<blockquote>
<p>After that, the device discovers the chain (polling position 0) and marks it as used, overwriting only the position 0. It skips completely the positions 1 and 2. When the driver polls for used, it will skip them too, knowing that the chain was 3 descriptors long:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A|U</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Using the descriptor chain</strong></p>
</blockquote>
<p>之后，设备会发现这个链（轮询位置0），并将其标记为已用，只覆盖位置0，完全跳过位置1和2。当驱动轮询已使用时，它也会跳过这些位置，因为它知道该链有3个描述符长。</p>
<blockquote>
<p>Now the driver produces another two descriptor long chain, and it has to take into account the wrapping:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A</td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Make available another descriptor chain</strong></p>
</blockquote>
<p>现在，驱动程序又产生了一个两根描述符的长链，它必须考虑到包装的问题。</p>
<blockquote>
<p>And the device marks it as used, so only the first descriptor in the chain (4th in the table) needs to be updated.</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|(!A)|U</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>0x81000000</td>
<td>0x1000</td>
<td>1</td>
<td>W|A</td>
<td>←</td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>2</td>
<td>W|A</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>0</td>
<td>W|A|U</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Using another descriptor chain</strong></p>
<p>Although the next descriptor (2nd) seems like available, since the avail flag is different from the used one, the device knows that it is not because of knowing the internal Driver Wrap Counter: The right flag combination is avail clear, used set.</p>
</blockquote>
<p>而设备将其标记为已使用，所以只有链中的第一个描述符（表中的第四个）需要更新。</p>
<p>尽管下一个描述符（第2个）看起来是可用的，但由于avail标志与used标志不同，设备知道它不是，因为知道内部的Driver Wrap Counter。正确的标志组合是avail clear，used set。</p>
<h3 id="Indirect-descriptors-When-chains-are-not-enough"><a href="#Indirect-descriptors-When-chains-are-not-enough" class="headerlink" title="Indirect descriptors: When chains are not enough"></a>Indirect descriptors: When chains are not enough</h3><blockquote>
<p>Indirect descriptors work like in the split case. First, the driver allocates a table of indirect descriptors each with the same layout as the regular packed descriptors anywhere in memory. After that, it sets each descriptor in this indirect table to the buffer it wants to make available for the driver (steps 1-2), and inserts a descriptor in the virtqueue with the flag <code>VIRTQ_DESC_F_INDIRECT (0x4)</code> set (step 3). The descriptor’s address and length correspond to the indirect table’s ones.</p>
</blockquote>
<p>间接描述符的工作方式与分割情况类似。首先，驱动程序分配一个间接描述符表，每个描述符的布局与内存中任何地方的常规打包描述符相同。之后，它将这个间接表中的每个描述符设置为它想为驱动提供的缓冲区（步骤1-2），并在virtqueue中插入一个设置了标志VIRTQ_DESC_F_INDIRECT（0x4）的描述符（步骤3）。该描述符的地址和长度对应于间接表的那些。</p>
<blockquote>
<p>In packed layout buffers must come in order in the indirect table, and the ID field is completely ignored. Also, the only valid flag for them is <code>VIRTQ_DESC_F_WRITE</code>, others are reserved and ignored by the device. As usual, the driver will notify the device if the conditions for the notification are met (step 4).</p>
</blockquote>
<p>在打包布局中，缓冲区必须按顺序出现在间接表中，ID字段完全被忽略。另外，它们唯一有效的标志是VIRTQ_DESC_F_WRITE，其他的是保留的，被设备忽略。像往常一样，如果通知的条件得到满足，驱动程序将通知设备（步骤4）。</p>
<img src="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/2020-07-15-vdpa-3.png" class="">

<p><strong>Diagram: Driver makes available a descriptor using a packed queue</strong></p>
<p>For example, the driver would need to allocate this 48 bytes table for a 3 descriptors indirect table:</p>
<table>
<thead>
<tr>
<th></th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>0x1000</td>
<td>…</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x81000000</td>
<td>0x1000</td>
<td>…</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0x82000000</td>
<td>0x1000</td>
<td>…</td>
<td>W</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Three descriptor long indirect packed table</strong></p>
<p>And if it introduces the indirect table the first in the descriptor table, assuming it is allocated in <code>0x83000000</code> address:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>48</td>
<td>0</td>
<td>A|I</td>
<td>←</td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Figure: Drivers makes an indirect table available</strong></p>
<p>After indirect buffer consumption, the device needs to return the indirect buffer id (0 in the example) in its used descriptor. The table looks like the return of the first buffer, except for the indirect (I) flag set:</p>
<table>
<thead>
<tr>
<th>Avail idx</th>
<th>Address</th>
<th>Length</th>
<th>ID</th>
<th>Flags</th>
<th>Used idx</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0x80000000</td>
<td>48</td>
<td>0</td>
<td>A|U|I</td>
<td></td>
</tr>
<tr>
<td>→</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td>←</td>
</tr>
</tbody></table>
<p><strong>Figure: Device makes an indirect table used</strong></p>
<p>After that, the device cannot access the memory table anymore unless the driver makes it available again, so the latter can free or reuse it.</p>
<h3 id="Notifications-how-to-manage-interruptions"><a href="#Notifications-how-to-manage-interruptions" class="headerlink" title="Notifications: how to manage interruptions?"></a>Notifications: how to manage interruptions?</h3><blockquote>
<p>Like in the used queue, each side of the communication maintains two identical structures used for controlling notifications between the device and the driver. The driver’s one is read-only by the device, and the device’s one is read-only by the driver.</p>
<p>The struct layout is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct pvirtq_event_suppress &#123; </span><br><span class="line">        le16 desc;</span><br><span class="line">        le16 flags; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Event suppression struct notification</strong></p>
</blockquote>
<p>就像在用过的队列中，通信的每一方都维护着两个相同的结构，用于控制设备和驱动之间的通知。驱动程序的那个结构是设备只读的，而设备的那个结构是驱动程序只读的。</p>
<blockquote>
<p>The member flags can take the values:</p>
<ul>
<li>0: Notifications are enabled</li>
<li>1: Notifications are disabled</li>
<li>2: Notifications are enabled for a specific descriptor, specified from the desc member.</li>
</ul>
<p>If flags value is 2, the other side will notify until the wrap counter matches the most significant bit of desc and the descriptor placed in the position desc discarding that bit is made used/available. For this mode to work, <code>VIRTIO_F_RING_EVENT_IDX</code> flag needs to be negotiated in Virtio device initialization: feature bits.</p>
<p>None of these mechanisms are 100% reliable, since the other side could have sent the notification already when we set the values, so expect it even when disable.</p>
<p>Note that, since the descriptor ring size is not being forced to be a power of two (comparing with the split version), the notification structure can fit in the same page as the descriptor table. This can be advantageous for some implementations.</p>
</blockquote>
<p>成员标志可以采取以下值。</p>
<ul>
<li>0: 通知被启用</li>
<li>1: 通知被禁用</li>
<li>2: 对一个特定的描述符启用通知，由desc成员指定。</li>
</ul>
<p>如果标志值为2，另一方将进行通知，直到wrap计数器与desc的最重要的位相匹配，并且放置在desc位置的描述符放弃该位而被使用/可用。为了使这种模式工作，VIRTIO_F_RING_EVENT_IDX标志需要在Virtio设备初始化中协商：特征位。</p>
<p>这些机制都不是100%可靠的，因为当我们设置这些值时，对方可能已经发送了通知，所以即使在禁用的情况下也要期待它。</p>
<p>请注意，由于描述符环的大小没有被强制为2的幂（与分裂版本相比），通知结构可以与描述符表放在同一页面中。这对某些实现来说是有利的。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><blockquote>
<p>In this series we have taken you through the different virtio data plane layouts and its virtqueues implementations. They are the means for virtio devices and virtio drivers to exchange information.</p>
<p>We start by covering the simpler and less optimized split virtqueue layout. This layout is relatively easy to implement and to debug thus it’s a good entry point for learning the virtio dataplane basics.</p>
<p>We then moved on to the packed virtqueue layout specified in virtio 1.1 which allows requests exchange using a more compact descriptor representation. This avoids all the overhead of scattering the data through memory, avoiding cache contention and reducing the PCI transactions in case of actual hardware.</p>
</blockquote>
<p>在这个系列中，我们已经带你了解了不同的virtio数据平面布局及其virtqueues的实现。它们是virtio设备和virtio驱动交换信息的手段。</p>
<p>我们首先介绍了更简单、更不优化的分离式virtqueue布局。这种布局相对容易实现和调试，因此它是学习virtio数据平面基础知识的一个很好的切入点。</p>
<p>然后，我们转向virtio 1.1中规定的打包式virtqueue布局，它允许使用更紧凑的描述符来交换请求。这避免了在内存中分散数据的所有开销，避免了缓存争用，并在实际硬件的情况下减少了PCI事务。</p>
<blockquote>
<p>We also covered a number of optimizations on top of both ring layouts which depends on the communication/device type or how each part is implemented. Mainly, they are oriented to reduce the communication overhead, both in notifications and in memory transactions. Virtio offers a simple protocol to communicate what features and optimizations support each side, so they can agree on how the data is going to be exchanged and is highly future-proof.</p>
</blockquote>
<p>我们还在这两个环状布局的基础上进行了一些优化，这取决于通信/设备类型或每个部分的实现方式。主要的是，它们的方向是减少通信开销，包括通知和内存事务。Virtio提供了一个简单的协议来沟通每一方支持哪些功能和优化，所以他们可以就数据的交换方式达成一致，并且是高度面向未来的。</p>
<blockquote>
<p>This series covered the essence of the virtio data plane and provided you with the tool to analyze and develop your own virtio device and drivers. It should be noted that this series summarizes the relevant sections from the virtio spec thus you should refer to the spec for additional information and see it as the source of truth.</p>
<p>In the next posts we will return to vDPA including the kernel framework, hands on blogs and vDPA in Kubernetes.</p>
</blockquote>
<p>这个系列涵盖了virtio数据平面的本质，并为你提供了分析和开发自己的virtio设备和驱动的工具。应该注意的是，这个系列总结了virtio规范中的相关部分，因此你应该参考规范以获得更多信息，并将其视为真理的来源。</p>
<p>在接下来的文章中，我们将回到vDPA，包括内核框架、实践博客和Kubernetes中的vDPA。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" data-id="cleh8xpaf0000urwb2g162srp" data-title="Packed virtqueue: How to reduce overhead with virtio" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/23/packed-virtqueue-how-to-reduce-overhead-with-virtio/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-virtqueues-and-virtio-ring-how-the-data-travels" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/" class="article-date">
  <time class="dt-published" datetime="2023-02-22T15:48:33.000Z" itemprop="datePublished">2023-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>►<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/">Virtqueues and virtio ring: How the data travels</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>This post continues where the “<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone">Virtio devices and drivers overview</a>“ leaves off. After we have explained the scenario in the previous post, we are reaching the main point: how does the data travel from the virtio-device to the driver and back?</p>
</blockquote>
<p>这篇文章继续 “Virtio设备和驱动概述 “的内容。在上一篇文章中，我们已经解释了这个场景，我们即将到达重点：数据如何从virtio设备到驱动，然后再返回？</p>
<h2 id="Buffers-and-notifications-The-work-routine"><a href="#Buffers-and-notifications-The-work-routine" class="headerlink" title="Buffers and notifications: The work routine"></a>Buffers and notifications: The work routine</h2><blockquote>
<p>As stated earlier, a virtqueue is just a queue of guest’s buffers that the host consumes, either reading them or writing to them. A buffer can be read-only or write-only from the device point of view, but never both.</p>
</blockquote>
<p>如前所述，virtqueue只是一个guest的缓冲区队列，主机消耗它们，要么读取它们，要么写入它们。从设备的角度来看，一个缓冲区可以是只读的，也可以是只写的，但绝不是两者都是。</p>
<blockquote>
<p>The descriptors can be chained, and the framing of the message can be spread whatever way is more convenient. For example, to spread a 2000 byte message in one single buffer or to use two 1000 byte buffers should be the same. </p>
</blockquote>
<p>描述符可以是链状的，消息的构架可以以任何更方便的方式传播。例如，将2000字节的信息分散在一个单一的缓冲区中，或使用两个1000字节的缓冲区，应该是一样的。</p>
<blockquote>
<p>Also, it provides driver to device notifications (doorbell) method, to signal that one or more buffers have been added to the queue, and vice-versa, devices can interrupt the driver to signal used buffers. It is up to the underlying driver to provide the right method to dispatch the actual notification, for example using PCI interruptions or memory writing: The virtqueue only standardizes the semantics of it.</p>
</blockquote>
<p>另外，它还提供了驱动程序到设备的通知（门铃）方法，以信号显示一个或多个缓冲区已被添加到队列中，反之亦然，设备可以中断驱动程序以信号显示已使用的缓冲区。这取决于底层驱动程序提供正确的方法来调度实际的通知，例如使用PCI中断或内存写入。virtqueue只是对它的语义进行了标准化。</p>
<blockquote>
<p>As stated before, the driver and the device can advise the other to not to emit notifications to reduce its dispatching overhead. Since this operation is asynchronous we will describe how to do so in further sections.</p>
</blockquote>
<p>如前所述，驱动和设备可以建议对方不要发出通知，以减少其调度开销。由于这个操作是异步的，我们将在后续章节中描述如何做到这一点。</p>
<h2 id="Split-virtqueue-the-beauty-of-simplicity"><a href="#Split-virtqueue-the-beauty-of-simplicity" class="headerlink" title="Split virtqueue: the beauty of simplicity"></a>Split virtqueue: the beauty of simplicity</h2><blockquote>
<p>The split virtqueue format separates the virtqueue into three areas, where each area is writable by either the driver or the device, but not both:</p>
<ul>
<li>Descriptor Area: used for describing buffers.</li>
<li>Driver Area: data supplied by driver to the device. Also called avail virtqueue.</li>
<li>Device Area: data supplied by device to driver. Also called used virtqueue.</li>
</ul>
</blockquote>
<p>split virtqueue格式将virtqueue分成三个区域，每个区域都可以被驱动或设备写入，但不能同时写入。</p>
<ul>
<li>描述符区：用于描述缓冲区。</li>
<li>驱动区：由驱动提供给设备的数据。也称为利用虚拟队列。</li>
<li>设备区：由设备提供给驱动的数据。也称为used virtqueue。</li>
</ul>
<blockquote>
<p>They need to be allocated in the driver’s memory for it to be able to access them in a straightforward way. Buffer addresses are stored from the driver’s point of view, and the device needs to perform an address translation. There are many ways for the device to access it depending on the latter nature:</p>
<ul>
<li>For an emulated device in the hypervisor (like qemu), the guest’s address is in its own process memory.</li>
<li>For other emulated devices like vhost-net or vhost-user, a memory mapping needs to be done, like POSIX shared memory. A file descriptor to that memory is shared through vhost protocol.</li>
<li>For a real device a hardware-level translation needs to be done, usually via IOMMU.</li>
</ul>
</blockquote>
<p>它们需要被分配到驱动程序的内存中，以便它能够直接访问它们。缓冲区地址从驱动程序的角度存储，设备需要进行地址转换。根据后者的性质，设备有很多方法可以访问它。</p>
<ul>
<li>对于管理程序中的仿真设备（如qemu），客户的地址在它自己的进程内存中。</li>
<li>对于其他仿真设备，如vhost-net或vhost-user，需要做一个内存映射，像POSIX共享内存一样。该内存的文件描述符是通过vhost协议共享的。</li>
<li>对于一个真实的设备，需要做一个硬件级的转换，通常是通过IOMMU。</li>
</ul>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig1.png" class="">

<p><strong>Shared memory with split ring elements</strong></p>
<h3 id="Descriptor-ring-Where-is-my-data"><a href="#Descriptor-ring-Where-is-my-data" class="headerlink" title="Descriptor ring: Where is my data?"></a>Descriptor ring: Where is my data?</h3><blockquote>
<p>The descriptor area (or descriptor ring) is the first one that needs to be understood. It contains an array of a number of guest addressed buffers and its length. Each descriptor also contains a set of flags indicating more information about it. For example, the buffer continues in another descriptor buffer if the 0x1 bit is set, and the buffer is write-only for the device if the bit 0x2 is set, and is read-only if it is clear.</p>
</blockquote>
<p>描述符区（或描述符环）是第一个需要被理解的。它包含一个由若干客体寻址的缓冲区和其长度组成的数组。每个描述符还包含一组标志，表示关于它的更多信息。例如，如果0x1位被设置，缓冲区在另一个描述符缓冲区中继续，如果0x2位被设置，缓冲区对设备来说是只写的，如果它被清除，则是只读的。</p>
<blockquote>
<p>This is the layout of a single descriptor. We will call leN for N bits in little endian format.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_desc</span> &#123;</span> </span><br><span class="line">        le64 addr;</span><br><span class="line">        le32 len;</span><br><span class="line">        le16 flags;</span><br><span class="line">        le16 next; <span class="comment">// Will explain this one later in the section &quot;Chained descriptors&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Split Virtqueue descriptor layout</strong></p>
</blockquote>
<p>这是一个单一描述符的布局。我们将调用leN来表示little endian格式的N位。</p>
<h3 id="Avail-ring-Supplying-data-to-the-device"><a href="#Avail-ring-Supplying-data-to-the-device" class="headerlink" title="Avail ring: Supplying data to the device"></a>Avail ring: Supplying data to the device</h3><blockquote>
<p>The next interesting structure is the driver area, or avail ring. Is the room where the driver places the descriptor (indexes) the device is going to consume. Note that placing a buffer here doesn’t mean that the device needs to consume immediately: virtio-net, for example, provides a bunch of descriptors for packet receiving that are only used by the device when a packet arrives, and are “ready to consume” until that moment.</p>
</blockquote>
<p>下一个有趣的结构是驱动区，或者说Avail环。是驱动程序放置设备要消耗的描述符（索引）的空间。注意，在这里放置缓冲区并不意味着设备需要立即消费：例如，virtio-net为数据包接收提供了一堆描述符，这些描述符只有在数据包到达时才会被设备使用，直到那一刻才会 “准备消费”。</p>
<blockquote>
<p>The avail ring has two important fields that only the driver can write and the device only can read them: idx and flags. The idx field indicates where the driver would put the next descriptor entry in the avail ring (modulo the queue size). On the other hand, the least significant bit of flags indicates if the driver wants to be notified or not (called <code>VIRTQ_AVAIL_F_NO_INTERRUPT</code>).</p>
</blockquote>
<p>avail环有两个重要的字段，只有驱动程序可以写入，设备只能读取它们：idx和flags。idx字段指出了驱动程序将把下一个描述符条目放在avail ring中的位置（modulo the queue size）。另一方面，flags的最小有效位表示驱动是否要被通知（称为<code>VIRTQ_AVAIL_F_NO_INTERRUPT</code>）。</p>
<blockquote>
<p>After these two fields, an array of integers of the same length as the descriptors ring. So the avail virtqueue layout is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_avail</span> &#123;</span></span><br><span class="line">        le16 flags;</span><br><span class="line">        le16 idx;</span><br><span class="line">        le16 ring[ <span class="comment">/* Queue Size */</span> ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Avail virtqueue layout</strong></p>
</blockquote>
<p>在这两个字段之后，是一个与描述符环相同长度的整数阵列。因此，avail virtqueue layout:</p>
<blockquote>
<p><strong>Figure 1</strong> shows a descriptor table with a 2000 bytes long buffer that starts in position 0x8000, and an avail ring that still does not have any entry. After all the steps, a components diagram highlighting the descriptor area update. The first step for the driver is to allocate the buffer with the memory and fill it (this is the step 1 in the “Process to make a buffer available” diagram), and to make available on the descriptor area after that (step 2).</p>
</blockquote>
<p>图1显示了一个具有2000字节长的缓冲区的描述符表，它从位置0x8000开始，而一个利用环仍然没有任何条目。在所有的步骤之后，一个组件图突出了描述符被更新的部分。驱动程序的第一步是分配缓冲区的内存并将其填满（这是 “使缓冲区可用的过程 “图中的第1步），然后在描述符区上使其可用（第2步）。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig2.png" class="">

<p><strong>Figure 1: Driver writes a buffer in descriptor ring</strong></p>
<blockquote>
<p>After populating descriptor entry, driver advises of it using the avail ring: It writes the descriptor index #0 in the first entry of the avail ring, and updates idx entry accordly. The result of this is shown in Figure 2. In the case that supply chained buffers, only the descriptor head index should be added this way, and avail idx would increase only by 1. This is the step 3 in the diagram.</p>
</blockquote>
<p>在填充完描述符条目后，驱动通知它使用空闲环。它将描述符的索引#0写在avail ring的第一个条目中，并相应地更新idx条目。其结果如图2所示。在提供链式缓冲区的情况下，只有描述符头部的索引应该这样添加，而avail idx只增加1。这就是图中的第三步。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig3.png" class="">

<p><strong>Figure 2: Driver offers the buffer with avail ring</strong></p>
<blockquote>
<p>From now on, the driver should not modify the available descriptor or the exposed buffer at any moment: It is under the device’s control. Now the driver needs to notify the device if the latter has enabled notifications at that moment (more on how the device manages this later). This is the last step 4 in the diagram.</p>
</blockquote>
<p>从现在开始，驱动程序不应该在任何时候修改可用的描述符或暴露的缓冲区。这是由设备控制的。现在，驱动程序需要通知设备，如果后者在当时启用了通知功能（后面会有更多关于设备如何管理的内容）。这就是图中的最后一步4。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig4.png" class="">

<p><strong>Diagram: Process to make a buffer available</strong></p>
<blockquote>
<p>The avail ring must be able to hold the same number of descriptors as the descriptor area, and the descriptor area must have a size power of two, so idx wraps naturally at some point. For example, if the ring size is 256 entries, idx 1 references the same descriptor as idx 257, 513… And it will wrap at a 16 bit boundary. This way, neither side needs to worry about processing an invalid idx: They are all valid.</p>
</blockquote>
<p>Avail环必须能够容纳与描述符区相同数量的描述符，描述符区的大小必须是2的幂，所以idx在某一点上自然会被包裹起来。例如，如果环的大小是256个条目，idx 1引用的描述符与idx 257、513…相同。而它将在16位边界处被包裹起来。这样一来，双方都不需要担心处理无效的idx。它们都是有效的。</p>
<blockquote>
<p>Note that descriptors can be added in any order to the avail ring, one does not need to start from descriptor table entry 0 nor continue by the next descriptor.</p>
</blockquote>
<p>请注意，描述符可以以任何顺序添加到利用环中，不需要从描述符表的第0条开始，也不需要从下一个描述符继续。</p>
<h3 id="Chained-descriptors-Supplying-large-data-to-the-device"><a href="#Chained-descriptors-Supplying-large-data-to-the-device" class="headerlink" title="Chained descriptors: Supplying large data to the device"></a>Chained descriptors: Supplying large data to the device</h3><blockquote>
<p>The driver can also chain more than one descriptor using its next member. If the NEXT (0x1) flag of a descriptor is set, the data continue in another buffer, making a chain of descriptors. Note that the descriptors in a chain do not share flags: Some descriptors can be read-only, and the others can be write-only. In this case, write-only descriptors must come after all write-only ones.</p>
</blockquote>
<p>驱动程序也可以使用其下一个成员来连锁一个以上的描述符。如果一个描述符的NEXT(0x1)标志被设置，数据在另一个缓冲区中继续，形成一个描述符链。注意，一个链中的描述符不共享标志。有些描述符可以是只读的，而其他描述符可以是只写的。在这种情况下，只写的描述符必须排在所有只写的描述符之后。</p>
<blockquote>
<p>For example, if the driver has sent us two buffers in a chain with descriptor table indexes 0 and 1 as first operation, the device would see the scenario in Figure 3, and it would be the step 2 again.</p>
</blockquote>
<p>例如，如果驱动程序在描述符表索引为0和1的链中向我们发送了两个缓冲区，作为第一次操作，设备会看到图3中的情景，它将再次成为步骤2。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig5.png" class="">

<p><strong>Figure 3: Device sees chained buffers</strong></p>
<h3 id="Used-ring-When-the-device-is-done-with-the-data"><a href="#Used-ring-When-the-device-is-done-with-the-data" class="headerlink" title="Used ring: When the device is done with the data"></a>Used ring: When the device is done with the data</h3><blockquote>
<p>The device employs the used ring to return the used (read or written) buffers to the driver. As the avail ring, it has the flags and idx members. They have the same layout and serve the same purpose, although the notification flag is now called <code>VIRTQ_USED_F_NO_NOTIFY</code>.</p>
</blockquote>
<p>设备使用使用过的环将使用过的（读或写）缓冲区返回给驱动。与avail环一样，它也有flags和idx成员。它们具有相同的布局和相同的目的，尽管通知标志现在被称为<code>VIRTQ_USED_F_NO_NOTIFY</code>。</p>
<blockquote>
<p>After them, it maintains an array of used descriptors. In this array, the device returns not only the descriptor index but also the used length in case of writing.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_used</span> &#123;</span></span><br><span class="line">        le16 flags;</span><br><span class="line">        le16 idx;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">virtq_used_elem</span> <span class="title">ring</span>[ /* <span class="title">Queue</span> <span class="title">Size</span> */];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtq_used_elem</span> &#123;</span></span><br><span class="line">        <span class="comment">/* Index of start of used descriptor chain. */</span></span><br><span class="line">        le32 id;</span><br><span class="line">        <span class="comment">/* Total length of the descriptor chain which was used (written to) */</span></span><br><span class="line">        le32 len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing: Used virtqueue layout</strong></p>
</blockquote>
<p>在它们之后，它维护一个已使用的描述符数组。在这个数组中，设备不仅返回描述符的索引，而且在写入的情况下返回已使用的长度。</p>
<blockquote>
<p>In case of returning a chain of descriptors, only the id of the head of the chain is returned, and the total written length through all descriptors, not increasing it when data is read. The descriptor table is not touched at all, it is read-only for the device. This is step 5 in the “Process to make a buffer as used” diagram.</p>
</blockquote>
<p>在返回描述符链的情况下，只返回链头的id，以及通过所有描述符的总写入长度，在读取数据时不增加它。描述符表完全不被触及，它对设备来说是只读的。这是 “制作使用的缓冲区的过程 “图中的第5步。</p>
<blockquote>
<p>For example, if the device uses the chain of descriptors exposed in the Chained descriptors version:</p>
</blockquote>
<p>例如，如果设备使用链式描述符版本中暴露的链式描述符:</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig6.png" class="">

<p><strong>Figure 4: Device returns buffer chain</strong></p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig7.png" class="">

<p><strong>Diagram: Process to mark a buffer as used</strong></p>
<blockquote>
<p>Lastly, the device will notify the driver if it sees that the driver wants to be notified, using the used queue flags to know it (step 6).</p>
</blockquote>
<p>最后，如果设备看到驱动想被通知，它将通知驱动，使用使用的队列标志来知道它（步骤6）。</p>
<h3 id="Indirect-descriptors-supplying-a-lot-of-data-to-the-device"><a href="#Indirect-descriptors-supplying-a-lot-of-data-to-the-device" class="headerlink" title="Indirect descriptors: supplying a lot of data to the device"></a>Indirect descriptors: supplying a lot of data to the device</h3><blockquote>
<p>Indirect descriptors are a way to dispatch a larger number of descriptors in a batch, increasing the ring capacity. The driver stores a table of indirect descriptors (the same layout as the regular descriptors) anywhere in memory, and inserts a descriptor in the virtqueue with the flag <code>VIRTQ_DESC_F_INDIRECT (0x4)</code> set. The descriptor’s address and length correspond to the indirect table’s ones.</p>
</blockquote>
<p>间接描述符是一种在一个批次中调度更多描述符的方法，增加了环的容量。驱动程序在内存的任何地方存储一个间接描述符表（与普通描述符的布局相同），并在virtqueue中插入一个描述符，并设置标志<code>VIRTQ_DESC_F_INDIRECT（0x4）</code>。该描述符的地址和长度对应于间接表的长度。</p>
<blockquote>
<p>If we want to add the chain described in section Chained descriptors to an indirect table, the driver first allocates the memory region of 2 entries (32 bytes) to hold the latter (step 2 in the diagram after allocate the buffers in the step 1):</p>
<table>
<thead>
<tr>
<th>Buffer</th>
<th>Len</th>
<th>Flags</th>
<th>Next</th>
</tr>
</thead>
<tbody><tr>
<td>0x8000</td>
<td>0x2000</td>
<td>W|N</td>
<td>1</td>
</tr>
<tr>
<td>0xD000</td>
<td>0x2000</td>
<td>W</td>
<td>…</td>
</tr>
</tbody></table>
<p><strong>Figure 4: Indirect table for indirect descriptors</strong></p>
</blockquote>
<p>如果我们想在一个间接表上添加链式描述符，驱动程序首先分配2个条目（32字节）的内存区域来容纳后者（图中的第2步，在第1步中分配了缓冲区之后）。</p>
<blockquote>
<p>Let’s suppose it has been allocated on memory position <code>0x2000</code>, and it is the first descriptor made available. As usual, the first step is to include it in the Descriptor area (step 3 in the diagram), so it would look like:</p>
<table>
<thead>
<tr>
<th>Descriptor Area</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Buffer</td>
<td>Len</td>
<td>Flags</td>
<td>Next</td>
</tr>
<tr>
<td>0x2000</td>
<td>32</td>
<td>I</td>
<td>…</td>
</tr>
</tbody></table>
<p><strong>Figure 5: Add indirect table to Descriptor area</strong></p>
</blockquote>
<p>让我们假设它被分配在内存位置<code>0x2000</code>，并且是第一个可用的描述符。像往常一样，第一步是把它纳入描述符区域（图中的第3步），所以它看起来像。</p>
<blockquote>
<p>After that, the steps are the same as with regular descriptors: The driver adds the index of the descriptor marked with the flag in the descriptor area to the avail ring (#0 in this case, step 4 in the diagram), and notify the device as usual (step 5).</p>
</blockquote>
<p>之后，步骤与普通描述符相同。驱动程序将描述符区域中标有标志的描述符的索引添加到利用环中（本例中为#0，图中第4步），并像往常一样通知设备（第5步）。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig8.png" class="">

<p><strong>Diagram: Driver make available indirect descriptors</strong></p>
<blockquote>
<p>For the device to use its data, and would use the same memory addresses to return its <code>0x3000</code> bytes (all <code>0x8000-0x9FFF</code> and <code>0xD000-0xDFFF</code>) (Step 6 and 7, same as with regular descriptors). Once used by the device, the driver can release the indirect memory or do whatever it wants with it, as it could do with any regular buffer.</p>
</blockquote>
<p>对于设备使用其数据，并将使用相同的内存地址来返回其0x3000字节（所有0x8000-0x9FFF和0xD000-0xDFFF）（步骤6和7，与常规描述符相同）。一旦被设备使用，驱动程序可以释放间接内存或对其做任何事情，就像它可以对任何常规缓冲区做的那样。</p>
<img src="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/2020-07-08-virtio-fig9.png" class="">

<p><strong>Diagram: Device mark the indirect descriptor as used</strong></p>
<blockquote>
<p>Descriptors with <code>INDIRECT</code> flag cannot have <code>NEXT</code> or <code>WRITE</code> flags set, so you cannot chain indirect descriptors in the descriptor table, and the indirect table can contain at maximum the same number of descriptors as the descriptor table.</p>
</blockquote>
<p>带有INDIRECT标志的描述符不能设置NEXT或WRITE标志，所以不能在描述符表中连锁间接描述符，间接表最多可以包含与描述符表相同数量的描述符。</p>
<h3 id="Notifications-Learning-the-“do-not-disturb”-mode"><a href="#Notifications-Learning-the-“do-not-disturb”-mode" class="headerlink" title="Notifications. Learning the “do not disturb” mode"></a>Notifications. Learning the “do not disturb” mode</h3><blockquote>
<p>In many systems used and available buffer notifications involve significant overhead. To mitigate it, each virtring maintains a flag to indicate when it wants to be notified. Remember that the driver’s one is read-only by the device, and the device’s one is read-only by the driver.</p>
</blockquote>
<p>在许多系统中，使用的和可用的缓冲区通知涉及大量的开销。为了减轻它，每个virtring都维护着一个标志，以表明它什么时候想被通知。记住，驱动的那个是设备只读的，而设备的那个是驱动只读的。</p>
<blockquote>
<p>We already know all of this, and its use is pretty straightforward. The only thing you need to take care of is the asynchronous nature of this method: The side of the communication that disables or enables it can’t be sure that the other end is going to know the change, so you can miss notifications or to have more than expected.</p>
</blockquote>
<p>我们已经知道了这些，它的使用是非常直接的。你唯一需要注意的是这个方法的异步性。通信中禁用或启用它的一方不能确定另一端是否会知道这个变化，所以你可能会错过通知或要比预期的多。</p>
<blockquote>
<p>A more effective way of notifications toggle is enabled if the <code>VIRTIO_F_EVENT_IDX</code> feature bit is negotiated by device and driver: Instead of disable them in a binary fashion, driver and device can specify how far the other can progress before a notification is required using an specific descriptor id. This id is advertised using a extra le16 member at the end of the structure, so they grow like this:</p>
</blockquote>
<p>如果设备和驱动协商<code>VIRTIO_F_EVENT_IDX</code>特性位，就可以启用一种更有效的通知切换方式。而不是以二进制的方式禁用它们，驱动和设备可以使用一个特定的描述符id来指定对方在需要通知之前可以进展到什么程度。这个id在结构的末尾使用一个额外的le16成员进行宣传，所以它们的增长方式是这样的。</p>
<blockquote>
<p>The struct layout is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct virtq_avail &#123;              struct virtq_used &#123;</span><br><span class="line">  le16 flags;                       le16 flags;</span><br><span class="line">  le16 idx;                         le16 idx;</span><br><span class="line">  le16 ring[ &#x2F;* Queue Size *&#x2F; ];    struct virtq_used_elem ring[Q. size];</span><br><span class="line">  le16 used_event;                  le16 avail_event;</span><br><span class="line">&#125;;                                &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Listing 3: Event suppression struct notification</strong></p>
</blockquote>
<blockquote>
<p>This way, every time the driver wants to make available a buffer it needs to check the avail_event on the used ring: If driver’s idx field was equal to avail_event, it’s time to send a notification, ignoring the lower bit of used ring flags member (<code>VIRTQ_USED_F_NO_NOTIFY</code>).</p>
</blockquote>
<p>这样一来，每次驱动程序想要提供一个缓冲区时，它需要检查已用环上的avail_event。如果驱动的idx字段等于avail_event，那么就是发送通知的时候了，忽略已用环标志成员的低位（<code>VIRTQ_USED_F_NO_NOTIFY</code>）。</p>
<blockquote>
<p>Similarly, if <code>VIRTIO_F_EVENT_IDX</code> has been negotiated, the device will check used_event to know if it needs to send a notification or not. This can be very effective for maintaining a virtqueue of buffers for the device to write, like in the virtio-net device receive queue.</p>
</blockquote>
<p>同样，如果<code>VIRTIO_F_EVENT_IDX</code>已经协商好了，设备将检查used_event以知道它是否需要发送通知。这对于维护一个供设备写入的缓冲区的虚拟队列非常有效，就像在virtio-net设备接收队列中一样。</p>
<blockquote>
<p>In our next post, we’re going to wrap up and take a look at a number of optimizations on top of both ring layouts which depend on the communication/device type or how each part is implemented.</p>
</blockquote>
<p>在我们的下一篇文章中，我们将总结并看看在这两个环形布局之上的一些优化，这些优化取决于通信/设备类型或每个部分的实现方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/" data-id="clefunqbh0000l2wb9oyqhw88" data-title="Virtqueues and virtio ring: How the data travels" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/22/virtqueues-and-virtio-ring-how-the-data-travels/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-virtio-devices-and-drivers-overview-the-headjack-and-the-phone" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/" class="article-date">
  <time class="dt-published" datetime="2023-02-22T14:12:09.000Z" itemprop="datePublished">2023-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/translation/">translation</a>►<a class="article-category-link" href="/categories/virtualization/translation/virtio/">virtio</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/">Virtio devices and drivers overview: The headjack and the phone</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>This three-part series will take you through the main virtio data plane layouts: the split virtqueue and the packed virtqueue. This is the basis for the communication between hosts and virtual environments like guests or containers.</p>
</blockquote>
<p>这个由三部分组成的系列，将会带你了解virtio数据平面的布局，split virtuqueue 和 packed virtqueue。这是物理机与虚拟环境比如虚拟机或容器交流的基础。</p>
<blockquote>
<p>One of the challenges when coming to explain these approaches is the lack of documentation and the many terms involved. This set of posts attempts to demystify the virtio data plane and provide you with a clear down to earth explanation of what is what.</p>
</blockquote>
<p>在解释这些方法时，面临的挑战之一是缺乏文档和涉及的许多术语。这组文章试图揭开virtio数据平面的神秘面纱，并为你提供一个清晰的解释，说明什么是什么。</p>
<blockquote>
<p>This is a technical deep dive and is relevant for those who are interested in the bits and bytes of things. It details the communication format between the different virtio parts and data plane protocols.</p>
</blockquote>
<p>这是一个技术上的深入研究，与那些对事物的比特和字节感兴趣的人有关。它详细介绍了不同virtio部件和数据平面协议之间的通信格式。</p>
<blockquote>
<p>While further extensions, optimizations and features are being added to both virtqueue versions, to improve performance and to simplify implementation, the core of the virtqueue operations remains the same. This is because it has been designed with extensibility in mind. </p>
</blockquote>
<p>虽然两个版本的virtqueue都加入了进一步的扩展、优化和功能，以提高性能和简化实现，但virtqueue操作的核心仍然保持不变。这是因为它在设计时就考虑到了可扩展性。</p>
<blockquote>
<p>Packed virtqueue, which complements the split virtqueue has been merged in the virtio 1.1 spec, and successfully implemented in both emulated devices (qemu, virtio_net, dpdk) and physical devices.</p>
</blockquote>
<p>作为split virtqueue的补充，packed virtqueue已被合并到virtio 1.1规范中，并在模拟设备（qemu、virtio_net、dpdk）和物理设备中成功实现。</p>
<blockquote>
<p>We’ll start with an overview of the virtio device, drivers and their data plane interaction. Then we’ll move on to explain the details of the split virtqueue ring layout. This is followed by an overview of the packed ring layout and the advantages it brings over the split virtqueue approach.</p>
</blockquote>
<p>我们将首先概述virtio设备、驱动程序和它们的数据平面互动。然后，我们将继续解释split virtqueue ring layout的细节。随后，我们将概述packed ring layout以及它比split virtqueue方法带来的优势。</p>
<h2 id="Virtio-devices-and-drivers-overview-who-is-who"><a href="#Virtio-devices-and-drivers-overview-who-is-who" class="headerlink" title="Virtio devices and drivers overview: who is who"></a>Virtio devices and drivers overview: who is who</h2><blockquote>
<p>This section provides a brief overview of the virtio devices, virtio drivers, examples of the different architectures you can use and the different components. If you’re already familiar with these topics or you have already followed the virtio networking series you can jump directly to the next section focusing on the virtio rings.</p>
</blockquote>
<p>本节简要介绍了virtio设备、virtio驱动、你可以使用的不同架构的例子以及不同的组件。如果你已经熟悉了这些主题，或者你已经关注了virtio网络系列，你可以直接跳到下一节，重点介绍virtio rings。</p>
<h3 id="Virtio-devices-In-and-out-the-virtual-world"><a href="#Virtio-devices-In-and-out-the-virtual-world" class="headerlink" title="Virtio devices: In and out the virtual world"></a>Virtio devices: In and out the virtual world</h3><blockquote>
<p>A virtio device is a device that exposes a virtio interface for the software to manage and exchange information. It can be exposed to the emulated environment using PCI, Memory Mapping I/O (Just to expose the device in a region of memory) and S/390 Channel I/O. Part of the communication needs to be delegated to theses, like device discovery.</p>
</blockquote>
<p>Virtio设备是一个暴露出virtio接口的设备，供软件管理和交换信息。它可以使用PCI、内存映射I/O（只是在内存的一个区域暴露设备）和S/390通道I/O暴露在仿真环境中。部分通信需要委托给这些设备，如设备发现。</p>
<blockquote>
<p>Its main task is to convert the signal from the format they have outside of the virtual environment (the VM, the container, etc) to the format they need to be exchanged through the virtio dataplane and vice-versa. This signal could be real (for example the electricity or the light from a NIC) or already virtual (like the representation the host has from a network packet).</p>
</blockquote>
<p>它的主要任务是将信号从它们在虚拟环境（虚拟机、容器等）之外的格式转换成它们需要通过virtio数据线交换的格式，反之亦然。这个信号可以是真实的（例如来自网卡的电或光），或者已经是虚拟的（如主机从网络包中得到的表示）。</p>
<blockquote>
<p>The virtio interface consist of the following mandatory parts (<a target="_blank" rel="noopener" href="https://docs.oasis-open.org/virtio/virtio/v1.1/cs01/virtio-v1.1-cs01.html#x1-90002">virtio1.1 spec</a>): </p>
<ul>
<li>Device status field</li>
<li>Feature bits</li>
<li>Notifications</li>
<li>One or more virtqueues</li>
</ul>
<p>Now we’ll provide additional details to each of these parts and how the device and driver starts communicating using these.</p>
</blockquote>
<p>virtio接口由以下强制性部分组成（virtio1.1规范）:</p>
<ul>
<li>设备状态字段</li>
<li>特征位</li>
<li>通知</li>
<li>一个或多个虚拟队列</li>
</ul>
<p>现在我们将提供这些部分的额外细节，以及设备和驱动如何使用这些部分开始通信。</p>
<h3 id="Device-status-field-Is-everything-ok"><a href="#Device-status-field-Is-everything-ok" class="headerlink" title="Device status field: Is everything ok?"></a>Device status field: Is everything ok?</h3><blockquote>
<p>The device status field is a sequence of bits the device and the driver use to perform their initialization. We can imagine it as traffic lights on a console, each part set and clear each bit indicating their status.</p>
</blockquote>
<p>设备状态字段是设备和驱动程序用来执行其初始化的一个比特序列。我们可以把它想象成控制台上的交通灯，每个部分设置和清除每个位，表示它们的状态。</p>
<blockquote>
<p>The guest or the driver set the bit <code>ACKNOWLEDGE</code> (0x1) in the device status field to indicate that it acknowledges the device, and the bit <code>DRIVER</code> (0x2) to indicate an initialization in progress. After that, it starts a feature negotiation using the feature bits (more on this later), and sets bit <code>DRIVER_OK</code> (0x4) and <code>FEATURES_OK</code> (0x8) to acknowledge the features, so communication can start. If the device wants to indicate a fatal failure, it can set bit <code>DEVICE_NEEDS_RESET</code> (0x40), and the driver can do the same with bit <code>FAILED</code> (0x80).</p>
</blockquote>
<p>访客或驱动程序在设备状态字段中设置位<code>ACKNOWLEDGE</code>（0x1）以表示它确认了设备，并设置位<code>DRIVER</code>（0x2）以表示初始化正在进行。之后，它开始使用功能位进行功能协商（后面会详细介绍），并设置位<code>DRIVER_OK</code>（0x4）和<code>FEATURES_OK</code>（0x8）来确认功能，这样就可以开始通信了。如果设备想指示一个致命的故障，它可以设置位<code>DEVICE_NEEDS_RESET</code> (0x40)，而驱动程序可以用位<code>FAILED</code> (0x80)做同样的事情。</p>
<blockquote>
<p>The device communicates the location of these bits using transport specific methods, like PCI scanning or knowing the address for MMIO.</p>
</blockquote>
<p>设备使用传输的特定方法来传达这些位的位置，如PCI扫描或知道MMIO的地址。</p>
<h3 id="Feature-bits-Setting-the-communication-agreement-points"><a href="#Feature-bits-Setting-the-communication-agreement-points" class="headerlink" title="Feature bits: Setting the communication agreement points"></a>Feature bits: Setting the communication agreement points</h3><blockquote>
<p>Device’s feature bits are used to communicate what features it supports, and to agree with the drivers about what of them will be used. These can be device-generic or device-specific. As an example of the first case, a bit can acknowledge if the device supports SR-IOV or what memory mode can be used. An example of the second case can be the different offloads it can perform, like checksumming or scatter-gather If the device is a network interface.</p>
</blockquote>
<p>设备的功能位用于交流它支持哪些功能，并与驱动程序商定将使用其中哪些功能。这些位可以是设备通用的，也可以是设备特定的。作为第一种情况的一个例子，一个比特可以确认设备是否支持SR-IOV或者可以使用什么内存模式。第二种情况的一个例子是，如果设备是一个网络接口，它可以执行不同的卸载，如校验和或散点收集。</p>
<blockquote>
<p>After the device initialization exposed in the previous section, the former reads the feature bits the device offers, and sends back the subset that it can handle. If they agree on them, the driver will allocate and inform about the virtqueues to the device, and all other configuration needed.</p>
</blockquote>
<p>在上一节暴露的设备初始化之后，前者会读取设备提供的功能位，并发回它能处理的子集。如果他们达成一致，驱动程序将分配和通知设备的虚拟队列，以及所有其他需要的配置。</p>
<h3 id="Notifications-You-have-work-to-do"><a href="#Notifications-You-have-work-to-do" class="headerlink" title="Notifications: You have work to do"></a>Notifications: You have work to do</h3><blockquote>
<p>Devices and drivers must notify that they have information to communicate using a notification. While the semantic of these is specified in the standard, the implementation of these are transport specific, like a PCI interruption or to write to a specific memory location. The device and the driver needs to expose at least one notification method. We will expand on this later in future sections.</p>
</blockquote>
<p>设备和驱动程序必须通知他们有使用通知的信息进行通信。虽然这些的语义是在标准中规定的，但这些的实现是特定于传输的，比如PCI中断或写到一个特定的内存位置。设备和驱动程序需要公开至少一个通知方法。我们将在以后的章节中对此进行阐述。</p>
<h3 id="One-or-more-virtqueues-The-communication-vehicles"><a href="#One-or-more-virtqueues-The-communication-vehicles" class="headerlink" title="One or more virtqueues: The communication vehicles"></a>One or more virtqueues: The communication vehicles</h3><blockquote>
<p>A virtqueue is just a queue of guest’s buffers that the host consumes, either reading them or writing to them, and returns to the guest. The current memory layout of a virtqueue implementation is a circular ring, so it is often called the virtring or vring.</p>
<p>They will be the main topic of the next section, Virtqueues and virtio ring, so at this moment is enough with that definition.</p>
</blockquote>
<p>virtqueue只是一个guest缓冲区的队列，主机消耗这些缓冲区，要么读取它们，要么写入它们，然后返回给客体。目前virtqueue实现的内存布局是一个圆形的环，所以它通常被称为virtring或vring。</p>
<p>它们将是下一节的主要话题，即virtqueues和virtio ring，所以此刻有了这个定义就足够了。</p>
<h2 id="Virtio-drivers-The-software-avatar"><a href="#Virtio-drivers-The-software-avatar" class="headerlink" title="Virtio drivers: The software avatar"></a>Virtio drivers: The software avatar</h2><blockquote>
<p>The virtio driver is the software part in the virtual environment that talks with the virtio device using the relevant parts of the virtio spec.</p>
<p>Generally speaking, its virtio control plane tasks are:</p>
<ul>
<li>Look for the device</li>
<li>To allocate shared memory in the guest for the communication</li>
</ul>
<p>Start it using the protocol in Virtio devices.</p>
</blockquote>
<p>virtio驱动是虚拟环境中的软件部分，它使用virtio规范的相关部分与virtio设备对话。</p>
<p>一般来说，其virtio控制面的任务是。</p>
<ul>
<li>寻找设备</li>
<li>在客户中为通信分配共享内存</li>
</ul>
<p>使用virtio设备中的协议启动它。</p>
<h3 id="Devices-and-drivers-interaction-The-scenarios"><a href="#Devices-and-drivers-interaction-The-scenarios" class="headerlink" title="Devices and drivers interaction: The scenarios"></a>Devices and drivers interaction: The scenarios</h3><blockquote>
<p>In this section we are going to locate each virtio networking element (device, driver, and how the communication works) in three different architectures, to provide both a common frame to start explaining the virtio data plane and to show how adaptive it is. We have already presented these elements in past posts, so you can skip this section if you are a virtio-net series reader. On the other hand, if you have not read them, you can use them as a reference to understand this part better.</p>
</blockquote>
<p>在这一节中，我们将把每个virtio网络元素（设备、驱动和通信如何工作）放在三个不同的架构中，以提供一个共同的框架来开始解释virtio数据平面，并展示它的适应性。我们已经在过去的文章中介绍了这些元素，所以如果你是virtio-net系列的读者，你可以跳过这一部分。另一方面，如果你没有读过这些文章，你可以把它们作为参考来更好地理解这一部分。</p>
<blockquote>
<p>In Introduction to virtio-networking and vhost-net we showed the environment in which qemu created an emulated net device and offered it to the guest’s virtio-net driver. In this environment, the driver notifications are routed from whatever method is exposed to guests (usually, PCI) to KVM interruptions that stop the guest’s processor and return the control to the host (vmexit). Similarly, the device notifications are a special ioctl the host can send to the KVM device (vCPU IRQ). QEMU can access virtqueue information using the shared memory.</p>
</blockquote>
<p>在介绍virtio-networking和vhost-net时，我们展示了qemu创建一个模拟的net设备并将其提供给客户的virtio-net驱动程序的环境。在这个环境中，驱动程序的通知从任何暴露给客体的方法（通常是PCI）被路由到KVM中断，停止客体的处理器并将控制权返回给主机（vmexit）。同样地，设备通知是主机可以向KVM设备发送的特殊ioctl（vCPU IRQ）。QEMU可以使用共享内存访问virtqueue信息。</p>
<blockquote>
<p>Please note the implications of the virtio rings shared memory concept: The memory the driver and the device access is the same page in RAM, they are not two different regions that follow a protocol to synchronize.</p>
</blockquote>
<p>请注意virtio环的共享内存概念的含义。驱动程序和设备访问的内存是RAM中的同一个页面，它们不是两个不同的区域，它们遵循一个协议来进行同步。</p>


<p><em>Figure 1: Qemu emulated device component diagram</em></p>
<blockquote>
<p>Since the notification now needs to travel from the guest (KVM), to QEMU, and then to the kernel for the latter to forward the network frame, we can spawn a thread in the kernel with access to the guest’s shared memory mapping and then let it handle the virtio dataplane.</p>
</blockquote>
<p>由于通知现在需要从guest（KVM）到QEMU，再到内核，以便后者转发网络帧，我们可以在内核中生成一个线程，访问客体的共享内存映射，然后让它处理virtio数据平面。</p>
<blockquote>
<p>In that context, QEMU initiates the device using the virtio dataplane, and then forwards the virtio device status to vhost-net, delegating the data plane to it. In this scenario, KVM will use an event file descriptor (eventfd) to communicate the device interruptions, and expose another one to receive CPU interruptions. The guest does not need to be aware of this change, it will operate as the previous scenario.</p>
</blockquote>
<p>在这种情况下，QEMU使用virtio数据平面启动设备，然后将virtio设备状态转发给vhost-net，将数据平面委托给它。在这种情况下，KVM将使用一个事件文件描述符（eventfd）来传达设备中断，并公开另一个文件描述符来接收CPU中断。guest不需要意识到这种变化，它将像之前的方案一样操作。</p>
<blockquote>
<p>Also, in order to increase the performance, we created an in-kernel virtio-net device (called vhost-net) to offload the data plane directly to the kernel, where packet forwarding takes place:</p>
</blockquote>
<p>另外，为了提高性能，我们创建了一个内核内的virtio-net设备（称为vhost-net），将数据平面直接卸载到内核，在那里进行数据包转发。</p>
<img src="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/2020-06-18-virtio-fig2.png" class="">

<p><em>Figure 2: Virtio-net components diagram</em></p>
<blockquote>
<p>Later on, we moved the virtio device from the kernel to an userspace process in the host (covered in the post “A journey to the vhost-users realm”) that can run a packet forwarding framework like DPDK. The protocol to set all this up is called virtio-user.</p>
</blockquote>
<p>后来，我们把virtio设备从内核移到了主机的用户空间进程中（在 “通往vhost-users领域的旅程 “一文中有所涉及），该进程可以运行像DPDK这样的包转发框架。设置这一切的协议被称为virtio-user。</p>
<img src="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/2020-06-18-virtio-fig3.png" class="">

<p><em>Figure 3: Virtio-user components diagram</em></p>
<blockquote>
<p>It even allows guests to run virtio drivers in guest’s userland, instead of the kernel! In this case, virtio names driver the process that is managing the memory and the virtqueues, not the kernel code that runs in the guest.</p>
</blockquote>
<p>它甚至允许客户在客户的用户区运行virtio驱动，而不是在内核中运行 在这种情况下，virtio将驱动程序命名为管理内存和virtqueues的进程，而不是在guest中运行的内核代码</p>
<img src="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/2020-06-18-virtio-fig4.png" class="">

<p><em>Figure 4: Virtio-user with userland driver in guest</em></p>
<blockquote>
<p>Lastly, we can directly do a virtio device passthrough with the proper hardware. If the NIC supports the virtio data plane, we can expose it directly to the guest with proper hardware (IOMMU device, able to translate between the guest’s and device’s memory addresses) and software (for example, VFIO linux driver, that enables the host to directly give the control of a PCI device to the guest). The device uses the typical hardware signals for notifications infrastructure, like PCI and CPU interruptions (IRQ).</p>
</blockquote>
<p>最后，我们可以通过适当的硬件直接进行virtio设备透传。如果网卡支持virtio数据平面，我们可以通过适当的硬件（IOMMU设备，能够在guest和设备的内存地址之间进行转换）和软件（例如，VFIO linux驱动，使主机能够直接将PCI设备的控制权交给guest）将其直接暴露给guest。该设备使用典型的硬件信号来通知基础设施，如PCI和CPU中断（IRQ）。</p>
<blockquote>
<p>If a hardware NIC wants to go this way, the easiest approach is to build its driver on top of <a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/achieving-network-wirespeed-open-standard-manner-introducing-vdpa">vDPA</a>, also explained in earlier posts of this series.</p>
</blockquote>
<p>如果硬件网卡想走这条路，最简单的方法是在vDPA的基础上构建它的驱动程序，在本系列的早期文章中也有解释.</p>
<img src="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/2020-06-18-virtio-fig5.png" class="">

<p><em>Figure 5: Virtio hardware passthrough components diagram</em></p>
<blockquote>
<p>We will explain what happens inside of the dataplane communication in the rest of the posts.</p>
</blockquote>
<p>我们将在接下来的文章中解释数据平面通信内部发生了什么。</p>
<blockquote>
<p>Thanks to the deep investment in standardization, the virtio data plane is the same in whatever way we use across these scenarios, and whatever transport protocol we use. The format of the exchanged messages are the same, and different devices or drivers can negotiate different capabilities or features based on its characteristics using the feature bits, previously mentioned. This way, the virtqueues only act as a common thin layer of device-driver communication that allows to reduce the investment of development and deployment.</p>
</blockquote>
<p>由于对标准化的深入投资，virtio数据平面在这些场景中，无论我们使用什么方式，无论我们使用什么传输协议，都是一样的。交换的消息的格式是相同的，不同的设备或驱动程序可以根据它的特点，使用前面提到的特征位，协商不同的能力或特征。这样一来，虚拟队列只是作为设备-驱动程序通信的一个普通薄层，可以减少开发和部署的投资。</p>
<blockquote>
<p>As stated on <a target="_blank" rel="noopener" href="https://www.redhat.com/en/virtio-networking-series">previous blogs on this series</a>, the interest of this standardization is to achieve a slim layer of communication with the virtual environment (instead of emulating a complete piece of hardware), that makes it easier to verify for correctness across different virtualization technologies or hardware.</p>
</blockquote>
<p>正如本系列的前几篇博客所述，这种标准化的兴趣在于实现与虚拟环境的薄层通信（而不是模拟一个完整的硬件），这使得在不同的虚拟化技术或硬件之间验证正确性更加容易。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/" data-id="clefret8n0000t1wbey3l78ev" data-title="Virtio devices and drivers overview: The headjack and the phone" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/22/virtio-devices-and-drivers-overview-the-headjack-and-the-phone/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-windows-install-virtio-then-reboot-met-BSOD" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/" class="article-date">
  <time class="dt-published" datetime="2023-02-03T02:05:19.000Z" itemprop="datePublished">2023-02-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/">Windows install virtio then reboot met BSOD</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>This blog is a practice search about windows virtio driver installation.</p>
<h2 id="Backgroud"><a href="#Backgroud" class="headerlink" title="Backgroud"></a>Backgroud</h2><p>For virtualization software, normally guest will install virtio related drivers to get better virtualization performance. But instll virtio driver to windows guest sometimes became complex, so many softwares offer a practice guide about virtio dirver installation</p>
<table>
<thead>
<tr>
<th>Software</th>
<th>practice guide</th>
</tr>
</thead>
<tbody><tr>
<td>Proxmox</td>
<td><a target="_blank" rel="noopener" href="https://pve.proxmox.com/wiki/Windows_VirtIO_Drivers">https://pve.proxmox.com/wiki/Windows_VirtIO_Drivers</a> <br /><a target="_blank" rel="noopener" href="https://pve.proxmox.com/wiki/Windows_10_guest_best_practices">https://pve.proxmox.com/wiki/Windows_10_guest_best_practices</a></td>
</tr>
<tr>
<td>IBM Cloud orchestrator</td>
<td><a target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/cloud-orchestrator/2.5.0.3?topic=images-installing-virtio-driver-kvm-hypervisor-only">https://www.ibm.com/docs/en/cloud-orchestrator/2.5.0.3?topic=images-installing-virtio-driver-kvm-hypervisor-only</a></td>
</tr>
</tbody></table>
<p>the guide introduce that how to install virtio driver from win-virtio.iso while lauch windows install.</p>
<p>But in practice, if user want install driver to exists guest, windows still get BSOD after virtio driver installed.</p>
<p>So I write this blog to solve related problems.</p>
<h3 id="Newly-virtio-driver-installation"><a href="#Newly-virtio-driver-installation" class="headerlink" title="Newly virtio driver installation"></a>Newly virtio driver installation</h3><p>Windows running root disk attached to ide controller and install virtio driver. Then stop guest and move the disk from ide controller to virtio-serial controller, start guest will meet BSOD (no accessible boot device).</p>
<p>This is because windows do not load the virtio controller when install virtio driver to running vm.</p>
<p>According to P2V practice, how to inject virtio driver to a guest <a target="_blank" rel="noopener" href="https://portal.nutanix.com/page/documents/kbs/details?targetId=kA00e000000kAWeCAM">https://portal.nutanix.com/page/documents/kbs/details?targetId=kA00e000000kAWeCAM</a> </p>
<p>we need manually load driver</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drvload vioser.inf</span><br></pre></td></tr></table></figure>

<p>then install the driver to disk where windows installed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism &#x2F;image:c:\ &#x2F;add-driver &#x2F;driver:vioscsi.inf</span><br></pre></td></tr></table></figure>

<p>but if you try to do this on a running windows vm, dism will tell you that this operation is not allowed on a running windows. So the kv tell user to do the operation through cmd prompt when windows failed to boot not convinence if there are many guest need do this.</p>
<p>from superuser <a target="_blank" rel="noopener" href="https://superuser.com/questions/1057959/windows-10-in-kvm-change-boot-disk-to-virtio/1253728#1253728">https://superuser.com/questions/1057959/windows-10-in-kvm-change-boot-disk-to-virtio/1253728#1253728</a></p>
<p>other solution is raised, the best one is by setting guest into safeboot mode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;set &quot;&#123;current&#125;&quot; safeboot minimal</span><br></pre></td></tr></table></figure>

<p>windows will load all drivers then change the disk controller seems make sense, but still manually operation is required.</p>
<p>A tricky way is noticed by adding a dummy virtio disk to windows and then install virtio driver, the controller will be loaded at first.</p>
<p>the following steps I followed:</p>
<ol>
<li>Install the virtio driver in windows</li>
<li>Add a additional “dummy” virtio disk. Reboot and check if the “dummy” works.</li>
<li>If Step 2 works, then switch the boot disk to virtio.</li>
<li>Reboot</li>
<li>Remove the additional “dummy” virtio disk</li>
</ol>
<p>because we do not need to do more operation inside guest, so this solution can be changed to a automatic way.</p>
<p>And more discussion can be found on reddit:</p>
<blockquote>
<p>Looks like you’re having the issue of windows refusing to load the virtio storage drivers at boot.</p>
<p>The only thing I found that works for me is using this method - <a target="_blank" rel="noopener" href="https://superuser.com/a/1200899">https://superuser.com/a/1200899</a>. You can also try this method of adding another disk and installing the driver but I personally found that to be very hit and miss.</p>
<p>For the first method you need to use diskpart to assign drive letters to your windows drive and virtio iso this tutorial should help if you don’t know how to do it.</p>
</blockquote>
<p>but luckily, </p>
<blockquote>
<p>You need to install the virtio drivers on a per storage device basis.</p>
<p>I suggest swapping back to sata and add a empty virtio device to your guest. Then boot and install the virtio driver for the new the device. Last step is to delete the old sata device and mount the device image at the virtio device and boot your guest.</p>
<p>Make sure that libvirt didn’t changed the pcie address of your virtio device as windows registers the driver on a per device basis.</p>
</blockquote>
<p>the dummy disk work around can be used because the pci address acutally reused (as the virtio device will be removed and reboot)</p>
<p>This method works well when virtio drivers are newly added, but if you have booted guest with virtio driver installed, change the controller from ide to virtio is complex.</p>
<p>We prefer user to install virtio driver during first windows intallation and make it as a image to avoid controller change.</p>
<h2 id="Virtio-driver-already-installed"><a href="#Virtio-driver-already-installed" class="headerlink" title="Virtio driver already installed"></a>Virtio driver already installed</h2><p>While virtio already installed and reboot windows and the disk controller not changed. After reboot the boot disk is still ide. </p>
<p>If you attach virtio-blk disk to guest, it will be recognized and loaded right now. </p>
<p>But if follow the steps below to attach a dummy disk (in this case you attached a virtio-blk disk actually), change the ide controller to virtio will not work, windows kept report BSOD after changed.</p>
<p>Work around is uninstall the virtio driver and reinstall with the steps than reboot every will works.</p>
<p>I think maybe windows only load all drivers which are newly installed. But for existing driver, it only works per disk basis.</p>
<h2 id="Virtio-scsi-always-works"><a href="#Virtio-scsi-always-works" class="headerlink" title="Virtio-scsi always works"></a>Virtio-scsi always works</h2><p>Cheerfully, if you change the ide/sata controller to virtio-scsi controller after virtio driver installed, windows works well.</p>
<p>More performance test is needed because we kept use virtio-blk for root disk due to some version of virtio driver offered virtio-scsi has bad performance.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/" data-id="cldnw2sji0000r2cabzpp6s00" data-title="Windows install virtio then reboot met BSOD" class="article-share-link">Share</a>
      
      
        <a href="/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/03/windows-install-virtio-then-reboot-met-BSOD/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BSOD/" rel="tag">BSOD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/windows/" rel="tag">windows</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-live-migration-failed-due-to-libvirt-keepalive-timeout" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/13/live-migration-failed-due-to-libvirt-keepalive-timeout/" class="article-date">
  <time class="dt-published" datetime="2023-01-13T08:16:33.000Z" itemprop="datePublished">2023-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/virtualization/">virtualization</a>►<a class="article-category-link" href="/categories/virtualization/libvirt/">libvirt</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/13/live-migration-failed-due-to-libvirt-keepalive-timeout/">Live migration failed due to libvirt keepalive timeout</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Live migration is a important part of kvm virtualization at the first day it was designed. However when dive into control plane of libvirt live migration, it became quite complex. So I will describe the basic implementation about it at the early stage.</p>
<h2 id="Libvirt-QEMU-basic-building-blocks"><a href="#Libvirt-QEMU-basic-building-blocks" class="headerlink" title="Libvirt + QEMU basic building blocks"></a>Libvirt + QEMU basic building blocks</h2><p>For KVM based virtualization software, normally use libvirt + QEMU to manage guest’s lifecycle. And for live migration we have to know some basic part between libvirt and QEMU.</p>
<img src="/2023/01/13/live-migration-failed-due-to-libvirt-keepalive-timeout/libvirt+qemu.png" class="">

<p>the figure below introduces the basic parts and I just list those parts from left to right:</p>
<ul>
<li>virsh: a commandline interface to management domains</li>
<li>libvirt sdk: Python, Go… supported sdk to access libvirt by defined api</li>
<li>Libvirt api: exposed connect (the connection to libvirt), domain (guest), network (virtualization network of a hypervisor), storage volume (storage volume as block device which can be used by domain), storage pool (logically used for allocate and store storage volumes)</li>
<li>QEMU driver: libvirt driver of qemu, it will translate libvirt api invoke to related qemu operations</li>
<li>QEMU: a generic and open source machine emulator and virtualizer</li>
<li>qmp: QEMU machine protocol, is a JSON-based protocol, which allows applications to control a QEMU instance</li>
</ul>
<p>So when we do a live migration operation all those parts will be involved.</p>
<h2 id="Libvirt-live-migration"><a href="#Libvirt-live-migration" class="headerlink" title="Libvirt live migration"></a>Libvirt live migration</h2><p>For the control plane (libvirt), many concepts need to be introduced before we try to comprehensive its migration logic.</p>
<p>According to <a target="_blank" rel="noopener" href="https://libvirt.org/migration.html">https://libvirt.org/migration.html</a> there are two options for network data transport.</p>
<ul>
<li>Native transport: use qemu socket to transport data<ul>
<li>Require network between hypervisor (firewall issue should be solved)</li>
<li>Encryption support is depend on hypervisor</li>
<li>Better performance (minimising the number of data copies)</li>
</ul>
</li>
<li>Tunnelled transport: the data will be transported through libvirt RPC protocol<ul>
<li>Encryption supported</li>
<li>Less firewall issues</li>
<li>Worst performance (due to encryption)</li>
</ul>
</li>
</ul>
<p>And libvirt also support different control plane, the migration support have common features</p>
<ol>
<li>a peer2peer flag decide if we use client to connect to libvirtd servers or libvirtd server manage the connection itself</li>
<li>A destination URI with a form like ‘qemu+ssh://desthost/system’ for libvirtd connection</li>
<li>Data transport URI need a optional URI like ‘tcp://10.0.0.1/‘ means use TCP for data transport to hypervisor or libvirtd server</li>
<li>Normally libvirtd on target will automatically determine its native hypervisor URI so is not required in migratin api</li>
<li>If hypervisor do not offer encryption itself, tunnelled migration should be used</li>
<li>When libvirt daemon can not access network use unix migration</li>
<li>For vm with disks on non-shared storage, remember copy all storages</li>
</ol>
<p>Following are libvirt supported migrations and all available for qemu driver:</p>
<ul>
<li>Native migration, client to two libvirtd servers</li>
<li>Native migration, client to and peer2peer between two libvirtd servers</li>
<li>Tunnelled migration, client and peer2peer between two libvirtd servers</li>
<li>Native migration, client to one libvirtd server</li>
<li>Native migration, peer2peer between two libvirtd servers</li>
<li>Tunnelled migration, peer2peer between two libvirtd servers</li>
<li>Migration using UNIX sockets</li>
<li>Migration of VMs using non-shared images for disks</li>
</ul>
<h2 id="Libvirt-keepalive-of-client"><a href="#Libvirt-keepalive-of-client" class="headerlink" title="Libvirt keepalive of client"></a>Libvirt keepalive of client</h2><p>Libvirt use a C/S architecture and during migration libvirt need to support ‘client to two libvirtd servers’ or ‘client to and peer2peer between two libvirtd servers’. </p>
<p>So connection management between client and server or server and server is important for libvirt. And some common conserns for this architecture:</p>
<ul>
<li>Client and server connection<ul>
<li>Async task not relay on the connection if server implement idempotency<ul>
<li>Domain object lock help with idempotency</li>
</ul>
</li>
<li>Sync task relay on the connection<ul>
<li>All sync tasks should fail if connection keepalive timeout</li>
</ul>
</li>
</ul>
</li>
<li>Server and server connection<ul>
<li>Source server should be treated as client and same with client and server connection</li>
</ul>
</li>
</ul>
<p>In order to solve basic requirements, libvirt introduced keepalive for client connection. Client can set a keepalive timeout with interval and count (server should support this because a keepalive response is required). </p>
<p>Note: </p>
<ul>
<li>Default settings is configured from libvirtd.conf</li>
<li>If set keepalive timeout to 0 means disable keepalive for client</li>
</ul>
<p>The code from <code>src/rpc/virkeepalive.h</code> is quite easy:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">virKeepAlivePtr <span class="title">virKeepAliveNew</span><span class="params">(<span class="keyword">int</span> interval,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">void</span> *client,</span></span></span><br><span class="line"><span class="function"><span class="params">                                virKeepAliveSendFunc sendCB,</span></span></span><br><span class="line"><span class="function"><span class="params">                                virKeepAliveDeadFunc deadCB,</span></span></span><br><span class="line"><span class="function"><span class="params">                                virKeepAliveFreeFunc freeCB)</span></span></span><br><span class="line"><span class="function">                                <span class="title">ATTRIBUTE_NONNULL</span><span class="params">(<span class="number">3</span>)</span> <span class="title">ATTRIBUTE_NONNULL</span><span class="params">(<span class="number">4</span>)</span></span></span><br><span class="line"><span class="function">                                <span class="title">ATTRIBUTE_NONNULL</span><span class="params">(<span class="number">5</span>)</span> <span class="title">ATTRIBUTE_NONNULL</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">virKeepAliveStart</span><span class="params">(virKeepAlivePtr ka,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> interval,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">virKeepAliveStop</span><span class="params">(virKeepAlivePtr ka)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">virKeepAliveTimeout</span><span class="params">(virKeepAlivePtr ka)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">virKeepAliveTrigger</span><span class="params">(virKeepAlivePtr ka,</span></span></span><br><span class="line"><span class="function"><span class="params">                         virNetMessagePtr *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">virKeepAliveCheckMessage</span><span class="params">(virKeepAlivePtr ka,</span></span></span><br><span class="line"><span class="function"><span class="params">                              virNetMessagePtr msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                              virNetMessagePtr *response)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="For-libvirt-keepalive-timeout-issue"><a href="#For-libvirt-keepalive-timeout-issue" class="headerlink" title="For libvirt keepalive timeout issue"></a>For libvirt keepalive timeout issue</h2><p>The result from <a target="_blank" rel="noopener" href="https://bugzilla.redhat.com/show_bug.cgi?id=1367620">https://bugzilla.redhat.com/show_bug.cgi?id=1367620</a> butzilla explains a issue of live migration failure due to poor network and the connection between libvirtd servers down which will report a keepalive timeout error.</p>
<p>In libvirtd log (<a target="_blank" rel="noopener" href="https://libvirt.org/kbase/debuglogs.html">https://libvirt.org/kbase/debuglogs.html</a>) we could see:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2023-01-05 05:07:36.721+0000: 114785: info : virKeepAliveTimerInternal:131 : RPC_KEEPALIVE_TIMEOUT: ka&#x3D;0x7f6af4006c60 client&#x3D;0x7f6af400</span><br><span class="line">6a70 countToDeath&#x3D;0 idle&#x3D;30</span><br><span class="line">2023-01-05 05:07:36.721+0000: 114785: debug : virKeepAliveTimerInternal:136 : No response from client 0x7f6af4006a70 after 5 keepalive</span><br><span class="line">messages in 30 seconds</span><br><span class="line">2023-01-05 05:07:36.721+0000: 114785: error : virKeepAliveTimerInternal:138 : internal error: connection closed due to keepalive timeout</span><br></pre></td></tr></table></figure>

<p>And search for client=0x7f6af400 we can find it is a connection created during migration:</p>
<img src="/2023/01/13/live-migration-failed-due-to-libvirt-keepalive-timeout/libvirtd-migration-keepalive.png" class="">

<p>the dconn is the URI to destination libvirtd server.</p>
<p>For peer2peer live migration, this issue can be workaround by using seperate network for libvirtd connection and data transport.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanayo.cn/2023/01/13/live-migration-failed-due-to-libvirt-keepalive-timeout/" data-id="cld1mheak000qyuwb9r1kfm1f" data-title="Live migration failed due to libvirt keepalive timeout" class="article-share-link">Share</a>
      
      
        <a href="/2023/01/13/live-migration-failed-due-to-libvirt-keepalive-timeout/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/01/13/live-migration-failed-due-to-libvirt-keepalive-timeout/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/live-migration/" rel="tag">live-migration</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arch-notes/">arch-notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/devops/">devops</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/languages/">languages</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/languages/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/languages/python/">python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/memory-management/">memory management</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/management/">management</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project-related-works/">project-related-works</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/">virtualization</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/edk2-ovmf/">edk2-ovmf</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/kvm/">kvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/">translation</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/virtio/">virtio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/translation/virtio-networking/">virtio-networking</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/v2v/">v2v</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virtualization/virtio-balloon/">virtio-balloon</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BSOD/" rel="tag">BSOD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPDK/" rel="tag">DPDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElementTree/" rel="tag">ElementTree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDP/" rel="tag">TDP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TLB/" rel="tag">TLB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/architecture/" rel="tag">architecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code-reading/" rel="tag">code-reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/colo/" rel="tag">colo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/edk2-ovmf/" rel="tag">edk2-ovmf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ft/" rel="tag">ft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kvm/" rel="tag">kvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/live-migration/" rel="tag">live-migration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nessus/" rel="tag">nessus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nexus/" rel="tag">nexus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/others/" rel="tag">others</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/paper-reading/" rel="tag">paper-reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perf/" rel="tag">perf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/performance/" rel="tag">performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qemu/" rel="tag">qemu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes/" rel="tag">reading notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/software-arch/" rel="tag">software-arch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sysstat/" rel="tag">sysstat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/system-design/" rel="tag">system-design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/v2v/" rel="tag">v2v</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vDPA/" rel="tag">vDPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vhost-net/" rel="tag">vhost-net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virt/" rel="tag">virt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virt-top/" rel="tag">virt-top</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio/" rel="tag">virtio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-balloon/" rel="tag">virtio-balloon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-net/" rel="tag">virtio-net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtio-networking/" rel="tag">virtio-networking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BSOD/" style="font-size: 10px;">BSOD</a> <a href="/tags/DPDK/" style="font-size: 12.86px;">DPDK</a> <a href="/tags/ElementTree/" style="font-size: 10px;">ElementTree</a> <a href="/tags/TDP/" style="font-size: 11.43px;">TDP</a> <a href="/tags/TLB/" style="font-size: 10px;">TLB</a> <a href="/tags/architecture/" style="font-size: 18.57px;">architecture</a> <a href="/tags/code-reading/" style="font-size: 10px;">code-reading</a> <a href="/tags/colo/" style="font-size: 10px;">colo</a> <a href="/tags/cpu/" style="font-size: 11.43px;">cpu</a> <a href="/tags/edk2-ovmf/" style="font-size: 10px;">edk2-ovmf</a> <a href="/tags/ft/" style="font-size: 11.43px;">ft</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 12.86px;">java</a> <a href="/tags/kernel/" style="font-size: 14.29px;">kernel</a> <a href="/tags/kvm/" style="font-size: 15.71px;">kvm</a> <a href="/tags/libvirt/" style="font-size: 12.86px;">libvirt</a> <a href="/tags/linux/" style="font-size: 17.14px;">linux</a> <a href="/tags/live-migration/" style="font-size: 10px;">live-migration</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/nessus/" style="font-size: 10px;">nessus</a> <a href="/tags/nexus/" style="font-size: 10px;">nexus</a> <a href="/tags/others/" style="font-size: 10px;">others</a> <a href="/tags/paper-reading/" style="font-size: 10px;">paper-reading</a> <a href="/tags/perf/" style="font-size: 10px;">perf</a> <a href="/tags/performance/" style="font-size: 10px;">performance</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/qemu/" style="font-size: 20px;">qemu</a> <a href="/tags/reading-notes/" style="font-size: 10px;">reading notes</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/software-arch/" style="font-size: 12.86px;">software-arch</a> <a href="/tags/sysstat/" style="font-size: 10px;">sysstat</a> <a href="/tags/system-design/" style="font-size: 12.86px;">system-design</a> <a href="/tags/v2v/" style="font-size: 10px;">v2v</a> <a href="/tags/vDPA/" style="font-size: 10px;">vDPA</a> <a href="/tags/vhost-net/" style="font-size: 17.14px;">vhost-net</a> <a href="/tags/virt/" style="font-size: 14.29px;">virt</a> <a href="/tags/virt-top/" style="font-size: 10px;">virt-top</a> <a href="/tags/virtio/" style="font-size: 15.71px;">virtio</a> <a href="/tags/virtio-balloon/" style="font-size: 10px;">virtio-balloon</a> <a href="/tags/virtio-net/" style="font-size: 17.14px;">virtio-net</a> <a href="/tags/virtio-networking/" style="font-size: 17.14px;">virtio-networking</a> <a href="/tags/windows/" style="font-size: 10px;">windows</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/13/qemu-colo-details/">Qemu Colo Details</a>
          </li>
        
          <li>
            <a href="/2023/03/13/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">KVM虚拟化性能分析</a>
          </li>
        
          <li>
            <a href="/2023/03/09/cpu-features-about-kvm-hidden/">Cpu features about kvm hidden</a>
          </li>
        
          <li>
            <a href="/2023/03/03/virtio-on-linux/">Virtio on Linux</a>
          </li>
        
          <li>
            <a href="/2023/03/01/cpu-feature-configuration-code-diving/">Cpu feature configuration code diving</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a></br>
      
      &copy; 2023 Alan Jager<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = '' == true;
    var verify = 'false' == true;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "r30r51B3r5JFqlxR88Jua6So-gzGzoHsz",
        appKey: "wnL9j38siXbLqBHGnWpzmVxv",
        placeholder: "Just go go",
        pageSize:'10',
        avatar:'mm',
        lang:'zh-cn'
    });
</script>

  </div>
</body>
</html>